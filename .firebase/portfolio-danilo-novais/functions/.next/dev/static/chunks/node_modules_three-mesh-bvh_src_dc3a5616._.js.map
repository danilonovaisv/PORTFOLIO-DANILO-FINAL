{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/danilonovais/_danilonov_portfolio/node_modules/three-mesh-bvh/src/utils/ThreeRayIntersectUtilities.js"],"sourcesContent":["import { Vector3, Vector2, Triangle, DoubleSide, BackSide } from 'three';\n\n// Ripped and modified From THREE.js Mesh raycast\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L115\nconst vA = /* @__PURE__ */ new Vector3();\nconst vB = /* @__PURE__ */ new Vector3();\nconst vC = /* @__PURE__ */ new Vector3();\n\nconst uvA = /* @__PURE__ */ new Vector2();\nconst uvB = /* @__PURE__ */ new Vector2();\nconst uvC = /* @__PURE__ */ new Vector2();\n\nconst intersectionPoint = /* @__PURE__ */ new Vector3();\nfunction checkIntersection( ray, pA, pB, pC, point, side ) {\n\n\tlet intersect;\n\tif ( side === BackSide ) {\n\n\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t} else {\n\n\t\tintersect = ray.intersectTriangle( pA, pB, pC, side !== DoubleSide, point );\n\n\t}\n\n\tif ( intersect === null ) return null;\n\n\tconst distance = ray.origin.distanceTo( point );\n\n\treturn {\n\n\t\tdistance: distance,\n\t\tpoint: point.clone(),\n\n\t};\n\n}\n\nfunction checkBufferGeometryIntersection( ray, position, uv, a, b, c, side ) {\n\n\tvA.fromBufferAttribute( position, a );\n\tvB.fromBufferAttribute( position, b );\n\tvC.fromBufferAttribute( position, c );\n\n\tconst intersection = checkIntersection( ray, vA, vB, vC, intersectionPoint, side );\n\n\tif ( intersection ) {\n\n\t\tif ( uv ) {\n\n\t\t\tuvA.fromBufferAttribute( uv, a );\n\t\t\tuvB.fromBufferAttribute( uv, b );\n\t\t\tuvC.fromBufferAttribute( uv, c );\n\n\t\t\tintersection.uv = Triangle.getUV( intersectionPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2( ) );\n\n\t\t}\n\n\t\tconst face = {\n\t\t\ta: a,\n\t\t\tb: b,\n\t\t\tc: c,\n\t\t\tnormal: new Vector3(),\n\t\t\tmaterialIndex: 0\n\t\t};\n\n\t\tTriangle.getNormal( vA, vB, vC, face.normal );\n\n\t\tintersection.face = face;\n\t\tintersection.faceIndex = a;\n\n\t}\n\n\treturn intersection;\n\n}\n\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L258\nfunction intersectTri( geo, side, ray, tri, intersections ) {\n\n\tconst triOffset = tri * 3;\n\tconst a = geo.index.getX( triOffset );\n\tconst b = geo.index.getX( triOffset + 1 );\n\tconst c = geo.index.getX( triOffset + 2 );\n\n\tconst intersection = checkBufferGeometryIntersection( ray, geo.attributes.position, geo.attributes.uv, a, b, c, side );\n\n\tif ( intersection ) {\n\n\t\tintersection.faceIndex = tri;\n\t\tif ( intersections ) intersections.push( intersection );\n\t\treturn intersection;\n\n\t}\n\n\treturn null;\n\n}\n\nexport { intersectTri };\n"],"names":[],"mappings":";;;;AAAA;;AAEA,iDAAiD;AACjD,4GAA4G;AAC5G,MAAM,KAAK,aAAa,GAAG,IAAI,+JAAO;AACtC,MAAM,KAAK,aAAa,GAAG,IAAI,+JAAO;AACtC,MAAM,KAAK,aAAa,GAAG,IAAI,+JAAO;AAEtC,MAAM,MAAM,aAAa,GAAG,IAAI,+JAAO;AACvC,MAAM,MAAM,aAAa,GAAG,IAAI,+JAAO;AACvC,MAAM,MAAM,aAAa,GAAG,IAAI,+JAAO;AAEvC,MAAM,oBAAoB,aAAa,GAAG,IAAI,+JAAO;AACrD,SAAS,kBAAmB,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,KAAK,EAAE,IAAI;IAEvD,IAAI;IACJ,IAAK,SAAS,gKAAQ,EAAG;QAExB,YAAY,IAAI,iBAAiB,CAAE,IAAI,IAAI,IAAI,MAAM;IAEtD,OAAO;QAEN,YAAY,IAAI,iBAAiB,CAAE,IAAI,IAAI,IAAI,SAAS,kKAAU,EAAE;IAErE;IAEA,IAAK,cAAc,MAAO,OAAO;IAEjC,MAAM,WAAW,IAAI,MAAM,CAAC,UAAU,CAAE;IAExC,OAAO;QAEN,UAAU;QACV,OAAO,MAAM,KAAK;IAEnB;AAED;AAEA,SAAS,gCAAiC,GAAG,EAAE,QAAQ,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,IAAI;IAEzE,GAAG,mBAAmB,CAAE,UAAU;IAClC,GAAG,mBAAmB,CAAE,UAAU;IAClC,GAAG,mBAAmB,CAAE,UAAU;IAElC,MAAM,eAAe,kBAAmB,KAAK,IAAI,IAAI,IAAI,mBAAmB;IAE5E,IAAK,cAAe;QAEnB,IAAK,IAAK;YAET,IAAI,mBAAmB,CAAE,IAAI;YAC7B,IAAI,mBAAmB,CAAE,IAAI;YAC7B,IAAI,mBAAmB,CAAE,IAAI;YAE7B,aAAa,EAAE,GAAG,gKAAQ,CAAC,KAAK,CAAE,mBAAmB,IAAI,IAAI,IAAI,KAAK,KAAK,KAAK,IAAI,+JAAO;QAE5F;QAEA,MAAM,OAAO;YACZ,GAAG;YACH,GAAG;YACH,GAAG;YACH,QAAQ,IAAI,+JAAO;YACnB,eAAe;QAChB;QAEA,gKAAQ,CAAC,SAAS,CAAE,IAAI,IAAI,IAAI,KAAK,MAAM;QAE3C,aAAa,IAAI,GAAG;QACpB,aAAa,SAAS,GAAG;IAE1B;IAEA,OAAO;AAER;AAEA,4GAA4G;AAC5G,SAAS,aAAc,GAAG,EAAE,IAAI,EAAE,GAAG,EAAE,GAAG,EAAE,aAAa;IAExD,MAAM,YAAY,MAAM;IACxB,MAAM,IAAI,IAAI,KAAK,CAAC,IAAI,CAAE;IAC1B,MAAM,IAAI,IAAI,KAAK,CAAC,IAAI,CAAE,YAAY;IACtC,MAAM,IAAI,IAAI,KAAK,CAAC,IAAI,CAAE,YAAY;IAEtC,MAAM,eAAe,gCAAiC,KAAK,IAAI,UAAU,CAAC,QAAQ,EAAE,IAAI,UAAU,CAAC,EAAE,EAAE,GAAG,GAAG,GAAG;IAEhH,IAAK,cAAe;QAEnB,aAAa,SAAS,GAAG;QACzB,IAAK,eAAgB,cAAc,IAAI,CAAE;QACzC,OAAO;IAER;IAEA,OAAO;AAER","ignoreList":[0]}},
    {"offset": {"line": 77, "column": 0}, "map": {"version":3,"sources":["file:///Users/danilonovais/_danilonov_portfolio/node_modules/three-mesh-bvh/src/utils/GeometryRayIntersectUtilities.js"],"sourcesContent":["import { intersectTri } from './ThreeRayIntersectUtilities.js';\n\nexport function intersectTris( geo, side, ray, offset, count, intersections ) {\n\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tintersectTri( geo, side, ray, i, intersections );\n\n\t}\n\n}\n\nexport function intersectClosestTri( geo, side, ray, offset, count ) {\n\n\tlet dist = Infinity;\n\tlet res = null;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tconst intersection = intersectTri( geo, side, ray, i );\n\t\tif ( intersection && intersection.distance < dist ) {\n\n\t\t\tres = intersection;\n\t\t\tdist = intersection.distance;\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\n// converts the given BVH raycast intersection to align with the three.js raycast\n// structure (include object, world space distance and point).\nexport function convertRaycastIntersect( hit, object, raycaster ) {\n\n\tif ( hit === null ) {\n\n\t\treturn null;\n\n\t}\n\n\thit.point.applyMatrix4( object.matrixWorld );\n\thit.distance = hit.point.distanceTo( raycaster.ray.origin );\n\thit.object = object;\n\n\tif ( hit.distance < raycaster.near || hit.distance > raycaster.far ) {\n\n\t\treturn null;\n\n\t} else {\n\n\t\treturn hit;\n\n\t}\n\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;;AAEO,SAAS,cAAe,GAAG,EAAE,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,KAAK,EAAE,aAAa;IAE1E,IAAM,IAAI,IAAI,QAAQ,MAAM,SAAS,OAAO,IAAI,KAAK,IAAO;QAE3D,IAAA,qMAAY,EAAE,KAAK,MAAM,KAAK,GAAG;IAElC;AAED;AAEO,SAAS,oBAAqB,GAAG,EAAE,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,KAAK;IAEjE,IAAI,OAAO;IACX,IAAI,MAAM;IACV,IAAM,IAAI,IAAI,QAAQ,MAAM,SAAS,OAAO,IAAI,KAAK,IAAO;QAE3D,MAAM,eAAe,IAAA,qMAAY,EAAE,KAAK,MAAM,KAAK;QACnD,IAAK,gBAAgB,aAAa,QAAQ,GAAG,MAAO;YAEnD,MAAM;YACN,OAAO,aAAa,QAAQ;QAE7B;IAED;IAEA,OAAO;AAER;AAIO,SAAS,wBAAyB,GAAG,EAAE,MAAM,EAAE,SAAS;IAE9D,IAAK,QAAQ,MAAO;QAEnB,OAAO;IAER;IAEA,IAAI,KAAK,CAAC,YAAY,CAAE,OAAO,WAAW;IAC1C,IAAI,QAAQ,GAAG,IAAI,KAAK,CAAC,UAAU,CAAE,UAAU,GAAG,CAAC,MAAM;IACzD,IAAI,MAAM,GAAG;IAEb,IAAK,IAAI,QAAQ,GAAG,UAAU,IAAI,IAAI,IAAI,QAAQ,GAAG,UAAU,GAAG,EAAG;QAEpE,OAAO;IAER,OAAO;QAEN,OAAO;IAER;AAED","ignoreList":[0]}},
    {"offset": {"line": 121, "column": 0}, "map": {"version":3,"sources":["file:///Users/danilonovais/_danilonov_portfolio/node_modules/three-mesh-bvh/src/core/Constants.js"],"sourcesContent":["// Split strategy constants\nexport const CENTER = 0;\nexport const AVERAGE = 1;\nexport const SAH = 2;\n\n// Traversal constants\nexport const NOT_INTERSECTED = 0;\nexport const INTERSECTED = 1;\nexport const CONTAINED = 2;\n\n// SAH cost constants\n// TODO: hone these costs more. The relative difference between them should be the\n// difference in measured time to perform a triangle intersection vs traversing\n// bounds.\nexport const TRIANGLE_INTERSECT_COST = 1.25;\nexport const TRAVERSAL_COST = 1;\n\n\n// Build constants\nexport const BYTES_PER_NODE = 6 * 4 + 4 + 4;\nexport const IS_LEAFNODE_FLAG = 0xFFFF;\n\n// EPSILON for computing floating point error during build\n// https://en.wikipedia.org/wiki/Machine_epsilon#Values_for_standard_hardware_floating_point_arithmetics\nexport const FLOAT32_EPSILON = Math.pow( 2, - 24 );\n\n"],"names":[],"mappings":"AAAA,2BAA2B;;;;;;;;;;;;;;;;;;;;;;;;;AACpB,MAAM,SAAS;AACf,MAAM,UAAU;AAChB,MAAM,MAAM;AAGZ,MAAM,kBAAkB;AACxB,MAAM,cAAc;AACpB,MAAM,YAAY;AAMlB,MAAM,0BAA0B;AAChC,MAAM,iBAAiB;AAIvB,MAAM,iBAAiB,IAAI,IAAI,IAAI;AACnC,MAAM,mBAAmB;AAIzB,MAAM,kBAAkB,KAAK,GAAG,CAAE,GAAG,CAAE","ignoreList":[0]}},
    {"offset": {"line": 161, "column": 0}, "map": {"version":3,"sources":["file:///Users/danilonovais/_danilonov_portfolio/node_modules/three-mesh-bvh/src/core/MeshBVHNode.js"],"sourcesContent":["export class MeshBVHNode {\n\n\tconstructor() {\n\n\t\t// internal nodes have boundingData, left, right, and splitAxis\n\t\t// leaf nodes have offset and count (referring to primitives in the mesh geometry)\n\n\t}\n\n}\n"],"names":[],"mappings":";;;;AAAO,MAAM;IAEZ,aAAc;IAEb,+DAA+D;IAC/D,kFAAkF;IAEnF;AAED","ignoreList":[0]}},
    {"offset": {"line": 175, "column": 0}, "map": {"version":3,"sources":["file:///Users/danilonovais/_danilonov_portfolio/node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js"],"sourcesContent":["export function arrayToBox( nodeIndex32, array, target ) {\n\n\ttarget.min.x = array[ nodeIndex32 ];\n\ttarget.min.y = array[ nodeIndex32 + 1 ];\n\ttarget.min.z = array[ nodeIndex32 + 2 ];\n\n\ttarget.max.x = array[ nodeIndex32 + 3 ];\n\ttarget.max.y = array[ nodeIndex32 + 4 ];\n\ttarget.max.z = array[ nodeIndex32 + 5 ];\n\n\treturn target;\n\n}\n\nexport function getLongestEdgeIndex( bounds ) {\n\n\tlet splitDimIdx = - 1;\n\tlet splitDist = - Infinity;\n\n\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\tconst dist = bounds[ i + 3 ] - bounds[ i ];\n\t\tif ( dist > splitDist ) {\n\n\t\t\tsplitDist = dist;\n\t\t\tsplitDimIdx = i;\n\n\t\t}\n\n\t}\n\n\treturn splitDimIdx;\n\n}\n\n// copies bounds a into bounds b\nexport function copyBounds( source, target ) {\n\n\ttarget.set( source );\n\n}\n\n// sets bounds target to the union of bounds a and b\nexport function unionBounds( a, b, target ) {\n\n\tlet aVal, bVal;\n\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\tconst d3 = d + 3;\n\n\t\t// set the minimum values\n\t\taVal = a[ d ];\n\t\tbVal = b[ d ];\n\t\ttarget[ d ] = aVal < bVal ? aVal : bVal;\n\n\t\t// set the max values\n\t\taVal = a[ d3 ];\n\t\tbVal = b[ d3 ];\n\t\ttarget[ d3 ] = aVal > bVal ? aVal : bVal;\n\n\t}\n\n}\n\n// expands the given bounds by the provided triangle bounds\nexport function expandByTriangleBounds( startIndex, triangleBounds, bounds ) {\n\n\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\tconst tCenter = triangleBounds[ startIndex + 2 * d ];\n\t\tconst tHalf = triangleBounds[ startIndex + 2 * d + 1 ];\n\n\t\tconst tMin = tCenter - tHalf;\n\t\tconst tMax = tCenter + tHalf;\n\n\t\tif ( tMin < bounds[ d ] ) {\n\n\t\t\tbounds[ d ] = tMin;\n\n\t\t}\n\n\t\tif ( tMax > bounds[ d + 3 ] ) {\n\n\t\t\tbounds[ d + 3 ] = tMax;\n\n\t\t}\n\n\t}\n\n}\n\n// compute bounds surface area\nexport function computeSurfaceArea( bounds ) {\n\n\tconst d0 = bounds[ 3 ] - bounds[ 0 ];\n\tconst d1 = bounds[ 4 ] - bounds[ 1 ];\n\tconst d2 = bounds[ 5 ] - bounds[ 2 ];\n\n\treturn 2 * ( d0 * d1 + d1 * d2 + d2 * d0 );\n\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAAO,SAAS,WAAY,WAAW,EAAE,KAAK,EAAE,MAAM;IAErD,OAAO,GAAG,CAAC,CAAC,GAAG,KAAK,CAAE,YAAa;IACnC,OAAO,GAAG,CAAC,CAAC,GAAG,KAAK,CAAE,cAAc,EAAG;IACvC,OAAO,GAAG,CAAC,CAAC,GAAG,KAAK,CAAE,cAAc,EAAG;IAEvC,OAAO,GAAG,CAAC,CAAC,GAAG,KAAK,CAAE,cAAc,EAAG;IACvC,OAAO,GAAG,CAAC,CAAC,GAAG,KAAK,CAAE,cAAc,EAAG;IACvC,OAAO,GAAG,CAAC,CAAC,GAAG,KAAK,CAAE,cAAc,EAAG;IAEvC,OAAO;AAER;AAEO,SAAS,oBAAqB,MAAM;IAE1C,IAAI,cAAc,CAAE;IACpB,IAAI,YAAY,CAAE;IAElB,IAAM,IAAI,IAAI,GAAG,IAAI,GAAG,IAAO;QAE9B,MAAM,OAAO,MAAM,CAAE,IAAI,EAAG,GAAG,MAAM,CAAE,EAAG;QAC1C,IAAK,OAAO,WAAY;YAEvB,YAAY;YACZ,cAAc;QAEf;IAED;IAEA,OAAO;AAER;AAGO,SAAS,WAAY,MAAM,EAAE,MAAM;IAEzC,OAAO,GAAG,CAAE;AAEb;AAGO,SAAS,YAAa,CAAC,EAAE,CAAC,EAAE,MAAM;IAExC,IAAI,MAAM;IACV,IAAM,IAAI,IAAI,GAAG,IAAI,GAAG,IAAO;QAE9B,MAAM,KAAK,IAAI;QAEf,yBAAyB;QACzB,OAAO,CAAC,CAAE,EAAG;QACb,OAAO,CAAC,CAAE,EAAG;QACb,MAAM,CAAE,EAAG,GAAG,OAAO,OAAO,OAAO;QAEnC,qBAAqB;QACrB,OAAO,CAAC,CAAE,GAAI;QACd,OAAO,CAAC,CAAE,GAAI;QACd,MAAM,CAAE,GAAI,GAAG,OAAO,OAAO,OAAO;IAErC;AAED;AAGO,SAAS,uBAAwB,UAAU,EAAE,cAAc,EAAE,MAAM;IAEzE,IAAM,IAAI,IAAI,GAAG,IAAI,GAAG,IAAO;QAE9B,MAAM,UAAU,cAAc,CAAE,aAAa,IAAI,EAAG;QACpD,MAAM,QAAQ,cAAc,CAAE,aAAa,IAAI,IAAI,EAAG;QAEtD,MAAM,OAAO,UAAU;QACvB,MAAM,OAAO,UAAU;QAEvB,IAAK,OAAO,MAAM,CAAE,EAAG,EAAG;YAEzB,MAAM,CAAE,EAAG,GAAG;QAEf;QAEA,IAAK,OAAO,MAAM,CAAE,IAAI,EAAG,EAAG;YAE7B,MAAM,CAAE,IAAI,EAAG,GAAG;QAEnB;IAED;AAED;AAGO,SAAS,mBAAoB,MAAM;IAEzC,MAAM,KAAK,MAAM,CAAE,EAAG,GAAG,MAAM,CAAE,EAAG;IACpC,MAAM,KAAK,MAAM,CAAE,EAAG,GAAG,MAAM,CAAE,EAAG;IACpC,MAAM,KAAK,MAAM,CAAE,EAAG,GAAG,MAAM,CAAE,EAAG;IAEpC,OAAO,IAAI,CAAE,KAAK,KAAK,KAAK,KAAK,KAAK,EAAG;AAE1C","ignoreList":[0]}},
    {"offset": {"line": 251, "column": 0}, "map": {"version":3,"sources":["file:///Users/danilonovais/_danilonov_portfolio/node_modules/three-mesh-bvh/src/core/buildFunctions.js"],"sourcesContent":["import { BufferAttribute } from 'three';\nimport { MeshBVHNode } from './MeshBVHNode.js';\nimport { getLongestEdgeIndex, computeSurfaceArea, copyBounds, unionBounds, expandByTriangleBounds } from '../utils/ArrayBoxUtilities.js';\nimport {\n\tCENTER, AVERAGE, SAH, TRIANGLE_INTERSECT_COST, TRAVERSAL_COST,\n\tBYTES_PER_NODE, FLOAT32_EPSILON, IS_LEAFNODE_FLAG,\n} from './Constants.js';\n\nfunction ensureIndex( geo, options ) {\n\n\tif ( ! geo.index ) {\n\n\t\tconst vertexCount = geo.attributes.position.count;\n\t\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\t\tlet index;\n\t\tif ( vertexCount > 65535 ) {\n\n\t\t\tindex = new Uint32Array( new BufferConstructor( 4 * vertexCount ) );\n\n\t\t} else {\n\n\t\t\tindex = new Uint16Array( new BufferConstructor( 2 * vertexCount ) );\n\n\t\t}\n\n\t\tgeo.setIndex( new BufferAttribute( index, 1 ) );\n\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\tindex[ i ] = i;\n\n\t\t}\n\n\t}\n\n}\n\n// Computes the set of { offset, count } ranges which need independent BVH roots. Each\n// region in the geometry index that belongs to a different set of material groups requires\n// a separate BVH root, so that triangles indices belonging to one group never get swapped\n// with triangle indices belongs to another group. For example, if the groups were like this:\n//\n// [-------------------------------------------------------------]\n// |__________________|\n//   g0 = [0, 20]  |______________________||_____________________|\n//                      g1 = [16, 40]           g2 = [41, 60]\n//\n// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\nfunction getRootIndexRanges( geo ) {\n\n\tif ( ! geo.groups || ! geo.groups.length ) {\n\n\t\treturn [ { offset: 0, count: geo.index.count / 3 } ];\n\n\t}\n\n\tconst ranges = [];\n\tconst rangeBoundaries = new Set();\n\tfor ( const group of geo.groups ) {\n\n\t\trangeBoundaries.add( group.start );\n\t\trangeBoundaries.add( group.start + group.count );\n\n\t}\n\n\t// note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\n\tconst sortedBoundaries = Array.from( rangeBoundaries.values() ).sort( ( a, b ) => a - b );\n\tfor ( let i = 0; i < sortedBoundaries.length - 1; i ++ ) {\n\n\t\tconst start = sortedBoundaries[ i ], end = sortedBoundaries[ i + 1 ];\n\t\tranges.push( { offset: ( start / 3 ), count: ( end - start ) / 3 } );\n\n\t}\n\n\treturn ranges;\n\n}\n\n// computes the union of the bounds of all of the given triangles and puts the resulting box in target. If\n// centroidTarget is provided then a bounding box is computed for the centroids of the triangles, as well.\n// These are computed together to avoid redundant accesses to bounds array.\nfunction getBounds( triangleBounds, offset, count, target, centroidTarget = null ) {\n\n\tlet minx = Infinity;\n\tlet miny = Infinity;\n\tlet minz = Infinity;\n\tlet maxx = - Infinity;\n\tlet maxy = - Infinity;\n\tlet maxz = - Infinity;\n\n\tlet cminx = Infinity;\n\tlet cminy = Infinity;\n\tlet cminz = Infinity;\n\tlet cmaxx = - Infinity;\n\tlet cmaxy = - Infinity;\n\tlet cmaxz = - Infinity;\n\n\tconst includeCentroid = centroidTarget !== null;\n\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\n\n\t\tconst cx = triangleBounds[ i + 0 ];\n\t\tconst hx = triangleBounds[ i + 1 ];\n\t\tconst lx = cx - hx;\n\t\tconst rx = cx + hx;\n\t\tif ( lx < minx ) minx = lx;\n\t\tif ( rx > maxx ) maxx = rx;\n\t\tif ( includeCentroid && cx < cminx ) cminx = cx;\n\t\tif ( includeCentroid && cx > cmaxx ) cmaxx = cx;\n\n\t\tconst cy = triangleBounds[ i + 2 ];\n\t\tconst hy = triangleBounds[ i + 3 ];\n\t\tconst ly = cy - hy;\n\t\tconst ry = cy + hy;\n\t\tif ( ly < miny ) miny = ly;\n\t\tif ( ry > maxy ) maxy = ry;\n\t\tif ( includeCentroid && cy < cminy ) cminy = cy;\n\t\tif ( includeCentroid && cy > cmaxy ) cmaxy = cy;\n\n\t\tconst cz = triangleBounds[ i + 4 ];\n\t\tconst hz = triangleBounds[ i + 5 ];\n\t\tconst lz = cz - hz;\n\t\tconst rz = cz + hz;\n\t\tif ( lz < minz ) minz = lz;\n\t\tif ( rz > maxz ) maxz = rz;\n\t\tif ( includeCentroid && cz < cminz ) cminz = cz;\n\t\tif ( includeCentroid && cz > cmaxz ) cmaxz = cz;\n\n\t}\n\n\ttarget[ 0 ] = minx;\n\ttarget[ 1 ] = miny;\n\ttarget[ 2 ] = minz;\n\n\ttarget[ 3 ] = maxx;\n\ttarget[ 4 ] = maxy;\n\ttarget[ 5 ] = maxz;\n\n\tif ( includeCentroid ) {\n\n\t\tcentroidTarget[ 0 ] = cminx;\n\t\tcentroidTarget[ 1 ] = cminy;\n\t\tcentroidTarget[ 2 ] = cminz;\n\n\t\tcentroidTarget[ 3 ] = cmaxx;\n\t\tcentroidTarget[ 4 ] = cmaxy;\n\t\tcentroidTarget[ 5 ] = cmaxz;\n\n\t}\n\n}\n\n// A stand alone function for retrieving the centroid bounds.\nfunction getCentroidBounds( triangleBounds, offset, count, centroidTarget ) {\n\n\tlet cminx = Infinity;\n\tlet cminy = Infinity;\n\tlet cminz = Infinity;\n\tlet cmaxx = - Infinity;\n\tlet cmaxy = - Infinity;\n\tlet cmaxz = - Infinity;\n\n\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\n\n\t\tconst cx = triangleBounds[ i + 0 ];\n\t\tif ( cx < cminx ) cminx = cx;\n\t\tif ( cx > cmaxx ) cmaxx = cx;\n\n\t\tconst cy = triangleBounds[ i + 2 ];\n\t\tif ( cy < cminy ) cminy = cy;\n\t\tif ( cy > cmaxy ) cmaxy = cy;\n\n\t\tconst cz = triangleBounds[ i + 4 ];\n\t\tif ( cz < cminz ) cminz = cz;\n\t\tif ( cz > cmaxz ) cmaxz = cz;\n\n\t}\n\n\tcentroidTarget[ 0 ] = cminx;\n\tcentroidTarget[ 1 ] = cminy;\n\tcentroidTarget[ 2 ] = cminz;\n\n\tcentroidTarget[ 3 ] = cmaxx;\n\tcentroidTarget[ 4 ] = cmaxy;\n\tcentroidTarget[ 5 ] = cmaxz;\n\n}\n\n\n// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nfunction partition( index, triangleBounds, offset, count, split ) {\n\n\tlet left = offset;\n\tlet right = offset + count - 1;\n\tconst pos = split.pos;\n\tconst axisOffset = split.axis * 2;\n\n\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n\twhile ( true ) {\n\n\t\twhile ( left <= right && triangleBounds[ left * 6 + axisOffset ] < pos ) {\n\n\t\t\tleft ++;\n\n\t\t}\n\n\n\t\t// if a triangle center lies on the partition plane it is considered to be on the right side\n\t\twhile ( left <= right && triangleBounds[ right * 6 + axisOffset ] >= pos ) {\n\n\t\t\tright --;\n\n\t\t}\n\n\t\tif ( left < right ) {\n\n\t\t\t// we need to swap all of the information associated with the triangles at index\n\t\t\t// left and right; that's the verts in the geometry index, the bounds,\n\t\t\t// and perhaps the SAH planes\n\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tlet t0 = index[ left * 3 + i ];\n\t\t\t\tindex[ left * 3 + i ] = index[ right * 3 + i ];\n\t\t\t\tindex[ right * 3 + i ] = t0;\n\n\t\t\t\tlet t1 = triangleBounds[ left * 6 + i * 2 + 0 ];\n\t\t\t\ttriangleBounds[ left * 6 + i * 2 + 0 ] = triangleBounds[ right * 6 + i * 2 + 0 ];\n\t\t\t\ttriangleBounds[ right * 6 + i * 2 + 0 ] = t1;\n\n\t\t\t\tlet t2 = triangleBounds[ left * 6 + i * 2 + 1 ];\n\t\t\t\ttriangleBounds[ left * 6 + i * 2 + 1 ] = triangleBounds[ right * 6 + i * 2 + 1 ];\n\t\t\t\ttriangleBounds[ right * 6 + i * 2 + 1 ] = t2;\n\n\t\t\t}\n\n\t\t\tleft ++;\n\t\t\tright --;\n\n\t\t} else {\n\n\t\t\treturn left;\n\n\t\t}\n\n\t}\n\n}\n\nconst BIN_COUNT = 32;\nconst binsSort = ( a, b ) => a.candidate - b.candidate;\nconst sahBins = new Array( BIN_COUNT ).fill().map( () => {\n\n\treturn {\n\n\t\tcount: 0,\n\t\tbounds: new Float32Array( 6 ),\n\t\trightCacheBounds: new Float32Array( 6 ),\n\t\tleftCacheBounds: new Float32Array( 6 ),\n\t\tcandidate: 0,\n\n\t};\n\n} );\nconst leftBounds = new Float32Array( 6 );\n\nfunction getOptimalSplit( nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy ) {\n\n\tlet axis = - 1;\n\tlet pos = 0;\n\n\t// Center\n\tif ( strategy === CENTER ) {\n\n\t\taxis = getLongestEdgeIndex( centroidBoundingData );\n\t\tif ( axis !== - 1 ) {\n\n\t\t\tpos = ( centroidBoundingData[ axis ] + centroidBoundingData[ axis + 3 ] ) / 2;\n\n\t\t}\n\n\t} else if ( strategy === AVERAGE ) {\n\n\t\taxis = getLongestEdgeIndex( nodeBoundingData );\n\t\tif ( axis !== - 1 ) {\n\n\t\t\tpos = getAverage( triangleBounds, offset, count, axis );\n\n\t\t}\n\n\t} else if ( strategy === SAH ) {\n\n\t\tconst rootSurfaceArea = computeSurfaceArea( nodeBoundingData );\n\t\tlet bestCost = TRIANGLE_INTERSECT_COST * count;\n\n\t\t// iterate over all axes\n\t\tconst cStart = offset * 6;\n\t\tconst cEnd = ( offset + count ) * 6;\n\t\tfor ( let a = 0; a < 3; a ++ ) {\n\n\t\t\tconst axisLeft = centroidBoundingData[ a ];\n\t\t\tconst axisRight = centroidBoundingData[ a + 3 ];\n\t\t\tconst axisLength = axisRight - axisLeft;\n\t\t\tconst binWidth = axisLength / BIN_COUNT;\n\n\t\t\t// If we have fewer triangles than we're planning to split then just check all\n\t\t\t// the triangle positions because it will be faster.\n\t\t\tif ( count < BIN_COUNT / 4 ) {\n\n\t\t\t\t// initialize the bin candidates\n\t\t\t\tconst truncatedBins = [ ...sahBins ];\n\t\t\t\ttruncatedBins.length = count;\n\n\t\t\t\t// set the candidates\n\t\t\t\tlet b = 0;\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6, b ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ b ];\n\t\t\t\t\tbin.candidate = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tbin.count = 0;\n\n\t\t\t\t\tconst {\n\t\t\t\t\t\tbounds,\n\t\t\t\t\t\tleftCacheBounds,\n\t\t\t\t\t\trightCacheBounds,\n\t\t\t\t\t} = bin;\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\trightCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\trightCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\tleftCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\tleftCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t}\n\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bounds );\n\n\t\t\t\t}\n\n\t\t\t\ttruncatedBins.sort( binsSort );\n\n\t\t\t\t// remove redundant splits\n\t\t\t\tlet splitCount = count;\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\twhile ( bi + 1 < splitCount && truncatedBins[ bi + 1 ].candidate === bin.candidate ) {\n\n\t\t\t\t\t\ttruncatedBins.splice( bi + 1, 1 );\n\t\t\t\t\t\tsplitCount --;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// find the appropriate bin for each triangle and expand the bounds.\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\tconst center = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\t\tif ( center >= bin.candidate ) {\n\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.rightCacheBounds );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.leftCacheBounds );\n\t\t\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// expand all the bounds\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\tconst leftCount = bin.count;\n\t\t\t\t\tconst rightCount = count - bin.count;\n\n\t\t\t\t\t// check the cost of this split\n\t\t\t\t\tconst leftBounds = bin.leftCacheBounds;\n\t\t\t\t\tconst rightBounds = bin.rightCacheBounds;\n\n\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet rightProb = 0;\n\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// reset the bins\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT; i ++ ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tbin.count = 0;\n\t\t\t\t\tbin.candidate = axisLeft + binWidth + i * binWidth;\n\n\t\t\t\t\tconst bounds = bin.bounds;\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// iterate over all center positions\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\tconst triCenter = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tconst relativeCenter = triCenter - axisLeft;\n\n\t\t\t\t\t// in the partition function if the centroid lies on the split plane then it is\n\t\t\t\t\t// considered to be on the right side of the split\n\t\t\t\t\tlet binIndex = ~ ~ ( relativeCenter / binWidth );\n\t\t\t\t\tif ( binIndex >= BIN_COUNT ) binIndex = BIN_COUNT - 1;\n\n\t\t\t\t\tconst bin = sahBins[ binIndex ];\n\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.bounds );\n\n\t\t\t\t}\n\n\t\t\t\t// cache the unioned bounds from right to left so we don't have to regenerate them each time\n\t\t\t\tconst lastBin = sahBins[ BIN_COUNT - 1 ];\n\t\t\t\tcopyBounds( lastBin.bounds, lastBin.rightCacheBounds );\n\t\t\t\tfor ( let i = BIN_COUNT - 2; i >= 0; i -- ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\tunionBounds( bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds );\n\n\t\t\t\t}\n\n\t\t\t\tlet leftCount = 0;\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT - 1; i ++ ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tconst binCount = bin.count;\n\t\t\t\t\tconst bounds = bin.bounds;\n\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\tconst rightBounds = nextBin.rightCacheBounds;\n\n\t\t\t\t\t// don't do anything with the bounds if the new bounds have no triangles\n\t\t\t\t\tif ( binCount !== 0 ) {\n\n\t\t\t\t\t\tif ( leftCount === 0 ) {\n\n\t\t\t\t\t\t\tcopyBounds( bounds, leftBounds );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tunionBounds( bounds, leftBounds, leftBounds );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tleftCount += binCount;\n\n\t\t\t\t\t// check the cost of this split\n\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\tlet rightProb = 0;\n\n\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst rightCount = count - leftCount;\n\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\tconsole.warn( `MeshBVH: Invalid build strategy value ${ strategy } used.` );\n\n\t}\n\n\treturn { axis, pos };\n\n}\n\n// returns the average coordinate on the specified axis of the all the provided triangles\nfunction getAverage( triangleBounds, offset, count, axis ) {\n\n\tlet avg = 0;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tavg += triangleBounds[ i * 6 + axis * 2 ];\n\n\t}\n\n\treturn avg / count;\n\n}\n\n// precomputes the bounding box for each triangle; required for quickly calculating tree splits.\n// result is an array of size tris.length * 6 where triangle i maps to a\n// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index i * 6,\n// representing the center and half-extent in each dimension of triangle i\nfunction computeTriangleBounds( geo, fullBounds ) {\n\n\tconst posAttr = geo.attributes.position;\n\tconst index = geo.index.array;\n\tconst triCount = index.length / 3;\n\tconst triangleBounds = new Float32Array( triCount * 6 );\n\tconst normalized = posAttr.normalized;\n\n\t// used for non-normalized positions\n\tconst posArr = posAttr.array;\n\n\t// support for an interleaved position buffer\n\tconst bufferOffset = posAttr.offset || 0;\n\tlet stride = 3;\n\tif ( posAttr.isInterleavedBufferAttribute ) {\n\n\t\tstride = posAttr.data.stride;\n\n\t}\n\n\t// used for normalized positions\n\tconst getters = [ 'getX', 'getY', 'getZ' ];\n\n\tfor ( let tri = 0; tri < triCount; tri ++ ) {\n\n\t\tconst tri3 = tri * 3;\n\t\tconst tri6 = tri * 6;\n\n\t\tlet ai, bi, ci;\n\n\t\tif ( normalized ) {\n\n\t\t\tai = index[ tri3 + 0 ];\n\t\t\tbi = index[ tri3 + 1 ];\n\t\t\tci = index[ tri3 + 2 ];\n\n\t\t} else {\n\n\t\t\tai = index[ tri3 + 0 ] * stride + bufferOffset;\n\t\t\tbi = index[ tri3 + 1 ] * stride + bufferOffset;\n\t\t\tci = index[ tri3 + 2 ] * stride + bufferOffset;\n\n\t\t}\n\n\t\tfor ( let el = 0; el < 3; el ++ ) {\n\n\t\t\tlet a, b, c;\n\n\t\t\tif ( normalized ) {\n\n\t\t\t\ta = posAttr[ getters[ el ] ]( ai );\n\t\t\t\tb = posAttr[ getters[ el ] ]( bi );\n\t\t\t\tc = posAttr[ getters[ el ] ]( ci );\n\n\t\t\t} else {\n\n\t\t\t\ta = posArr[ ai + el ];\n\t\t\t\tb = posArr[ bi + el ];\n\t\t\t\tc = posArr[ ci + el ];\n\n\t\t\t}\n\n\t\t\tlet min = a;\n\t\t\tif ( b < min ) min = b;\n\t\t\tif ( c < min ) min = c;\n\n\t\t\tlet max = a;\n\t\t\tif ( b > max ) max = b;\n\t\t\tif ( c > max ) max = c;\n\n\t\t\t// Increase the bounds size by float32 epsilon to avoid precision errors when\n\t\t\t// converting to 32 bit float. Scale the epsilon by the size of the numbers being\n\t\t\t// worked with.\n\t\t\tconst halfExtents = ( max - min ) / 2;\n\t\t\tconst el2 = el * 2;\n\t\t\ttriangleBounds[ tri6 + el2 + 0 ] = min + halfExtents;\n\t\t\ttriangleBounds[ tri6 + el2 + 1 ] = halfExtents + ( Math.abs( min ) + halfExtents ) * FLOAT32_EPSILON;\n\n\t\t\tif ( min < fullBounds[ el ] ) fullBounds[ el ] = min;\n\t\t\tif ( max > fullBounds[ el + 3 ] ) fullBounds[ el + 3 ] = max;\n\n\t\t}\n\n\t}\n\n\treturn triangleBounds;\n\n}\n\nexport function buildTree( geo, options ) {\n\n\tfunction triggerProgress( trianglesProcessed ) {\n\n\t\tif ( onProgress ) {\n\n\t\t\tonProgress( trianglesProcessed / totalTriangles );\n\n\t\t}\n\n\t}\n\n\t// either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\n\t// recording the offset and count of its triangles and writing them into the reordered geometry index.\n\tfunction splitNode( node, offset, count, centroidBoundingData = null, depth = 0 ) {\n\n\t\tif ( ! reachedMaxDepth && depth >= maxDepth ) {\n\n\t\t\treachedMaxDepth = true;\n\t\t\tif ( verbose ) {\n\n\t\t\t\tconsole.warn( `MeshBVH: Max depth of ${ maxDepth } reached when generating BVH. Consider increasing maxDepth.` );\n\t\t\t\tconsole.warn( geo );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// early out if we've met our capacity\n\t\tif ( count <= maxLeafTris || depth >= maxDepth ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\t\t\treturn node;\n\n\t\t}\n\n\t\t// Find where to split the volume\n\t\tconst split = getOptimalSplit( node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy );\n\t\tif ( split.axis === - 1 ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\t\t\treturn node;\n\n\t\t}\n\n\t\tconst splitOffset = partition( indexArray, triangleBounds, offset, count, split );\n\n\t\t// create the two new child nodes\n\t\tif ( splitOffset === offset || splitOffset === offset + count ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\n\t\t} else {\n\n\t\t\tnode.splitAxis = split.axis;\n\n\t\t\t// create the left child and compute its bounding box\n\t\t\tconst left = new MeshBVHNode();\n\t\t\tconst lstart = offset;\n\t\t\tconst lcount = splitOffset - offset;\n\t\t\tnode.left = left;\n\t\t\tleft.boundingData = new Float32Array( 6 );\n\n\t\t\tgetBounds( triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData );\n\t\t\tsplitNode( left, lstart, lcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t\t// repeat for right\n\t\t\tconst right = new MeshBVHNode();\n\t\t\tconst rstart = splitOffset;\n\t\t\tconst rcount = count - lcount;\n\t\t\tnode.right = right;\n\t\t\tright.boundingData = new Float32Array( 6 );\n\n\t\t\tgetBounds( triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData );\n\t\t\tsplitNode( right, rstart, rcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n\tensureIndex( geo, options );\n\n\t// Compute the full bounds of the geometry at the same time as triangle bounds because\n\t// we'll need it for the root bounds in the case with no groups and it should be fast here.\n\t// We can't use the geometrying bounding box if it's available because it may be out of date.\n\tconst fullBounds = new Float32Array( 6 );\n\tconst cacheCentroidBoundingData = new Float32Array( 6 );\n\tconst triangleBounds = computeTriangleBounds( geo, fullBounds );\n\tconst indexArray = geo.index.array;\n\tconst maxDepth = options.maxDepth;\n\tconst verbose = options.verbose;\n\tconst maxLeafTris = options.maxLeafTris;\n\tconst strategy = options.strategy;\n\tconst onProgress = options.onProgress;\n\tconst totalTriangles = geo.index.count / 3;\n\tlet reachedMaxDepth = false;\n\n\tconst roots = [];\n\tconst ranges = getRootIndexRanges( geo );\n\n\tif ( ranges.length === 1 ) {\n\n\t\tconst range = ranges[ 0 ];\n\t\tconst root = new MeshBVHNode();\n\t\troot.boundingData = fullBounds;\n\t\tgetCentroidBounds( triangleBounds, range.offset, range.count, cacheCentroidBoundingData );\n\n\t\tsplitNode( root, range.offset, range.count, cacheCentroidBoundingData );\n\t\troots.push( root );\n\n\t} else {\n\n\t\tfor ( let range of ranges ) {\n\n\t\t\tconst root = new MeshBVHNode();\n\t\t\troot.boundingData = new Float32Array( 6 );\n\t\t\tgetBounds( triangleBounds, range.offset, range.count, root.boundingData, cacheCentroidBoundingData );\n\n\t\t\tsplitNode( root, range.offset, range.count, cacheCentroidBoundingData );\n\t\t\troots.push( root );\n\n\t\t}\n\n\t}\n\n\treturn roots;\n\n}\n\nexport function buildPackedTree( geo, options ) {\n\n\t// boundingData  \t\t\t\t: 6 float32\n\t// right / offset \t\t\t\t: 1 uint32\n\t// splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\n\tconst roots = buildTree( geo, options );\n\n\tlet float32Array;\n\tlet uint32Array;\n\tlet uint16Array;\n\tconst packedRoots = [];\n\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\tfor ( let i = 0; i < roots.length; i ++ ) {\n\n\t\tconst root = roots[ i ];\n\t\tlet nodeCount = countNodes( root );\n\n\t\tconst buffer = new BufferConstructor( BYTES_PER_NODE * nodeCount );\n\t\tfloat32Array = new Float32Array( buffer );\n\t\tuint32Array = new Uint32Array( buffer );\n\t\tuint16Array = new Uint16Array( buffer );\n\t\tpopulateBuffer( 0, root );\n\t\tpackedRoots.push( buffer );\n\n\t}\n\n\treturn packedRoots;\n\n\tfunction countNodes( node ) {\n\n\t\tif ( node.count ) {\n\n\t\t\treturn 1;\n\n\t\t} else {\n\n\t\t\treturn 1 + countNodes( node.left ) + countNodes( node.right );\n\n\t\t}\n\n\t}\n\n\tfunction populateBuffer( byteOffset, node ) {\n\n\t\tconst stride4Offset = byteOffset / 4;\n\t\tconst stride2Offset = byteOffset / 2;\n\t\tconst isLeaf = ! ! node.count;\n\t\tconst boundingData = node.boundingData;\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tfloat32Array[ stride4Offset + i ] = boundingData[ i ];\n\n\t\t}\n\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = node.offset;\n\t\t\tconst count = node.count;\n\t\t\tuint32Array[ stride4Offset + 6 ] = offset;\n\t\t\tuint16Array[ stride2Offset + 14 ] = count;\n\t\t\tuint16Array[ stride2Offset + 15 ] = IS_LEAFNODE_FLAG;\n\t\t\treturn byteOffset + BYTES_PER_NODE;\n\n\t\t} else {\n\n\t\t\tconst left = node.left;\n\t\t\tconst right = node.right;\n\t\t\tconst splitAxis = node.splitAxis;\n\n\t\t\tlet nextUnusedPointer;\n\t\t\tnextUnusedPointer = populateBuffer( byteOffset + BYTES_PER_NODE, left );\n\n\t\t\tif ( ( nextUnusedPointer / 4 ) > Math.pow( 2, 32 ) ) {\n\n\t\t\t\tthrow new Error( 'MeshBVH: Cannot store child pointer greater than 32 bits.' );\n\n\t\t\t}\n\n\t\t\tuint32Array[ stride4Offset + 6 ] = nextUnusedPointer / 4;\n\t\t\tnextUnusedPointer = populateBuffer( nextUnusedPointer, right );\n\n\t\t\tuint32Array[ stride4Offset + 7 ] = splitAxis;\n\t\t\treturn nextUnusedPointer;\n\n\t\t}\n\n\t}\n\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 857, "column": 0}, "map": {"version":3,"sources":["file:///Users/danilonovais/_danilonov_portfolio/node_modules/three-mesh-bvh/src/math/SeparatingAxisBounds.js"],"sourcesContent":["import { Vector3 } from 'three';\n\nexport class SeparatingAxisBounds {\n\n\tconstructor() {\n\n\t\tthis.min = Infinity;\n\t\tthis.max = - Infinity;\n\n\t}\n\n\tsetFromPointsField( points, field ) {\n\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tconst val = p[ field ];\n\t\t\tmin = val < min ? val : min;\n\t\t\tmax = val > max ? val : max;\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tsetFromPoints( axis, points ) {\n\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tconst val = axis.dot( p );\n\t\t\tmin = val < min ? val : min;\n\t\t\tmax = val > max ? val : max;\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tisSeparated( other ) {\n\n\t\treturn this.min > other.max || other.min > this.max;\n\n\t}\n\n}\n\nSeparatingAxisBounds.prototype.setFromBox = ( function () {\n\n\tconst p = new Vector3();\n\treturn function setFromBox( axis, box ) {\n\n\t\tconst boxMin = box.min;\n\t\tconst boxMax = box.max;\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tp.x = boxMin.x * x + boxMax.x * ( 1 - x );\n\t\t\t\t\tp.y = boxMin.y * y + boxMax.y * ( 1 - y );\n\t\t\t\t\tp.z = boxMin.z * z + boxMax.z * ( 1 - z );\n\n\t\t\t\t\tconst val = axis.dot( p );\n\t\t\t\t\tmin = Math.min( val, min );\n\t\t\t\t\tmax = Math.max( val, max );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t};\n\n} )();\n\nexport const areIntersecting = ( function () {\n\n\tconst cacheSatBounds = new SeparatingAxisBounds();\n\treturn function areIntersecting( shape1, shape2 ) {\n\n\t\tconst points1 = shape1.points;\n\t\tconst satAxes1 = shape1.satAxes;\n\t\tconst satBounds1 = shape1.satBounds;\n\n\t\tconst points2 = shape2.points;\n\t\tconst satAxes2 = shape2.satAxes;\n\t\tconst satBounds2 = shape2.satBounds;\n\n\t\t// check axes of the first shape\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds1[ i ];\n\t\t\tconst sa = satAxes1[ i ];\n\t\t\tcacheSatBounds.setFromPoints( sa, points2 );\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\n\n\t\t}\n\n\t\t// check axes of the second shape\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds2[ i ];\n\t\t\tconst sa = satAxes2[ i ];\n\t\t\tcacheSatBounds.setFromPoints( sa, points1 );\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\n\n\t\t}\n\n\t};\n\n} )();\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 950, "column": 0}, "map": {"version":3,"sources":["file:///Users/danilonovais/_danilonov_portfolio/node_modules/three-mesh-bvh/src/math/MathUtilities.js"],"sourcesContent":["import { Vector3, Vector2, Plane, Line3 } from 'three';\n\nexport const closestPointLineToLine = ( function () {\n\n\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/Line.cpp#L56\n\tconst dir1 = new Vector3();\n\tconst dir2 = new Vector3();\n\tconst v02 = new Vector3();\n\treturn function closestPointLineToLine( l1, l2, result ) {\n\n\t\tconst v0 = l1.start;\n\t\tconst v10 = dir1;\n\t\tconst v2 = l2.start;\n\t\tconst v32 = dir2;\n\n\t\tv02.subVectors( v0, v2 );\n\t\tdir1.subVectors( l1.end, l1.start );\n\t\tdir2.subVectors( l2.end, l2.start );\n\n\t\t// float d0232 = v02.Dot(v32);\n\t\tconst d0232 = v02.dot( v32 );\n\n\t\t// float d3210 = v32.Dot(v10);\n\t\tconst d3210 = v32.dot( v10 );\n\n\t\t// float d3232 = v32.Dot(v32);\n\t\tconst d3232 = v32.dot( v32 );\n\n\t\t// float d0210 = v02.Dot(v10);\n\t\tconst d0210 = v02.dot( v10 );\n\n\t\t// float d1010 = v10.Dot(v10);\n\t\tconst d1010 = v10.dot( v10 );\n\n\t\t// float denom = d1010*d3232 - d3210*d3210;\n\t\tconst denom = d1010 * d3232 - d3210 * d3210;\n\n\t\tlet d, d2;\n\t\tif ( denom !== 0 ) {\n\n\t\t\td = ( d0232 * d3210 - d0210 * d3232 ) / denom;\n\n\t\t} else {\n\n\t\t\td = 0;\n\n\t\t}\n\n\t\td2 = ( d0232 + d * d3210 ) / d3232;\n\n\t\tresult.x = d;\n\t\tresult.y = d2;\n\n\t};\n\n} )();\n\nexport const closestPointsSegmentToSegment = ( function () {\n\n\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/LineSegment.cpp#L187\n\tconst paramResult = new Vector2();\n\tconst temp1 = new Vector3();\n\tconst temp2 = new Vector3();\n\treturn function closestPointsSegmentToSegment( l1, l2, target1, target2 ) {\n\n\t\tclosestPointLineToLine( l1, l2, paramResult );\n\n\t\tlet d = paramResult.x;\n\t\tlet d2 = paramResult.y;\n\t\tif ( d >= 0 && d <= 1 && d2 >= 0 && d2 <= 1 ) {\n\n\t\t\tl1.at( d, target1 );\n\t\t\tl2.at( d2, target2 );\n\n\t\t\treturn;\n\n\t\t} else if ( d >= 0 && d <= 1 ) {\n\n\t\t\t// Only d2 is out of bounds.\n\t\t\tif ( d2 < 0 ) {\n\n\t\t\t\tl2.at( 0, target2 );\n\n\t\t\t} else {\n\n\t\t\t\tl2.at( 1, target2 );\n\n\t\t\t}\n\n\t\t\tl1.closestPointToPoint( target2, true, target1 );\n\t\t\treturn;\n\n\t\t} else if ( d2 >= 0 && d2 <= 1 ) {\n\n\t\t\t// Only d is out of bounds.\n\t\t\tif ( d < 0 ) {\n\n\t\t\t\tl1.at( 0, target1 );\n\n\t\t\t} else {\n\n\t\t\t\tl1.at( 1, target1 );\n\n\t\t\t}\n\n\t\t\tl2.closestPointToPoint( target1, true, target2 );\n\t\t\treturn;\n\n\t\t} else {\n\n\t\t\t// Both u and u2 are out of bounds.\n\t\t\tlet p;\n\t\t\tif ( d < 0 ) {\n\n\t\t\t\tp = l1.start;\n\n\t\t\t} else {\n\n\t\t\t\tp = l1.end;\n\n\t\t\t}\n\n\t\t\tlet p2;\n\t\t\tif ( d2 < 0 ) {\n\n\t\t\t\tp2 = l2.start;\n\n\t\t\t} else {\n\n\t\t\t\tp2 = l2.end;\n\n\t\t\t}\n\n\t\t\tconst closestPoint = temp1;\n\t\t\tconst closestPoint2 = temp2;\n\t\t\tl1.closestPointToPoint( p2, true, temp1 );\n\t\t\tl2.closestPointToPoint( p, true, temp2 );\n\n\t\t\tif ( closestPoint.distanceToSquared( p2 ) <= closestPoint2.distanceToSquared( p ) ) {\n\n\t\t\t\ttarget1.copy( closestPoint );\n\t\t\t\ttarget2.copy( p2 );\n\t\t\t\treturn;\n\n\t\t\t} else {\n\n\t\t\t\ttarget1.copy( p );\n\t\t\t\ttarget2.copy( closestPoint2 );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n} )();\n\n\nexport const sphereIntersectTriangle = ( function () {\n\n\t// https://stackoverflow.com/questions/34043955/detect-collision-between-sphere-and-triangle-in-three-js\n\tconst closestPointTemp = new Vector3();\n\tconst projectedPointTemp = new Vector3();\n\tconst planeTemp = new Plane();\n\tconst lineTemp = new Line3();\n\treturn function sphereIntersectTriangle( sphere, triangle ) {\n\n\t\tconst { radius, center } = sphere;\n\t\tconst { a, b, c } = triangle;\n\n\t\t// phase 1\n\t\tlineTemp.start = a;\n\t\tlineTemp.end = b;\n\t\tconst closestPoint1 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint1.distanceTo( center ) <= radius ) return true;\n\n\t\tlineTemp.start = a;\n\t\tlineTemp.end = c;\n\t\tconst closestPoint2 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint2.distanceTo( center ) <= radius ) return true;\n\n\t\tlineTemp.start = b;\n\t\tlineTemp.end = c;\n\t\tconst closestPoint3 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint3.distanceTo( center ) <= radius ) return true;\n\n\t\t// phase 2\n\t\tconst plane = triangle.getPlane( planeTemp );\n\t\tconst dp = Math.abs( plane.distanceToPoint( center ) );\n\t\tif ( dp <= radius ) {\n\n\t\t\tconst pp = plane.projectPoint( center, projectedPointTemp );\n\t\t\tconst cp = triangle.containsPoint( pp );\n\t\t\tif ( cp ) return true;\n\n\t\t}\n\n\t\treturn false;\n\n\t};\n\n} )();\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1094, "column": 0}, "map": {"version":3,"sources":["file:///Users/danilonovais/_danilonov_portfolio/node_modules/three-mesh-bvh/src/math/ExtendedTriangle.js"],"sourcesContent":["import { Triangle, Vector3, Line3, Sphere, Plane } from 'three';\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\nimport { closestPointsSegmentToSegment, sphereIntersectTriangle } from './MathUtilities.js';\n\nconst DIST_EPSILON = 1e-15;\nfunction isNearZero( value ) {\n\n\treturn Math.abs( value ) < DIST_EPSILON;\n\n}\n\nexport class ExtendedTriangle extends Triangle {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tthis.isExtendedTriangle = true;\n\t\tthis.satAxes = new Array( 4 ).fill().map( () => new Vector3() );\n\t\tthis.satBounds = new Array( 4 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.points = [ this.a, this.b, this.c ];\n\t\tthis.sphere = new Sphere();\n\t\tthis.plane = new Plane();\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn sphereIntersectTriangle( sphere, this );\n\n\t}\n\n\tupdate() {\n\n\t\tconst a = this.a;\n\t\tconst b = this.b;\n\t\tconst c = this.c;\n\t\tconst points = this.points;\n\n\t\tconst satAxes = this.satAxes;\n\t\tconst satBounds = this.satBounds;\n\n\t\tconst axis0 = satAxes[ 0 ];\n\t\tconst sab0 = satBounds[ 0 ];\n\t\tthis.getNormal( axis0 );\n\t\tsab0.setFromPoints( axis0, points );\n\n\t\tconst axis1 = satAxes[ 1 ];\n\t\tconst sab1 = satBounds[ 1 ];\n\t\taxis1.subVectors( a, b );\n\t\tsab1.setFromPoints( axis1, points );\n\n\t\tconst axis2 = satAxes[ 2 ];\n\t\tconst sab2 = satBounds[ 2 ];\n\t\taxis2.subVectors( b, c );\n\t\tsab2.setFromPoints( axis2, points );\n\n\t\tconst axis3 = satAxes[ 3 ];\n\t\tconst sab3 = satBounds[ 3 ];\n\t\taxis3.subVectors( c, a );\n\t\tsab3.setFromPoints( axis3, points );\n\n\t\tthis.sphere.setFromPoints( this.points );\n\t\tthis.plane.setFromNormalAndCoplanarPoint( axis0, a );\n\t\tthis.needsUpdate = false;\n\n\t}\n\n}\n\nExtendedTriangle.prototype.closestPointToSegment = ( function () {\n\n\tconst point1 = new Vector3();\n\tconst point2 = new Vector3();\n\tconst edge = new Line3();\n\n\treturn function distanceToSegment( segment, target1 = null, target2 = null ) {\n\n\t\tconst { start, end } = segment;\n\t\tconst points = this.points;\n\t\tlet distSq;\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check the triangle edges\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst nexti = ( i + 1 ) % 3;\n\t\t\tedge.start.copy( points[ i ] );\n\t\t\tedge.end.copy( points[ nexti ] );\n\n\t\t\tclosestPointsSegmentToSegment( edge, segment, point1, point2 );\n\n\t\t\tdistSq = point1.distanceToSquared( point2 );\n\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check end points\n\t\tthis.closestPointToPoint( start, point1 );\n\t\tdistSq = start.distanceToSquared( point1 );\n\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\tclosestDistanceSq = distSq;\n\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\tif ( target2 ) target2.copy( start );\n\n\t\t}\n\n\t\tthis.closestPointToPoint( end, point1 );\n\t\tdistSq = end.distanceToSquared( point1 );\n\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\tclosestDistanceSq = distSq;\n\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\tif ( target2 ) target2.copy( end );\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n\nExtendedTriangle.prototype.intersectsTriangle = ( function () {\n\n\tconst saTri2 = new ExtendedTriangle();\n\tconst arr1 = new Array( 3 );\n\tconst arr2 = new Array( 3 );\n\tconst cachedSatBounds = new SeparatingAxisBounds();\n\tconst cachedSatBounds2 = new SeparatingAxisBounds();\n\tconst cachedAxis = new Vector3();\n\tconst dir1 = new Vector3();\n\tconst dir2 = new Vector3();\n\tconst tempDir = new Vector3();\n\tconst edge = new Line3();\n\tconst edge1 = new Line3();\n\tconst edge2 = new Line3();\n\n\t// TODO: If the triangles are coplanar and intersecting the target is nonsensical. It should at least\n\t// be a line contained by both triangles if not a different special case somehow represented in the return result.\n\treturn function intersectsTriangle( other, target = null, suppressLog = false ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( ! other.isExtendedTriangle ) {\n\n\t\t\tsaTri2.copy( other );\n\t\t\tsaTri2.update();\n\t\t\tother = saTri2;\n\n\t\t} else if ( other.needsUpdate ) {\n\n\t\t\tother.update();\n\n\t\t}\n\n\t\tconst plane1 = this.plane;\n\t\tconst plane2 = other.plane;\n\n\t\tif ( Math.abs( plane1.normal.dot( plane2.normal ) ) > 1.0 - 1e-10 ) {\n\n\t\t\t// perform separating axis intersection test only for coplanar triangles\n\t\t\tconst satBounds1 = this.satBounds;\n\t\t\tconst satAxes1 = this.satAxes;\n\t\t\tarr2[ 0 ] = other.a;\n\t\t\tarr2[ 1 ] = other.b;\n\t\t\tarr2[ 2 ] = other.c;\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\tconst sb = satBounds1[ i ];\n\t\t\t\tconst sa = satAxes1[ i ];\n\t\t\t\tcachedSatBounds.setFromPoints( sa, arr2 );\n\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\t}\n\n\t\t\tconst satBounds2 = other.satBounds;\n\t\t\tconst satAxes2 = other.satAxes;\n\t\t\tarr1[ 0 ] = this.a;\n\t\t\tarr1[ 1 ] = this.b;\n\t\t\tarr1[ 2 ] = this.c;\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\tconst sb = satBounds2[ i ];\n\t\t\t\tconst sa = satAxes2[ i ];\n\t\t\t\tcachedSatBounds.setFromPoints( sa, arr1 );\n\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\t}\n\n\t\t\t// check crossed axes\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\tconst sa1 = satAxes1[ i ];\n\t\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\n\n\t\t\t\t\tconst sa2 = satAxes2[ i2 ];\n\t\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\n\t\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, arr1 );\n\t\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, arr2 );\n\t\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( target ) {\n\n\t\t\t\t// TODO find two points that intersect on the edges and make that the result\n\t\t\t\tif ( ! suppressLog ) {\n\n\t\t\t\t\tconsole.warn( 'ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.' );\n\n\t\t\t\t}\n\n\t\t\t\ttarget.start.set( 0, 0, 0 );\n\t\t\t\ttarget.end.set( 0, 0, 0 );\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\t// find the edge that intersects the other triangle plane\n\t\t\tconst points1 = this.points;\n\t\t\tlet found1 = false;\n\t\t\tlet count1 = 0;\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst p = points1[ i ];\n\t\t\t\tconst pNext = points1[ ( i + 1 ) % 3 ];\n\n\t\t\t\tedge.start.copy( p );\n\t\t\t\tedge.end.copy( pNext );\n\t\t\t\tedge.delta( dir1 );\n\n\t\t\t\tconst targetPoint = found1 ? edge1.start : edge1.end;\n\t\t\t\tconst startIntersects = isNearZero( plane2.distanceToPoint( p ) );\n\t\t\t\tif ( isNearZero( plane2.normal.dot( dir1 ) ) && startIntersects ) {\n\n\t\t\t\t\t// if the edge lies on the plane then take the line\n\t\t\t\t\tedge1.copy( edge );\n\t\t\t\t\tcount1 = 2;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\t// check if the start point is near the plane because \"intersectLine\" is not robust to that case\n\t\t\t\tconst doesIntersect = plane2.intersectLine( edge, targetPoint ) || startIntersects;\n\t\t\t\tif ( doesIntersect && ! isNearZero( targetPoint.distanceTo( pNext ) ) ) {\n\n\t\t\t\t\tcount1 ++;\n\t\t\t\t\tif ( found1 ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfound1 = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( count1 === 1 && other.containsPoint( edge1.end ) ) {\n\n\t\t\t\tif ( target ) {\n\n\t\t\t\t\ttarget.start.copy( edge1.end );\n\t\t\t\t\ttarget.end.copy( edge1.end );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t} else if ( count1 !== 2 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// find the other triangles edge that intersects this plane\n\t\t\tconst points2 = other.points;\n\t\t\tlet found2 = false;\n\t\t\tlet count2 = 0;\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst p = points2[ i ];\n\t\t\t\tconst pNext = points2[ ( i + 1 ) % 3 ];\n\n\t\t\t\tedge.start.copy( p );\n\t\t\t\tedge.end.copy( pNext );\n\t\t\t\tedge.delta( dir2 );\n\n\t\t\t\tconst targetPoint = found2 ? edge2.start : edge2.end;\n\t\t\t\tconst startIntersects = isNearZero( plane1.distanceToPoint( p ) );\n\t\t\t\tif ( isNearZero( plane1.normal.dot( dir2 ) ) && startIntersects ) {\n\n\t\t\t\t\t// if the edge lies on the plane then take the line\n\t\t\t\t\tedge2.copy( edge );\n\t\t\t\t\tcount2 = 2;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\t// check if the start point is near the plane because \"intersectLine\" is not robust to that case\n\t\t\t\tconst doesIntersect = plane1.intersectLine( edge, targetPoint ) || startIntersects;\n\t\t\t\tif ( doesIntersect && ! isNearZero( targetPoint.distanceTo( pNext ) ) ) {\n\n\t\t\t\t\tcount2 ++;\n\t\t\t\t\tif ( found2 ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfound2 = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( count2 === 1 && this.containsPoint( edge2.end ) ) {\n\n\t\t\t\tif ( target ) {\n\n\t\t\t\t\ttarget.start.copy( edge2.end );\n\t\t\t\t\ttarget.end.copy( edge2.end );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t} else if ( count2 !== 2 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// find swap the second edge so both lines are running the same direction\n\t\t\tedge1.delta( dir1 );\n\t\t\tedge2.delta( dir2 );\n\n\t\t\tif ( dir1.dot( dir2 ) < 0 ) {\n\n\t\t\t\tlet tmp = edge2.start;\n\t\t\t\tedge2.start = edge2.end;\n\t\t\t\tedge2.end = tmp;\n\n\t\t\t}\n\n\t\t\t// check if the edges are overlapping\n\t\t\tconst s1 = edge1.start.dot( dir1 );\n\t\t\tconst e1 = edge1.end.dot( dir1 );\n\t\t\tconst s2 = edge2.start.dot( dir1 );\n\t\t\tconst e2 = edge2.end.dot( dir1 );\n\t\t\tconst separated1 = e1 < s2;\n\t\t\tconst separated2 = s1 < e2;\n\n\t\t\tif ( s1 !== e2 && s2 !== e1 && separated1 === separated2 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// assign the target output\n\t\t\tif ( target ) {\n\n\t\t\t\ttempDir.subVectors( edge1.start, edge2.start );\n\t\t\t\tif ( tempDir.dot( dir1 ) > 0 ) {\n\n\t\t\t\t\ttarget.start.copy( edge1.start );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttarget.start.copy( edge2.start );\n\n\t\t\t\t}\n\n\t\t\t\ttempDir.subVectors( edge1.end, edge2.end );\n\t\t\t\tif ( tempDir.dot( dir1 ) < 0 ) {\n\n\t\t\t\t\ttarget.end.copy( edge1.end );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttarget.end.copy( edge2.end );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t};\n\n} )();\n\n\nExtendedTriangle.prototype.distanceToPoint = ( function () {\n\n\tconst target = new Vector3();\n\treturn function distanceToPoint( point ) {\n\n\t\tthis.closestPointToPoint( point, target );\n\t\treturn point.distanceTo( target );\n\n\t};\n\n} )();\n\n\nExtendedTriangle.prototype.distanceToTriangle = ( function () {\n\n\tconst point = new Vector3();\n\tconst point2 = new Vector3();\n\tconst cornerFields = [ 'a', 'b', 'c' ];\n\tconst line1 = new Line3();\n\tconst line2 = new Line3();\n\n\treturn function distanceToTriangle( other, target1 = null, target2 = null ) {\n\n\t\tconst lineTarget = target1 || target2 ? line1 : null;\n\t\tif ( this.intersectsTriangle( other, lineTarget ) ) {\n\n\t\t\tif ( target1 || target2 ) {\n\n\t\t\t\tif ( target1 ) lineTarget.getCenter( target1 );\n\t\t\t\tif ( target2 ) lineTarget.getCenter( target2 );\n\n\t\t\t}\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check all point distances\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tlet dist;\n\t\t\tconst field = cornerFields[ i ];\n\t\t\tconst otherVec = other[ field ];\n\t\t\tthis.closestPointToPoint( otherVec, point );\n\n\t\t\tdist = otherVec.distanceToSquared( point );\n\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( point );\n\t\t\t\tif ( target2 ) target2.copy( otherVec );\n\n\t\t\t}\n\n\n\t\t\tconst thisVec = this[ field ];\n\t\t\tother.closestPointToPoint( thisVec, point );\n\n\t\t\tdist = thisVec.distanceToSquared( point );\n\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( thisVec );\n\t\t\t\tif ( target2 ) target2.copy( point );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst f11 = cornerFields[ i ];\n\t\t\tconst f12 = cornerFields[ ( i + 1 ) % 3 ];\n\t\t\tline1.set( this[ f11 ], this[ f12 ] );\n\t\t\tfor ( let i2 = 0; i2 < 3; i2 ++ ) {\n\n\t\t\t\tconst f21 = cornerFields[ i2 ];\n\t\t\t\tconst f22 = cornerFields[ ( i2 + 1 ) % 3 ];\n\t\t\t\tline2.set( other[ f21 ], other[ f22 ] );\n\n\t\t\t\tclosestPointsSegmentToSegment( line1, line2, point, point2 );\n\n\t\t\t\tconst dist = point.distanceToSquared( point2 );\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( point );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1450, "column": 0}, "map": {"version":3,"sources":["file:///Users/danilonovais/_danilonov_portfolio/node_modules/three-mesh-bvh/src/math/OrientedBox.js"],"sourcesContent":["import { Vector3, Matrix4, Line3 } from 'three';\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\nimport { ExtendedTriangle } from './ExtendedTriangle.js';\nimport { closestPointsSegmentToSegment } from './MathUtilities.js';\n\nexport class OrientedBox {\n\n\tconstructor( min, max, matrix ) {\n\n\t\tthis.isOrientedBox = true;\n\t\tthis.min = new Vector3();\n\t\tthis.max = new Vector3();\n\t\tthis.matrix = new Matrix4();\n\t\tthis.invMatrix = new Matrix4();\n\t\tthis.points = new Array( 8 ).fill().map( () => new Vector3() );\n\t\tthis.satAxes = new Array( 3 ).fill().map( () => new Vector3() );\n\t\tthis.satBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.alignedSatBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.needsUpdate = false;\n\n\t\tif ( min ) this.min.copy( min );\n\t\tif ( max ) this.max.copy( max );\n\t\tif ( matrix ) this.matrix.copy( matrix );\n\n\t}\n\n\tset( min, max, matrix ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\t\tthis.matrix.copy( matrix );\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tcopy( other ) {\n\n\t\tthis.min.copy( other.min );\n\t\tthis.max.copy( other.max );\n\t\tthis.matrix.copy( other.matrix );\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n\nOrientedBox.prototype.update = ( function () {\n\n\treturn function update() {\n\n\t\tconst matrix = this.matrix;\n\t\tconst min = this.min;\n\t\tconst max = this.max;\n\n\t\tconst points = this.points;\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tconst i = ( ( 1 << 0 ) * x ) | ( ( 1 << 1 ) * y ) | ( ( 1 << 2 ) * z );\n\t\t\t\t\tconst v = points[ i ];\n\t\t\t\t\tv.x = x ? max.x : min.x;\n\t\t\t\t\tv.y = y ? max.y : min.y;\n\t\t\t\t\tv.z = z ? max.z : min.z;\n\n\t\t\t\t\tv.applyMatrix4( matrix );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\t\tconst minVec = points[ 0 ];\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst axis = satAxes[ i ];\n\t\t\tconst sb = satBounds[ i ];\n\t\t\tconst index = 1 << i;\n\t\t\tconst pi = points[ index ];\n\n\t\t\taxis.subVectors( minVec, pi );\n\t\t\tsb.setFromPoints( axis, points );\n\n\t\t}\n\n\t\tconst alignedSatBounds = this.alignedSatBounds;\n\t\talignedSatBounds[ 0 ].setFromPointsField( points, 'x' );\n\t\talignedSatBounds[ 1 ].setFromPointsField( points, 'y' );\n\t\talignedSatBounds[ 2 ].setFromPointsField( points, 'z' );\n\n\t\tthis.invMatrix.copy( this.matrix ).invert();\n\t\tthis.needsUpdate = false;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.intersectsBox = ( function () {\n\n\tconst aabbBounds = new SeparatingAxisBounds();\n\treturn function intersectsBox( box ) {\n\n\t\t// TODO: should this be doing SAT against the AABB?\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tconst min = box.min;\n\t\tconst max = box.max;\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\t\tconst alignedSatBounds = this.alignedSatBounds;\n\n\t\taabbBounds.min = min.x;\n\t\taabbBounds.max = max.x;\n\t\tif ( alignedSatBounds[ 0 ].isSeparated( aabbBounds ) ) return false;\n\n\t\taabbBounds.min = min.y;\n\t\taabbBounds.max = max.y;\n\t\tif ( alignedSatBounds[ 1 ].isSeparated( aabbBounds ) ) return false;\n\n\t\taabbBounds.min = min.z;\n\t\taabbBounds.max = max.z;\n\t\tif ( alignedSatBounds[ 2 ].isSeparated( aabbBounds ) ) return false;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst axis = satAxes[ i ];\n\t\t\tconst sb = satBounds[ i ];\n\t\t\taabbBounds.setFromBox( axis, box );\n\t\t\tif ( sb.isSeparated( aabbBounds ) ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.intersectsTriangle = ( function () {\n\n\tconst saTri = new ExtendedTriangle();\n\tconst pointsArr = new Array( 3 );\n\tconst cachedSatBounds = new SeparatingAxisBounds();\n\tconst cachedSatBounds2 = new SeparatingAxisBounds();\n\tconst cachedAxis = new Vector3();\n\treturn function intersectsTriangle( triangle ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( ! triangle.isExtendedTriangle ) {\n\n\t\t\tsaTri.copy( triangle );\n\t\t\tsaTri.update();\n\t\t\ttriangle = saTri;\n\n\t\t} else if ( triangle.needsUpdate ) {\n\n\t\t\ttriangle.update();\n\n\t\t}\n\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\n\t\tpointsArr[ 0 ] = triangle.a;\n\t\tpointsArr[ 1 ] = triangle.b;\n\t\tpointsArr[ 2 ] = triangle.c;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds[ i ];\n\t\t\tconst sa = satAxes[ i ];\n\t\t\tcachedSatBounds.setFromPoints( sa, pointsArr );\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t}\n\n\t\tconst triSatBounds = triangle.satBounds;\n\t\tconst triSatAxes = triangle.satAxes;\n\t\tconst points = this.points;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = triSatBounds[ i ];\n\t\t\tconst sa = triSatAxes[ i ];\n\t\t\tcachedSatBounds.setFromPoints( sa, points );\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t}\n\n\t\t// check crossed axes\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sa1 = satAxes[ i ];\n\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\n\n\t\t\t\tconst sa2 = triSatAxes[ i2 ];\n\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\n\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, pointsArr );\n\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, points );\n\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.closestPointToPoint = ( function () {\n\n\treturn function closestPointToPoint( point, target1 ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\ttarget1\n\t\t\t.copy( point )\n\t\t\t.applyMatrix4( this.invMatrix )\n\t\t\t.clamp( this.min, this.max )\n\t\t\t.applyMatrix4( this.matrix );\n\n\t\treturn target1;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.distanceToPoint = ( function () {\n\n\tconst target = new Vector3();\n\treturn function distanceToPoint( point ) {\n\n\t\tthis.closestPointToPoint( point, target );\n\t\treturn point.distanceTo( target );\n\n\t};\n\n} )();\n\nOrientedBox.prototype.distanceToBox = ( function () {\n\n\tconst xyzFields = [ 'x', 'y', 'z' ];\n\tconst segments1 = new Array( 12 ).fill().map( () => new Line3() );\n\tconst segments2 = new Array( 12 ).fill().map( () => new Line3() );\n\n\tconst point1 = new Vector3();\n\tconst point2 = new Vector3();\n\n\t// early out if we find a value below threshold\n\treturn function distanceToBox( box, threshold = 0, target1 = null, target2 = null ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( this.intersectsBox( box ) ) {\n\n\t\t\tif ( target1 || target2 ) {\n\n\t\t\t\tbox.getCenter( point2 );\n\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\tbox.closestPointToPoint( point1, point2 );\n\n\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t}\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tconst threshold2 = threshold * threshold;\n\t\tconst min = box.min;\n\t\tconst max = box.max;\n\t\tconst points = this.points;\n\n\n\t\t// iterate over every edge and compare distances\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check over all these points\n\t\tfor ( let i = 0; i < 8; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tpoint2.copy( p ).clamp( min, max );\n\n\t\t\tconst dist = p.distanceToSquared( point2 );\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( p );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate and check all line segment distances\n\t\tlet count = 0;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tfor ( let i1 = 0; i1 <= 1; i1 ++ ) {\n\n\t\t\t\tfor ( let i2 = 0; i2 <= 1; i2 ++ ) {\n\n\t\t\t\t\tconst nextIndex = ( i + 1 ) % 3;\n\t\t\t\t\tconst nextIndex2 = ( i + 2 ) % 3;\n\n\t\t\t\t\t// get obb line segments\n\t\t\t\t\tconst index = i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\tconst index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\tconst p1 = points[ index ];\n\t\t\t\t\tconst p2 = points[ index2 ];\n\t\t\t\t\tconst line1 = segments1[ count ];\n\t\t\t\t\tline1.set( p1, p2 );\n\n\n\t\t\t\t\t// get aabb line segments\n\t\t\t\t\tconst f1 = xyzFields[ i ];\n\t\t\t\t\tconst f2 = xyzFields[ nextIndex ];\n\t\t\t\t\tconst f3 = xyzFields[ nextIndex2 ];\n\t\t\t\t\tconst line2 = segments2[ count ];\n\t\t\t\t\tconst start = line2.start;\n\t\t\t\t\tconst end = line2.end;\n\n\t\t\t\t\tstart[ f1 ] = min[ f1 ];\n\t\t\t\t\tstart[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\tstart[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\tend[ f1 ] = max[ f1 ];\n\t\t\t\t\tend[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\tend[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\tcount ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check all the other boxes point\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tpoint2.x = x ? max.x : min.x;\n\t\t\t\t\tpoint2.y = y ? max.y : min.y;\n\t\t\t\t\tpoint2.z = z ? max.z : min.z;\n\n\t\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\t\tconst dist = point2.distanceToSquared( point1 );\n\t\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 12; i ++ ) {\n\n\t\t\tconst l1 = segments1[ i ];\n\t\t\tfor ( let i2 = 0; i2 < 12; i2 ++ ) {\n\n\t\t\t\tconst l2 = segments2[ i2 ];\n\t\t\t\tclosestPointsSegmentToSegment( l1, l2, point1, point2 );\n\t\t\t\tconst dist = point1.distanceToSquared( point2 );\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1738, "column": 0}, "map": {"version":3,"sources":["file:///Users/danilonovais/_danilonov_portfolio/node_modules/three-mesh-bvh/src/utils/TriangleUtilities.js"],"sourcesContent":["\nimport { Vector2, Vector3, Triangle } from 'three';\n\n// sets the vertices of triangle `tri` with the 3 vertices after i\nexport function setTriangle( tri, i, index, pos ) {\n\n\tconst ta = tri.a;\n\tconst tb = tri.b;\n\tconst tc = tri.c;\n\n\tlet i0 = i;\n\tlet i1 = i + 1;\n\tlet i2 = i + 2;\n\tif ( index ) {\n\n\t\ti0 = index.getX( i );\n\t\ti1 = index.getX( i + 1 );\n\t\ti2 = index.getX( i + 2 );\n\n\t}\n\n\tta.x = pos.getX( i0 );\n\tta.y = pos.getY( i0 );\n\tta.z = pos.getZ( i0 );\n\n\ttb.x = pos.getX( i1 );\n\ttb.y = pos.getY( i1 );\n\ttb.z = pos.getZ( i1 );\n\n\ttc.x = pos.getX( i2 );\n\ttc.y = pos.getY( i2 );\n\ttc.z = pos.getZ( i2 );\n\n}\n\nexport function iterateOverTriangles(\n\toffset,\n\tcount,\n\tgeometry,\n\tintersectsTriangleFunc,\n\tcontained,\n\tdepth,\n\ttriangle\n) {\n\n\tconst index = geometry.index;\n\tconst pos = geometry.attributes.position;\n\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\tsetTriangle( triangle, i * 3, index, pos );\n\t\ttriangle.needsUpdate = true;\n\n\t\tif ( intersectsTriangleFunc( triangle, i, contained, depth ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\nconst tempV1 = /* @__PURE__ */ new Vector3();\nconst tempV2 = /* @__PURE__ */ new Vector3();\nconst tempV3 = /* @__PURE__ */ new Vector3();\nconst tempUV1 = /* @__PURE__ */ new Vector2();\nconst tempUV2 = /* @__PURE__ */ new Vector2();\nconst tempUV3 = /* @__PURE__ */ new Vector2();\n\nexport function getTriangleHitPointInfo( point, geometry, triangleIndex, target ) {\n\n\tconst indices = geometry.getIndex().array;\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst uvs = geometry.getAttribute( 'uv' );\n\n\tconst a = indices[ triangleIndex * 3 ];\n\tconst b = indices[ triangleIndex * 3 + 1 ];\n\tconst c = indices[ triangleIndex * 3 + 2 ];\n\n\ttempV1.fromBufferAttribute( positions, a );\n\ttempV2.fromBufferAttribute( positions, b );\n\ttempV3.fromBufferAttribute( positions, c );\n\n\t// find the associated material index\n\tlet materialIndex = 0;\n\tconst groups = geometry.groups;\n\tconst firstVertexIndex = triangleIndex * 3;\n\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\t\tconst { start, count } = group;\n\t\tif ( firstVertexIndex >= start && firstVertexIndex < start + count ) {\n\n\t\t\tmaterialIndex = group.materialIndex;\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\t// extract uvs\n\tlet uv = null;\n\tif ( uvs ) {\n\n\t\ttempUV1.fromBufferAttribute( uvs, a );\n\t\ttempUV2.fromBufferAttribute( uvs, b );\n\t\ttempUV3.fromBufferAttribute( uvs, c );\n\n\t\tif ( target && target.uv ) uv = target.uv;\n\t\telse uv = new Vector2();\n\n\t\tTriangle.getUV( point, tempV1, tempV2, tempV3, tempUV1, tempUV2, tempUV3, uv );\n\n\t}\n\n\t// adjust the provided target or create a new one\n\tif ( target ) {\n\n\t\tif ( ! target.face ) target.face = { };\n\t\ttarget.face.a = a;\n\t\ttarget.face.b = b;\n\t\ttarget.face.c = c;\n\t\ttarget.face.materialIndex = materialIndex;\n\t\tif ( ! target.face.normal ) target.face.normal = new Vector3();\n\t\tTriangle.getNormal( tempV1, tempV2, tempV3, target.face.normal );\n\n\t\tif ( uv ) target.uv = uv;\n\n\t\treturn target;\n\n\t} else {\n\n\t\treturn {\n\t\t\tface: {\n\t\t\t\ta: a,\n\t\t\t\tb: b,\n\t\t\t\tc: c,\n\t\t\t\tmaterialIndex: materialIndex,\n\t\t\t\tnormal: Triangle.getNormal( tempV1, tempV2, tempV3, new Vector3() )\n\t\t\t},\n\t\t\tuv: uv\n\t\t};\n\n\t}\n\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1848, "column": 0}, "map": {"version":3,"sources":["file:///Users/danilonovais/_danilonov_portfolio/node_modules/three-mesh-bvh/src/utils/PrimitivePool.js"],"sourcesContent":["export class PrimitivePool {\n\n\tconstructor( getNewPrimitive ) {\n\n\t\tthis._getNewPrimitive = getNewPrimitive;\n\t\tthis._primitives = [];\n\n\t}\n\n\tgetPrimitive() {\n\n\t\tconst primitives = this._primitives;\n\t\tif ( primitives.length === 0 ) {\n\n\t\t\treturn this._getNewPrimitive();\n\n\t\t} else {\n\n\t\t\treturn primitives.pop();\n\n\t\t}\n\n\t}\n\n\treleasePrimitive( primitive ) {\n\n\t\tthis._primitives.push( primitive );\n\n\t}\n\n}\n"],"names":[],"mappings":";;;;AAAO,MAAM;IAEZ,YAAa,eAAe,CAAG;QAE9B,IAAI,CAAC,gBAAgB,GAAG;QACxB,IAAI,CAAC,WAAW,GAAG,EAAE;IAEtB;IAEA,eAAe;QAEd,MAAM,aAAa,IAAI,CAAC,WAAW;QACnC,IAAK,WAAW,MAAM,KAAK,GAAI;YAE9B,OAAO,IAAI,CAAC,gBAAgB;QAE7B,OAAO;YAEN,OAAO,WAAW,GAAG;QAEtB;IAED;IAEA,iBAAkB,SAAS,EAAG;QAE7B,IAAI,CAAC,WAAW,CAAC,IAAI,CAAE;IAExB;AAED","ignoreList":[0]}},
    {"offset": {"line": 1873, "column": 0}, "map": {"version":3,"sources":["file:///Users/danilonovais/_danilonov_portfolio/node_modules/three-mesh-bvh/src/core/nodeBufferFunctions.js"],"sourcesContent":["export function IS_LEAF( n16, uint16Array ) {\n\n\treturn uint16Array[ n16 + 15 ] === 0xFFFF;\n\n}\n\nexport function OFFSET( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 6 ];\n\n}\n\nexport function COUNT( n16, uint16Array ) {\n\n\treturn uint16Array[ n16 + 14 ];\n\n}\n\nexport function LEFT_NODE( n32 ) {\n\n\treturn n32 + 8;\n\n}\n\nexport function RIGHT_NODE( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 6 ];\n\n}\n\nexport function SPLIT_AXIS( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 7 ];\n\n}\n\nexport function BOUNDING_DATA_INDEX( n32 ) {\n\n\treturn n32;\n\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAO,SAAS,QAAS,GAAG,EAAE,WAAW;IAExC,OAAO,WAAW,CAAE,MAAM,GAAI,KAAK;AAEpC;AAEO,SAAS,OAAQ,GAAG,EAAE,WAAW;IAEvC,OAAO,WAAW,CAAE,MAAM,EAAG;AAE9B;AAEO,SAAS,MAAO,GAAG,EAAE,WAAW;IAEtC,OAAO,WAAW,CAAE,MAAM,GAAI;AAE/B;AAEO,SAAS,UAAW,GAAG;IAE7B,OAAO,MAAM;AAEd;AAEO,SAAS,WAAY,GAAG,EAAE,WAAW;IAE3C,OAAO,WAAW,CAAE,MAAM,EAAG;AAE9B;AAEO,SAAS,WAAY,GAAG,EAAE,WAAW;IAE3C,OAAO,WAAW,CAAE,MAAM,EAAG;AAE9B;AAEO,SAAS,oBAAqB,GAAG;IAEvC,OAAO;AAER","ignoreList":[0]}},
    {"offset": {"line": 1914, "column": 0}, "map": {"version":3,"sources":["file:///Users/danilonovais/_danilonov_portfolio/node_modules/three-mesh-bvh/src/core/castFunctions.js"],"sourcesContent":["import { Box3, Vector3, Matrix4 } from 'three';\nimport { CONTAINED } from './Constants.js';\n\nimport { OrientedBox } from '../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../math/ExtendedTriangle.js';\nimport { intersectTris, intersectClosestTri } from '../utils/GeometryRayIntersectUtilities.js';\nimport { setTriangle } from '../utils/TriangleUtilities.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { PrimitivePool } from '../utils/PrimitivePool.js';\nimport { COUNT, OFFSET, LEFT_NODE, RIGHT_NODE, IS_LEAF, BOUNDING_DATA_INDEX, SPLIT_AXIS } from './nodeBufferFunctions.js';\n\nconst boundingBox = new Box3();\nconst boxIntersection = new Vector3();\nconst xyzFields = [ 'x', 'y', 'z' ];\n\nexport function raycast( nodeIndex32, geometry, side, ray, intersects ) {\n\n\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\tintersectTris( geometry, side, ray, offset, count, intersects );\n\n\t} else {\n\n\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\n\t\tif ( intersectRay( leftIndex, float32Array, ray, boxIntersection ) ) {\n\n\t\t\traycast( leftIndex, geometry, side, ray, intersects );\n\n\t\t}\n\n\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tif ( intersectRay( rightIndex, float32Array, ray, boxIntersection ) ) {\n\n\t\t\traycast( rightIndex, geometry, side, ray, intersects );\n\n\t\t}\n\n\t}\n\n}\n\nexport function raycastFirst( nodeIndex32, geometry, side, ray ) {\n\n\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\treturn intersectClosestTri( geometry, side, ray, offset, count );\n\n\t} else {\n\n\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\n\t\t// the ray is coming from, look for an intersection among that side of the tree first\n\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\t\tconst xyzAxis = xyzFields[ splitAxis ];\n\t\tconst rayDir = ray.direction[ xyzAxis ];\n\t\tconst leftToRight = rayDir >= 0;\n\n\t\t// c1 is the child to check first\n\t\tlet c1, c2;\n\t\tif ( leftToRight ) {\n\n\t\t\tc1 = LEFT_NODE( nodeIndex32 );\n\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t} else {\n\n\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tc2 = LEFT_NODE( nodeIndex32 );\n\n\t\t}\n\n\t\tconst c1Intersection = intersectRay( c1, float32Array, ray, boxIntersection );\n\t\tconst c1Result = c1Intersection ? raycastFirst( c1, geometry, side, ray ) : null;\n\n\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\n\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\n\t\tif ( c1Result ) {\n\n\t\t\t// check if the point is within the second bounds\n\t\t\t// \"point\" is in the local frame of the bvh\n\t\t\tconst point = c1Result.point[ xyzAxis ];\n\t\t\tconst isOutside = leftToRight ?\n\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\n\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\n\n\t\t\tif ( isOutside ) {\n\n\t\t\t\treturn c1Result;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// either there was no intersection in the first node, or there could still be a closer\n\t\t// intersection in the second, so check the second node and then take the better of the two\n\t\tconst c2Intersection = intersectRay( c2, float32Array, ray, boxIntersection );\n\t\tconst c2Result = c2Intersection ? raycastFirst( c2, geometry, side, ray ) : null;\n\n\t\tif ( c1Result && c2Result ) {\n\n\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n\n\t\t} else {\n\n\t\t\treturn c1Result || c2Result || null;\n\n\t\t}\n\n\t}\n\n}\n\nexport const shapecast = ( function () {\n\n\tlet _box1, _box2;\n\tconst boxStack = [];\n\tconst boxPool = new PrimitivePool( () => new Box3() );\n\n\treturn function shapecast( ...args ) {\n\n\t\t_box1 = boxPool.getPrimitive();\n\t\t_box2 = boxPool.getPrimitive();\n\t\tboxStack.push( _box1, _box2 );\n\n\t\tconst result = shapecastTraverse( ...args );\n\n\t\tboxPool.releasePrimitive( _box1 );\n\t\tboxPool.releasePrimitive( _box2 );\n\t\tboxStack.pop();\n\t\tboxStack.pop();\n\n\t\tconst length = boxStack.length;\n\t\tif ( length > 0 ) {\n\n\t\t\t_box2 = boxStack[ length - 1 ];\n\t\t\t_box1 = boxStack[ length - 2 ];\n\n\t\t}\n\n\t\treturn result;\n\n\t};\n\n\tfunction shapecastTraverse(\n\t\tnodeIndex32,\n\t\tgeometry,\n\t\tintersectsBoundsFunc,\n\t\tintersectsRangeFunc,\n\t\tnodeScoreFunc = null,\n\t\tnodeIndexByteOffset = 0, // offset for unique node identifier\n\t\tdepth = 0\n\t) {\n\n\t\t// Define these inside the function so it has access to the local variables needed\n\t\t// when converting to the buffer equivalents\n\t\tfunction getLeftOffset( nodeIndex32 ) {\n\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\t\t\t// traverse until we find a leaf\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\tnodeIndex32 = LEFT_NODE( nodeIndex32 );\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t}\n\n\t\t\treturn OFFSET( nodeIndex32, uint32Array );\n\n\t\t}\n\n\t\tfunction getRightEndOffset( nodeIndex32 ) {\n\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\t\t\t// traverse until we find a leaf\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\t// adjust offset to point to the right node\n\t\t\t\tnodeIndex32 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t}\n\n\t\t\t// return the end offset of the triangle range\n\t\t\treturn OFFSET( nodeIndex32, uint32Array ) + COUNT( nodeIndex16, uint16Array );\n\n\t\t}\n\n\t\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, _box1 );\n\t\t\treturn intersectsRangeFunc( offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box1 );\n\n\t\t} else {\n\n\t\t\tconst left = LEFT_NODE( nodeIndex32 );\n\t\t\tconst right = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tlet c1 = left;\n\t\t\tlet c2 = right;\n\n\t\t\tlet score1, score2;\n\t\t\tlet box1, box2;\n\t\t\tif ( nodeScoreFunc ) {\n\n\t\t\t\tbox1 = _box1;\n\t\t\t\tbox2 = _box2;\n\n\t\t\t\t// bounding data is not offset\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\t\t\tscore1 = nodeScoreFunc( box1 );\n\t\t\t\tscore2 = nodeScoreFunc( box2 );\n\n\t\t\t\tif ( score2 < score1 ) {\n\n\t\t\t\t\tc1 = right;\n\t\t\t\t\tc2 = left;\n\n\t\t\t\t\tconst temp = score1;\n\t\t\t\t\tscore1 = score2;\n\t\t\t\t\tscore2 = temp;\n\n\t\t\t\t\tbox1 = box2;\n\t\t\t\t\t// box2 is always set before use below\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Check box 1 intersection\n\t\t\tif ( ! box1 ) {\n\n\t\t\t\tbox1 = _box1;\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\n\t\t\t}\n\n\t\t\tconst isC1Leaf = IS_LEAF( c1 * 2, uint16Array );\n\t\t\tconst c1Intersection = intersectsBoundsFunc( box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1 );\n\n\t\t\tlet c1StopTraversal;\n\t\t\tif ( c1Intersection === CONTAINED ) {\n\n\t\t\t\tconst offset = getLeftOffset( c1 );\n\t\t\t\tconst end = getRightEndOffset( c1 );\n\t\t\t\tconst count = end - offset;\n\n\t\t\t\tc1StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c1, box1 );\n\n\t\t\t} else {\n\n\t\t\t\tc1StopTraversal =\n\t\t\t\t\tc1Intersection &&\n\t\t\t\t\tshapecastTraverse(\n\t\t\t\t\t\tc1,\n\t\t\t\t\t\tgeometry,\n\t\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\t\tnodeIndexByteOffset,\n\t\t\t\t\t\tdepth + 1\n\t\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( c1StopTraversal ) return true;\n\n\t\t\t// Check box 2 intersection\n\t\t\t// cached box2 will have been overwritten by previous traversal\n\t\t\tbox2 = _box2;\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\t\tconst isC2Leaf = IS_LEAF( c2 * 2, uint16Array );\n\t\t\tconst c2Intersection = intersectsBoundsFunc( box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2 );\n\n\t\t\tlet c2StopTraversal;\n\t\t\tif ( c2Intersection === CONTAINED ) {\n\n\t\t\t\tconst offset = getLeftOffset( c2 );\n\t\t\t\tconst end = getRightEndOffset( c2 );\n\t\t\t\tconst count = end - offset;\n\n\t\t\t\tc2StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c2, box2 );\n\n\t\t\t} else {\n\n\t\t\t\tc2StopTraversal =\n\t\t\t\t\tc2Intersection &&\n\t\t\t\t\tshapecastTraverse(\n\t\t\t\t\t\tc2,\n\t\t\t\t\t\tgeometry,\n\t\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\t\tnodeIndexByteOffset,\n\t\t\t\t\t\tdepth + 1\n\t\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( c2StopTraversal ) return true;\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n} )();\n\nexport const intersectsGeometry = ( function () {\n\n\tconst triangle = new ExtendedTriangle();\n\tconst triangle2 = new ExtendedTriangle();\n\tconst invertedMat = new Matrix4();\n\n\tconst obb = new OrientedBox();\n\tconst obb2 = new OrientedBox();\n\n\treturn function intersectsGeometry( nodeIndex32, geometry, otherGeometry, geometryToBvh, cachedObb = null ) {\n\n\t\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\t\tif ( cachedObb === null ) {\n\n\t\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\t\totherGeometry.computeBoundingBox();\n\n\t\t\t}\n\n\t\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\t\tcachedObb = obb;\n\n\t\t}\n\n\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\t\tif ( isLeaf ) {\n\n\t\t\tconst thisGeometry = geometry;\n\t\t\tconst thisIndex = thisGeometry.index;\n\t\t\tconst thisPos = thisGeometry.attributes.position;\n\n\t\t\tconst index = otherGeometry.index;\n\t\t\tconst pos = otherGeometry.attributes.position;\n\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\n\t\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\n\t\t\t// here.\n\t\t\tinvertedMat.copy( geometryToBvh ).invert();\n\n\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2 );\n\t\t\t\tobb2.matrix.copy( invertedMat );\n\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\tconst res = otherGeometry.boundsTree.shapecast( {\n\n\t\t\t\t\tintersectsBounds: box => obb2.intersectsBox( box ),\n\n\t\t\t\t\tintersectsTriangle: tri => {\n\n\t\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttri.needsUpdate = true;\n\n\t\t\t\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\t\t\tsetTriangle( triangle2, i, thisIndex, thisPos );\n\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\t\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\treturn res;\n\n\t\t\t} else {\n\n\t\t\t\tfor ( let i = offset * 3, l = ( count + offset * 3 ); i < l; i += 3 ) {\n\n\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\tsetTriangle( triangle, i, thisIndex, thisPos );\n\t\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\n\t\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\n\t\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\n\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\t\tsetTriangle( triangle2, i2, index, pos );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst left = nodeIndex32 + 8;\n\t\t\tconst right = uint32Array[ nodeIndex32 + 6 ];\n\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox );\n\t\t\tconst leftIntersection =\n\t\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t\tintersectsGeometry( left, geometry, otherGeometry, geometryToBvh, cachedObb );\n\n\t\t\tif ( leftIntersection ) return true;\n\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox );\n\t\t\tconst rightIntersection =\n\t\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t\tintersectsGeometry( right, geometry, otherGeometry, geometryToBvh, cachedObb );\n\n\t\t\tif ( rightIntersection ) return true;\n\n\t\t\treturn false;\n\n\t\t}\n\n\t};\n\n} )();\n\nfunction intersectRay( nodeIndex32, array, ray, target ) {\n\n\tarrayToBox( nodeIndex32, array, boundingBox );\n\treturn ray.intersectBox( boundingBox, target );\n\n}\n\nconst bufferStack = [];\nlet _prevBuffer;\nlet _float32Array;\nlet _uint16Array;\nlet _uint32Array;\nexport function setBuffer( buffer ) {\n\n\tif ( _prevBuffer ) {\n\n\t\tbufferStack.push( _prevBuffer );\n\n\t}\n\n\t_prevBuffer = buffer;\n\t_float32Array = new Float32Array( buffer );\n\t_uint16Array = new Uint16Array( buffer );\n\t_uint32Array = new Uint32Array( buffer );\n\n}\n\nexport function clearBuffer() {\n\n\t_prevBuffer = null;\n\t_float32Array = null;\n\t_uint16Array = null;\n\t_uint32Array = null;\n\n\tif ( bufferStack.length ) {\n\n\t\tsetBuffer( bufferStack.pop() );\n\n\t}\n\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2244, "column": 0}, "map": {"version":3,"sources":["file:///Users/danilonovais/_danilonov_portfolio/node_modules/three-mesh-bvh/src/core/MeshBVH.js"],"sourcesContent":["import { Vector3, BufferAttribute, Box3, FrontSide, Matrix4 } from 'three';\nimport { CENTER, BYTES_PER_NODE, IS_LEAFNODE_FLAG } from './Constants.js';\nimport { buildPackedTree } from './buildFunctions.js';\nimport {\n\traycast,\n\traycastFirst,\n\tshapecast,\n\tintersectsGeometry,\n\tsetBuffer,\n\tclearBuffer,\n} from './castFunctions.js';\nimport { OrientedBox } from '../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../math/ExtendedTriangle.js';\nimport { PrimitivePool } from '../utils/PrimitivePool.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { iterateOverTriangles, setTriangle } from '../utils/TriangleUtilities.js';\n\nconst SKIP_GENERATION = Symbol( 'skip tree generation' );\n\nconst aabb = /* @__PURE__ */ new Box3();\nconst aabb2 = /* @__PURE__ */ new Box3();\nconst tempMatrix = /* @__PURE__ */ new Matrix4();\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\nconst temp = /* @__PURE__ */ new Vector3();\nconst temp1 = /* @__PURE__ */ new Vector3();\nconst temp2 = /* @__PURE__ */ new Vector3();\nconst temp3 = /* @__PURE__ */ new Vector3();\nconst temp4 = /* @__PURE__ */ new Vector3();\nconst tempBox = /* @__PURE__ */ new Box3();\nconst trianglePool = /* @__PURE__ */ new PrimitivePool( () => new ExtendedTriangle() );\n\nexport class MeshBVH {\n\n\tstatic serialize( bvh, options = {} ) {\n\n\t\tif ( options.isBufferGeometry ) {\n\n\t\t\tconsole.warn( 'MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature.' );\n\n\t\t\treturn MeshBVH.serialize(\n\t\t\t\targuments[ 0 ],\n\t\t\t\t{\n\t\t\t\t\tcloneBuffers: arguments[ 2 ] === undefined ? true : arguments[ 2 ],\n\t\t\t\t}\n\t\t\t);\n\n\t\t}\n\n\t\toptions = {\n\t\t\tcloneBuffers: true,\n\t\t\t...options,\n\t\t};\n\n\t\tconst geometry = bvh.geometry;\n\t\tconst rootData = bvh._roots;\n\t\tconst indexAttribute = geometry.getIndex();\n\t\tlet result;\n\t\tif ( options.cloneBuffers ) {\n\n\t\t\tresult = {\n\t\t\t\troots: rootData.map( root => root.slice() ),\n\t\t\t\tindex: indexAttribute.array.slice(),\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tresult = {\n\t\t\t\troots: rootData,\n\t\t\t\tindex: indexAttribute.array,\n\t\t\t};\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tstatic deserialize( data, geometry, options = {} ) {\n\n\t\tif ( typeof options === 'boolean' ) {\n\n\t\t\tconsole.warn( 'MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature.' );\n\n\t\t\treturn MeshBVH.deserialize(\n\t\t\t\targuments[ 0 ],\n\t\t\t\targuments[ 1 ],\n\t\t\t\t{\n\t\t\t\t\tsetIndex: arguments[ 2 ] === undefined ? true : arguments[ 2 ],\n\t\t\t\t}\n\t\t\t);\n\n\t\t}\n\n\t\toptions = {\n\t\t\tsetIndex: true,\n\t\t\t...options,\n\t\t};\n\n\t\tconst { index, roots } = data;\n\t\tconst bvh = new MeshBVH( geometry, { ...options, [ SKIP_GENERATION ]: true } );\n\t\tbvh._roots = roots;\n\n\t\tif ( options.setIndex ) {\n\n\t\t\tconst indexAttribute = geometry.getIndex();\n\t\t\tif ( indexAttribute === null ) {\n\n\t\t\t\tconst newIndex = new BufferAttribute( data.index, 1, false );\n\t\t\t\tgeometry.setIndex( newIndex );\n\n\t\t\t} else if ( indexAttribute.array !== index ) {\n\n\t\t\t\tindexAttribute.array.set( index );\n\t\t\t\tindexAttribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bvh;\n\n\t}\n\n\tconstructor( geometry, options = {} ) {\n\n\t\tif ( ! geometry.isBufferGeometry ) {\n\n\t\t\tthrow new Error( 'MeshBVH: Only BufferGeometries are supported.' );\n\n\t\t} else if ( geometry.index && geometry.index.isInterleavedBufferAttribute ) {\n\n\t\t\tthrow new Error( 'MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.' );\n\n\t\t}\n\n\t\t// default options\n\t\toptions = Object.assign( {\n\n\t\t\tstrategy: CENTER,\n\t\t\tmaxDepth: 40,\n\t\t\tmaxLeafTris: 10,\n\t\t\tverbose: true,\n\t\t\tuseSharedArrayBuffer: false,\n\t\t\tsetBoundingBox: true,\n\t\t\tonProgress: null,\n\n\t\t\t// undocumented options\n\n\t\t\t// Whether to skip generating the tree. Used for deserialization.\n\t\t\t[ SKIP_GENERATION ]: false,\n\n\t\t}, options );\n\n\t\tif ( options.useSharedArrayBuffer && typeof SharedArrayBuffer === 'undefined' ) {\n\n\t\t\tthrow new Error( 'MeshBVH: SharedArrayBuffer is not available.' );\n\n\t\t}\n\n\t\tthis._roots = null;\n\t\tif ( ! options[ SKIP_GENERATION ] ) {\n\n\t\t\tthis._roots = buildPackedTree( geometry, options );\n\n\t\t\tif ( ! geometry.boundingBox && options.setBoundingBox ) {\n\n\t\t\t\tgeometry.boundingBox = this.getBoundingBox( new Box3() );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// retain references to the geometry so we can use them it without having to\n\t\t// take a geometry reference in every function.\n\t\tthis.geometry = geometry;\n\n\t}\n\n\trefit( nodeIndices = null ) {\n\n\t\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\n\n\t\t\tnodeIndices = new Set( nodeIndices );\n\n\t\t}\n\n\t\tconst geometry = this.geometry;\n\t\tconst indexArr = geometry.index.array;\n\t\tconst posAttr = geometry.attributes.position;\n\n\t\tlet buffer, uint32Array, uint16Array, float32Array;\n\t\tlet byteOffset = 0;\n\t\tconst roots = this._roots;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tbuffer = roots[ i ];\n\t\t\tuint32Array = new Uint32Array( buffer );\n\t\t\tuint16Array = new Uint16Array( buffer );\n\t\t\tfloat32Array = new Float32Array( buffer );\n\n\t\t\t_traverse( 0, byteOffset );\n\t\t\tbyteOffset += buffer.byteLength;\n\n\t\t}\n\n\t\tfunction _traverse( node32Index, byteOffset, force = false ) {\n\n\t\t\tconst node16Index = node32Index * 2;\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\n\t\t\t\tlet minx = Infinity;\n\t\t\t\tlet miny = Infinity;\n\t\t\t\tlet minz = Infinity;\n\t\t\t\tlet maxx = - Infinity;\n\t\t\t\tlet maxy = - Infinity;\n\t\t\t\tlet maxz = - Infinity;\n\n\t\t\t\tfor ( let i = 3 * offset, l = 3 * ( offset + count ); i < l; i ++ ) {\n\n\t\t\t\t\tconst index = indexArr[ i ];\n\t\t\t\t\tconst x = posAttr.getX( index );\n\t\t\t\t\tconst y = posAttr.getY( index );\n\t\t\t\t\tconst z = posAttr.getZ( index );\n\n\t\t\t\t\tif ( x < minx ) minx = x;\n\t\t\t\t\tif ( x > maxx ) maxx = x;\n\n\t\t\t\t\tif ( y < miny ) miny = y;\n\t\t\t\t\tif ( y > maxy ) maxy = y;\n\n\t\t\t\t\tif ( z < minz ) minz = z;\n\t\t\t\t\tif ( z > maxz ) maxz = z;\n\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\n\t\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\n\t\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\n\n\t\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\n\t\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\n\t\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\n\t\t\t\t) {\n\n\t\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\n\t\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\n\t\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\n\n\t\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\n\t\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\n\t\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst left = node32Index + 8;\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\n\t\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\n\t\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\n\t\t\t\tconst offsetLeft = left + byteOffset;\n\t\t\t\tconst offsetRight = right + byteOffset;\n\t\t\t\tlet forceChildren = force;\n\t\t\t\tlet includesLeft = false;\n\t\t\t\tlet includesRight = false;\n\n\t\t\t\tif ( nodeIndices ) {\n\n\t\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\n\t\t\t\t\t// then we assume that all children need to be updated.\n\t\t\t\t\tif ( ! forceChildren ) {\n\n\t\t\t\t\t\tincludesLeft = nodeIndices.has( offsetLeft );\n\t\t\t\t\t\tincludesRight = nodeIndices.has( offsetRight );\n\t\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tincludesLeft = true;\n\t\t\t\t\tincludesRight = true;\n\n\t\t\t\t}\n\n\t\t\t\tconst traverseLeft = forceChildren || includesLeft;\n\t\t\t\tconst traverseRight = forceChildren || includesRight;\n\n\t\t\t\tlet leftChange = false;\n\t\t\t\tif ( traverseLeft ) {\n\n\t\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\n\n\t\t\t\t}\n\n\t\t\t\tlet rightChange = false;\n\t\t\t\tif ( traverseRight ) {\n\n\t\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\n\n\t\t\t\t}\n\n\t\t\t\tconst didChange = leftChange || rightChange;\n\t\t\t\tif ( didChange ) {\n\n\t\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\tconst lefti = left + i;\n\t\t\t\t\t\tconst righti = right + i;\n\t\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\n\t\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\n\t\t\t\t\t\tconst minRightValue = float32Array[ righti ];\n\t\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\n\n\t\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n\t\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn didChange;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttraverse( callback, rootIndex = 0 ) {\n\n\t\tconst buffer = this._roots[ rootIndex ];\n\t\tconst uint32Array = new Uint32Array( buffer );\n\t\tconst uint16Array = new Uint16Array( buffer );\n\t\t_traverse( 0 );\n\n\t\tfunction _traverse( node32Index, depth = 0 ) {\n\n\t\t\tconst node16Index = node32Index * 2;\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\t\t\t\tcallback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), offset, count );\n\n\t\t\t} else {\n\n\t\t\t\t// TODO: use node functions here\n\t\t\t\tconst left = node32Index + BYTES_PER_NODE / 4;\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst splitAxis = uint32Array[ node32Index + 7 ];\n\t\t\t\tconst stopTraversal = callback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), splitAxis );\n\n\t\t\t\tif ( ! stopTraversal ) {\n\n\t\t\t\t\t_traverse( left, depth + 1 );\n\t\t\t\t\t_traverse( right, depth + 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/* Core Cast Functions */\n\traycast( ray, materialOrSide = FrontSide ) {\n\n\t\tconst roots = this._roots;\n\t\tconst geometry = this.geometry;\n\t\tconst intersects = [];\n\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\tconst groups = geometry.groups;\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\t\t\tconst startCount = intersects.length;\n\n\t\t\tsetBuffer( roots[ i ] );\n\t\t\traycast( 0, geometry, materialSide, ray, intersects );\n\t\t\tclearBuffer();\n\n\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\tconst materialIndex = groups[ i ].materialIndex;\n\t\t\t\tfor ( let j = startCount, jl = intersects.length; j < jl; j ++ ) {\n\n\t\t\t\t\tintersects[ j ].face.materialIndex = materialIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn intersects;\n\n\t}\n\n\traycastFirst( ray, materialOrSide = FrontSide ) {\n\n\t\tconst roots = this._roots;\n\t\tconst geometry = this.geometry;\n\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\tlet closestResult = null;\n\n\t\tconst groups = geometry.groups;\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\n\t\t\tsetBuffer( roots[ i ] );\n\t\t\tconst result = raycastFirst( 0, geometry, materialSide, ray );\n\t\t\tclearBuffer();\n\n\t\t\tif ( result != null && ( closestResult == null || result.distance < closestResult.distance ) ) {\n\n\t\t\t\tclosestResult = result;\n\t\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\t\tresult.face.materialIndex = groups[ i ].materialIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn closestResult;\n\n\t}\n\n\tintersectsGeometry( otherGeometry, geomToMesh ) {\n\n\t\tconst geometry = this.geometry;\n\t\tlet result = false;\n\t\tfor ( const root of this._roots ) {\n\n\t\t\tsetBuffer( root );\n\t\t\tresult = intersectsGeometry( 0, geometry, otherGeometry, geomToMesh );\n\t\t\tclearBuffer();\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tshapecast( callbacks, _intersectsTriangleFunc, _orderNodesFunc ) {\n\n\t\tconst geometry = this.geometry;\n\t\tif ( callbacks instanceof Function ) {\n\n\t\t\tif ( _intersectsTriangleFunc ) {\n\n\t\t\t\t// Support the previous function signature that provided three sequential index buffer\n\t\t\t\t// indices here.\n\t\t\t\tconst originalTriangleFunc = _intersectsTriangleFunc;\n\t\t\t\t_intersectsTriangleFunc = ( tri, index, contained, depth ) => {\n\n\t\t\t\t\tconst i3 = index * 3;\n\t\t\t\t\treturn originalTriangleFunc( tri, i3, i3 + 1, i3 + 2, contained, depth );\n\n\t\t\t\t};\n\n\n\t\t\t}\n\n\t\t\tcallbacks = {\n\n\t\t\t\tboundsTraverseOrder: _orderNodesFunc,\n\t\t\t\tintersectsBounds: callbacks,\n\t\t\t\tintersectsTriangle: _intersectsTriangleFunc,\n\t\t\t\tintersectsRange: null,\n\n\t\t\t};\n\n\t\t\tconsole.warn( 'MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.' );\n\n\t\t}\n\n\t\tconst triangle = trianglePool.getPrimitive();\n\t\tlet {\n\t\t\tboundsTraverseOrder,\n\t\t\tintersectsBounds,\n\t\t\tintersectsRange,\n\t\t\tintersectsTriangle,\n\t\t} = callbacks;\n\n\t\tif ( intersectsRange && intersectsTriangle ) {\n\n\t\t\tconst originalIntersectsRange = intersectsRange;\n\t\t\tintersectsRange = ( offset, count, contained, depth, nodeIndex ) => {\n\n\t\t\t\tif ( ! originalIntersectsRange( offset, count, contained, depth, nodeIndex ) ) {\n\n\t\t\t\t\treturn iterateOverTriangles( offset, count, geometry, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t};\n\n\t\t} else if ( ! intersectsRange ) {\n\n\t\t\tif ( intersectsTriangle ) {\n\n\t\t\t\tintersectsRange = ( offset, count, contained, depth ) => {\n\n\t\t\t\t\treturn iterateOverTriangles( offset, count, geometry, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tintersectsRange = ( offset, count, contained ) => {\n\n\t\t\t\t\treturn contained;\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet result = false;\n\t\tlet byteOffset = 0;\n\t\tfor ( const root of this._roots ) {\n\n\t\t\tsetBuffer( root );\n\t\t\tresult = shapecast( 0, geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\n\t\t\tclearBuffer();\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tbyteOffset += root.byteLength;\n\n\t\t}\n\n\t\ttrianglePool.releasePrimitive( triangle );\n\n\t\treturn result;\n\n\t}\n\n\tbvhcast( otherBvh, matrixToLocal, callbacks ) {\n\n\t\t// BVHCast function for intersecting two BVHs against each other. Ultimately just uses two recursive shapecast calls rather\n\t\t// than an approach that walks down the tree (see bvhcast.js file for more info).\n\n\t\tlet {\n\t\t\tintersectsRanges,\n\t\t\tintersectsTriangles,\n\t\t} = callbacks;\n\n\t\tconst indexAttr = this.geometry.index;\n\t\tconst positionAttr = this.geometry.attributes.position;\n\n\t\tconst otherIndexAttr = otherBvh.geometry.index;\n\t\tconst otherPositionAttr = otherBvh.geometry.attributes.position;\n\n\t\ttempMatrix.copy( matrixToLocal ).invert();\n\n\t\tconst triangle = trianglePool.getPrimitive();\n\t\tconst triangle2 = trianglePool.getPrimitive();\n\n\t\tif ( intersectsTriangles ) {\n\n\t\t\tfunction iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {\n\n\t\t\t\tfor ( let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\tsetTriangle( triangle2, i2 * 3, otherIndexAttr, otherPositionAttr );\n\t\t\t\t\ttriangle2.a.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.b.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.c.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1 ++ ) {\n\n\t\t\t\t\t\tsetTriangle( triangle, i1 * 3, indexAttr, positionAttr );\n\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\tif ( intersectsTriangles( triangle, triangle2, i1, i2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\tif ( intersectsRanges ) {\n\n\t\t\t\tconst originalIntersectsRanges = intersectsRanges;\n\t\t\t\tintersectsRanges = function ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {\n\n\t\t\t\t\tif ( ! originalIntersectsRanges( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\treturn iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tintersectsRanges = iterateOverDoubleTriangles;\n\n\t\t\t}\n\n\t\t}\n\n\t\totherBvh.getBoundingBox( aabb2 );\n\t\taabb2.applyMatrix4( matrixToLocal );\n\t\tconst result = this.shapecast( {\n\n\t\t\tintersectsBounds: box => aabb2.intersectsBox( box ),\n\n\t\t\tintersectsRange: ( offset1, count1, contained, depth1, nodeIndex1, box ) => {\n\n\t\t\t\taabb.copy( box );\n\t\t\t\taabb.applyMatrix4( tempMatrix );\n\t\t\t\treturn otherBvh.shapecast( {\n\n\t\t\t\t\tintersectsBounds: box => aabb.intersectsBox( box ),\n\n\t\t\t\t\tintersectsRange: ( offset2, count2, contained, depth2, nodeIndex2 ) => {\n\n\t\t\t\t\t\treturn intersectsRanges( offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2 );\n\n\t\t\t\t\t},\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} );\n\n\t\ttrianglePool.releasePrimitive( triangle );\n\t\ttrianglePool.releasePrimitive( triangle2 );\n\t\treturn result;\n\n\t}\n\n\t/* Derived Cast Functions */\n\tintersectsBox( box, boxToMesh ) {\n\n\t\tobb.set( box.min, box.max, boxToMesh );\n\t\tobb.needsUpdate = true;\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => obb.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => obb.intersectsTriangle( tri )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => sphere.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => tri.intersectsSphere( sphere )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tclosestPointToGeometry( otherGeometry, geometryToBvh, target1 = { }, target2 = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\totherGeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\tobb.needsUpdate = true;\n\n\t\tconst geometry = this.geometry;\n\t\tconst pos = geometry.attributes.position;\n\t\tconst index = geometry.index;\n\t\tconst otherPos = otherGeometry.attributes.position;\n\t\tconst otherIndex = otherGeometry.index;\n\t\tconst triangle = trianglePool.getPrimitive();\n\t\tconst triangle2 = trianglePool.getPrimitive();\n\n\t\tlet tempTarget1 = temp1;\n\t\tlet tempTargetDest1 = temp2;\n\t\tlet tempTarget2 = null;\n\t\tlet tempTargetDest2 = null;\n\n\t\tif ( target2 ) {\n\n\t\t\ttempTarget2 = temp3;\n\t\t\ttempTargetDest2 = temp4;\n\n\t\t}\n\n\t\tlet closestDistance = Infinity;\n\t\tlet closestDistanceTriIndex = null;\n\t\tlet closestDistanceOtherTriIndex = null;\n\t\ttempMatrix.copy( geometryToBvh ).invert();\n\t\tobb2.matrix.copy( tempMatrix );\n\t\tthis.shapecast(\n\t\t\t{\n\n\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\treturn obb.distanceToBox( box );\n\n\t\t\t\t},\n\n\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\n\n\t\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\n\t\t\t\t\t\t// save the bounds to use during triangle checks.\n\t\t\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t\t\tobb2.min.copy( box.min );\n\t\t\t\t\t\t\tobb2.max.copy( box.max );\n\t\t\t\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t},\n\n\t\t\t\tintersectsRange: ( offset, count ) => {\n\n\t\t\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n\t\t\t\t\t\t// the closest bounds in the other geometry to check.\n\t\t\t\t\t\treturn otherGeometry.boundsTree.shapecast( {\n\t\t\t\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\n\n\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\n\n\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\n\n\t\t\t\t\t\t\t\tfor ( let i2 = otherOffset * 3, l2 = ( otherOffset + otherCount ) * 3; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle2, i2, otherIndex, otherPos );\n\t\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\tfor ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t\t\t\tsetTriangle( triangle, i, index, pos );\n\t\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i / 3;\n\t\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2 / 3;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\n\t\t\t\t\t\tconst triCount = otherIndex ? otherIndex.count : otherPos.count;\n\t\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\t\t\tsetTriangle( triangle2, i2, otherIndex, otherPos );\n\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\tfor ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t\tsetTriangle( triangle, i, index, pos );\n\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i / 3;\n\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2 / 3;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t}\n\n\t\t);\n\n\t\ttrianglePool.releasePrimitive( triangle );\n\t\ttrianglePool.releasePrimitive( triangle2 );\n\n\t\tif ( closestDistance === Infinity ) return null;\n\n\t\tif ( ! target1.point ) target1.point = tempTargetDest1.clone();\n\t\telse target1.point.copy( tempTargetDest1 );\n\t\ttarget1.distance = closestDistance,\n\t\ttarget1.faceIndex = closestDistanceTriIndex;\n\n\t\tif ( target2 ) {\n\n\t\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\n\t\t\telse target2.point.copy( tempTargetDest2 );\n\t\t\ttarget2.point.applyMatrix4( tempMatrix );\n\t\t\ttempTargetDest1.applyMatrix4( tempMatrix );\n\t\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\n\t\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\n\n\t\t}\n\n\t\treturn target1;\n\n\t}\n\n\tclosestPointToPoint( point, target = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\t// early out if under minThreshold\n\t\t// skip checking if over maxThreshold\n\t\t// set minThreshold = maxThreshold to quickly check if a point is within a threshold\n\t\t// returns Infinity if no value found\n\t\tconst minThresholdSq = minThreshold * minThreshold;\n\t\tconst maxThresholdSq = maxThreshold * maxThreshold;\n\t\tlet closestDistanceSq = Infinity;\n\t\tlet closestDistanceTriIndex = null;\n\t\tthis.shapecast(\n\n\t\t\t{\n\n\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\ttemp.copy( point ).clamp( box.min, box.max );\n\t\t\t\t\treturn temp.distanceToSquared( point );\n\n\t\t\t\t},\n\n\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\treturn score < closestDistanceSq && score < maxThresholdSq;\n\n\t\t\t\t},\n\n\t\t\t\tintersectsTriangle: ( tri, triIndex ) => {\n\n\t\t\t\t\ttri.closestPointToPoint( point, temp );\n\t\t\t\t\tconst distSq = point.distanceToSquared( temp );\n\t\t\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\t\t\ttemp1.copy( temp );\n\t\t\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\t\t\tclosestDistanceTriIndex = triIndex;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( distSq < minThresholdSq ) {\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t}\n\n\t\t);\n\n\t\tif ( closestDistanceSq === Infinity ) return null;\n\n\t\tconst closestDistance = Math.sqrt( closestDistanceSq );\n\n\t\tif ( ! target.point ) target.point = temp1.clone();\n\t\telse target.point.copy( temp1 );\n\t\ttarget.distance = closestDistance,\n\t\ttarget.faceIndex = closestDistanceTriIndex;\n\n\t\treturn target;\n\n\t}\n\n\tgetBoundingBox( target ) {\n\n\t\ttarget.makeEmpty();\n\n\t\tconst roots = this._roots;\n\t\troots.forEach( buffer => {\n\n\t\t\tarrayToBox( 0, new Float32Array( buffer ), tempBox );\n\t\t\ttarget.union( tempBox );\n\n\t\t} );\n\n\t\treturn target;\n\n\t}\n\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2866, "column": 0}, "map": {"version":3,"sources":["file:///Users/danilonovais/_danilonov_portfolio/node_modules/three-mesh-bvh/src/utils/ExtensionUtilities.js"],"sourcesContent":["import { Ray, Matrix4, Mesh } from 'three';\nimport { convertRaycastIntersect } from './GeometryRayIntersectUtilities.js';\nimport { MeshBVH } from '../core/MeshBVH.js';\n\nconst ray = /* @__PURE__ */ new Ray();\nconst tmpInverseMatrix = /* @__PURE__ */ new Matrix4();\nconst origMeshRaycastFunc = Mesh.prototype.raycast;\n\nexport function acceleratedRaycast( raycaster, intersects ) {\n\n\tif ( this.geometry.boundsTree ) {\n\n\t\tif ( this.material === undefined ) return;\n\n\t\ttmpInverseMatrix.copy( this.matrixWorld ).invert();\n\t\tray.copy( raycaster.ray ).applyMatrix4( tmpInverseMatrix );\n\n\t\tconst bvh = this.geometry.boundsTree;\n\t\tif ( raycaster.firstHitOnly === true ) {\n\n\t\t\tconst hit = convertRaycastIntersect( bvh.raycastFirst( ray, this.material ), this, raycaster );\n\t\t\tif ( hit ) {\n\n\t\t\t\tintersects.push( hit );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst hits = bvh.raycast( ray, this.material );\n\t\t\tfor ( let i = 0, l = hits.length; i < l; i ++ ) {\n\n\t\t\t\tconst hit = convertRaycastIntersect( hits[ i ], this, raycaster );\n\t\t\t\tif ( hit ) {\n\n\t\t\t\t\tintersects.push( hit );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\torigMeshRaycastFunc.call( this, raycaster, intersects );\n\n\t}\n\n}\n\nexport function computeBoundsTree( options ) {\n\n\tthis.boundsTree = new MeshBVH( this, options );\n\treturn this.boundsTree;\n\n}\n\nexport function disposeBoundsTree() {\n\n\tthis.boundsTree = null;\n\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AACA;;;;AAEA,MAAM,MAAM,aAAa,GAAG,IAAI,2JAAG;AACnC,MAAM,mBAAmB,aAAa,GAAG,IAAI,+JAAO;AACpD,MAAM,sBAAsB,4JAAI,CAAC,SAAS,CAAC,OAAO;AAE3C,SAAS,mBAAoB,SAAS,EAAE,UAAU;IAExD,IAAK,IAAI,CAAC,QAAQ,CAAC,UAAU,EAAG;QAE/B,IAAK,IAAI,CAAC,QAAQ,KAAK,WAAY;QAEnC,iBAAiB,IAAI,CAAE,IAAI,CAAC,WAAW,EAAG,MAAM;QAChD,IAAI,IAAI,CAAE,UAAU,GAAG,EAAG,YAAY,CAAE;QAExC,MAAM,MAAM,IAAI,CAAC,QAAQ,CAAC,UAAU;QACpC,IAAK,UAAU,YAAY,KAAK,MAAO;YAEtC,MAAM,MAAM,IAAA,mNAAuB,EAAE,IAAI,YAAY,CAAE,KAAK,IAAI,CAAC,QAAQ,GAAI,IAAI,EAAE;YACnF,IAAK,KAAM;gBAEV,WAAW,IAAI,CAAE;YAElB;QAED,OAAO;YAEN,MAAM,OAAO,IAAI,OAAO,CAAE,KAAK,IAAI,CAAC,QAAQ;YAC5C,IAAM,IAAI,IAAI,GAAG,IAAI,KAAK,MAAM,EAAE,IAAI,GAAG,IAAO;gBAE/C,MAAM,MAAM,IAAA,mNAAuB,EAAE,IAAI,CAAE,EAAG,EAAE,IAAI,EAAE;gBACtD,IAAK,KAAM;oBAEV,WAAW,IAAI,CAAE;gBAElB;YAED;QAED;IAED,OAAO;QAEN,oBAAoB,IAAI,CAAE,IAAI,EAAE,WAAW;IAE5C;AAED;AAEO,SAAS,kBAAmB,OAAO;IAEzC,IAAI,CAAC,UAAU,GAAG,IAAI,4KAAO,CAAE,IAAI,EAAE;IACrC,OAAO,IAAI,CAAC,UAAU;AAEvB;AAEO,SAAS;IAEf,IAAI,CAAC,UAAU,GAAG;AAEnB","ignoreList":[0]}}]
}