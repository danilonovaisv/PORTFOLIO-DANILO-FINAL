{"version":3,"sources":["../../../../components/three/TorusDan.tsx","../../../../node_modules/%40react-three/drei/core/MeshTransmissionMaterial.js","../../../../node_modules/src/libs/MeshoptDecoder.ts","../../../../node_modules/src/types/helpers.ts","../../../../node_modules/src/_polyfill/LoaderUtils.js","../../../../node_modules/%40react-three/drei/core/Float.js","../../../../node_modules/src/utils/SkeletonUtils.js","../../../../node_modules/src/loaders/DRACOLoader.js","../../../../node_modules/%40react-three/drei/materials/DiscardMaterial.js","../../../../node_modules/%40react-three/drei/core/shaderMaterial.js","../../../../node_modules/src/utils/BufferGeometryUtils.ts","../../../../node_modules/%40react-three/drei/core/Gltf.js","../../../../node_modules/src/loaders/GLTFLoader.js","../../../../node_modules/%40react-three/drei/core/Clone.js"],"sourcesContent":["'use client';\n\nimport React, { useMemo, useRef } from 'react';\nimport { Float, MeshTransmissionMaterial, useGLTF } from '@react-three/drei';\nimport { useFrame } from '@react-three/fiber';\nimport * as THREE from 'three';\n\ntype TorusDanProps = {\n  reduceMotion?: boolean;\n  isMobile?: boolean;\n};\n\nconst TorusDan = ({\n  reduceMotion = false,\n  isMobile = false,\n}: TorusDanProps) => {\n  const groupRef = useRef<THREE.Group>(null);\n  const { nodes } = useGLTF('/media/torus_dan.glb');\n  const geometry =\n    (nodes as any).Torus?.geometry ||\n    (nodes as any).Torus002?.geometry ||\n    (nodes as any).Mesh?.geometry;\n\n  if (!geometry) {\n    return null;\n  }\n\n  const materialConfig = useMemo(() => {\n    const common = {\n      ior: 1.25,\n      chromaticAberration: 0.06,\n      backside: true,\n    };\n\n    if (reduceMotion) {\n      return {\n        ...common,\n        transmission: 0.9,\n        roughness: 0.15,\n        thickness: 0.35,\n        samples: 2,\n        resolution: 256,\n      };\n    }\n\n    if (isMobile) {\n      return {\n        ...common,\n        transmission: 1,\n        roughness: 0.08,\n        thickness: 0.45,\n        samples: 4,\n        resolution: 512,\n      };\n    }\n\n    return {\n      ...common,\n      transmission: 1,\n      roughness: 0.05,\n      thickness: 0.55,\n      samples: 12,\n      resolution: 1024,\n    };\n  }, [isMobile, reduceMotion]);\n\n  useFrame((_, delta) => {\n    if (reduceMotion || !groupRef.current) return;\n    groupRef.current.rotation.y += delta * 0.35;\n    groupRef.current.rotation.x = THREE.MathUtils.lerp(\n      groupRef.current.rotation.x,\n      0.15,\n      0.05\n    );\n  });\n\n  const mesh = (\n    // @ts-ignore\n    <mesh geometry={geometry}>\n      {/* Ajuste de material para vidro com tier mobile */}\n      <MeshTransmissionMaterial {...materialConfig} />\n    </mesh>\n  );\n\n  if (reduceMotion) {\n    return (\n      // @ts-ignore\n      <group ref={groupRef} dispose={null} scale={2.8}>\n        {mesh}\n      </group>\n    );\n  }\n\n  return (\n    // @ts-ignore\n    <group ref={groupRef} dispose={null} scale={2.8}>\n      <Float\n        speed={1.4}\n        rotationIntensity={0.2}\n        floatIntensity={0.35}\n        floatingRange={[-0.1, 0.2]}\n      >\n        {mesh}\n      </Float>\n    </group>\n  );\n};\n\nuseGLTF.preload('/media/torus_dan.glb');\n\nexport default TorusDan;\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { extend, useFrame } from '@react-three/fiber';\nimport { useFBO } from './Fbo.js';\nimport { DiscardMaterial } from '../materials/DiscardMaterial.js';\n\nclass MeshTransmissionMaterialImpl extends THREE.MeshPhysicalMaterial {\n  constructor(samples = 6, transmissionSampler = false) {\n    super();\n    this.uniforms = {\n      chromaticAberration: {\n        value: 0.05\n      },\n      // Transmission must always be 0, unless transmissionSampler is being used\n      transmission: {\n        value: 0\n      },\n      // Instead a workaround is used, see below for reasons why\n      _transmission: {\n        value: 1\n      },\n      transmissionMap: {\n        value: null\n      },\n      // Roughness is 1 in THREE.MeshPhysicalMaterial but it makes little sense in a transmission material\n      roughness: {\n        value: 0\n      },\n      thickness: {\n        value: 0\n      },\n      thicknessMap: {\n        value: null\n      },\n      attenuationDistance: {\n        value: Infinity\n      },\n      attenuationColor: {\n        value: new THREE.Color('white')\n      },\n      anisotropicBlur: {\n        value: 0.1\n      },\n      time: {\n        value: 0\n      },\n      distortion: {\n        value: 0.0\n      },\n      distortionScale: {\n        value: 0.5\n      },\n      temporalDistortion: {\n        value: 0.0\n      },\n      buffer: {\n        value: null\n      }\n    };\n    this.onBeforeCompile = shader => {\n      shader.uniforms = {\n        ...shader.uniforms,\n        ...this.uniforms\n      };\n\n      // Fix for r153-r156 anisotropy chunks\n      // https://github.com/mrdoob/three.js/pull/26716\n      if (this.anisotropy > 0) shader.defines.USE_ANISOTROPY = '';\n\n      // If the transmission sampler is active inject a flag\n      if (transmissionSampler) shader.defines.USE_SAMPLER = '';\n      // Otherwise we do use use .transmission and must therefore force USE_TRANSMISSION\n      // because threejs won't inject it for us\n      else shader.defines.USE_TRANSMISSION = '';\n\n      // Head\n      shader.fragmentShader = /*glsl*/`\n      uniform float chromaticAberration;         \n      uniform float anisotropicBlur;      \n      uniform float time;\n      uniform float distortion;\n      uniform float distortionScale;\n      uniform float temporalDistortion;\n      uniform sampler2D buffer;\n\n      vec3 random3(vec3 c) {\n        float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n        vec3 r;\n        r.z = fract(512.0*j);\n        j *= .125;\n        r.x = fract(512.0*j);\n        j *= .125;\n        r.y = fract(512.0*j);\n        return r-0.5;\n      }\n\n      uint hash( uint x ) {\n        x += ( x << 10u );\n        x ^= ( x >>  6u );\n        x += ( x <<  3u );\n        x ^= ( x >> 11u );\n        x += ( x << 15u );\n        return x;\n      }\n\n      // Compound versions of the hashing algorithm I whipped together.\n      uint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\n      uint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\n      uint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\n      // Construct a float with half-open range [0:1] using low 23 bits.\n      // All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\n      float floatConstruct( uint m ) {\n        const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n        const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n        m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n        m |= ieeeOne;                          // Add fractional part to 1.0\n        float  f = uintBitsToFloat( m );       // Range [1:2]\n        return f - 1.0;                        // Range [0:1]\n      }\n\n      // Pseudo-random value in half-open range [0:1].\n      float randomBase( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\n      float randomBase( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n      float randomBase( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n      float randomBase( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n      float rand(float seed) {\n        float result = randomBase(vec3(gl_FragCoord.xy, seed));\n        return result;\n      }\n\n      const float F3 =  0.3333333;\n      const float G3 =  0.1666667;\n\n      float snoise(vec3 p) {\n        vec3 s = floor(p + dot(p, vec3(F3)));\n        vec3 x = p - s + dot(s, vec3(G3));\n        vec3 e = step(vec3(0.0), x - x.yzx);\n        vec3 i1 = e*(1.0 - e.zxy);\n        vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n        vec3 x1 = x - i1 + G3;\n        vec3 x2 = x - i2 + 2.0*G3;\n        vec3 x3 = x - 1.0 + 3.0*G3;\n        vec4 w, d;\n        w.x = dot(x, x);\n        w.y = dot(x1, x1);\n        w.z = dot(x2, x2);\n        w.w = dot(x3, x3);\n        w = max(0.6 - w, 0.0);\n        d.x = dot(random3(s), x);\n        d.y = dot(random3(s + i1), x1);\n        d.z = dot(random3(s + i2), x2);\n        d.w = dot(random3(s + 1.0), x3);\n        w *= w;\n        w *= w;\n        d *= w;\n        return dot(d, vec4(52.0));\n      }\n\n      float snoiseFractal(vec3 m) {\n        return 0.5333333* snoise(m)\n              +0.2666667* snoise(2.0*m)\n              +0.1333333* snoise(4.0*m)\n              +0.0666667* snoise(8.0*m);\n      }\\n` + shader.fragmentShader;\n\n      // Remove transmission\n      shader.fragmentShader = shader.fragmentShader.replace('#include <transmission_pars_fragment>', /*glsl*/`\n        #ifdef USE_TRANSMISSION\n          // Transmission code is based on glTF-Sampler-Viewer\n          // https://github.com/KhronosGroup/glTF-Sample-Viewer\n          uniform float _transmission;\n          uniform float thickness;\n          uniform float attenuationDistance;\n          uniform vec3 attenuationColor;\n          #ifdef USE_TRANSMISSIONMAP\n            uniform sampler2D transmissionMap;\n          #endif\n          #ifdef USE_THICKNESSMAP\n            uniform sampler2D thicknessMap;\n          #endif\n          uniform vec2 transmissionSamplerSize;\n          uniform sampler2D transmissionSamplerMap;\n          uniform mat4 modelMatrix;\n          uniform mat4 projectionMatrix;\n          varying vec3 vWorldPosition;\n          vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n            // Direction of refracted light.\n            vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n            // Compute rotation-independant scaling of the model matrix.\n            vec3 modelScale;\n            modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n            modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n            modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n            // The thickness is specified in local space.\n            return normalize( refractionVector ) * thickness * modelScale;\n          }\n          float applyIorToRoughness( const in float roughness, const in float ior ) {\n            // Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and\n            // an IOR of 1.5 results in the default amount of microfacet refraction.\n            return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n          }\n          vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n            float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );            \n            #ifdef USE_SAMPLER\n              #ifdef texture2DLodEXT\n                return texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod);\n              #else\n                return texture2D(transmissionSamplerMap, fragCoord.xy, framebufferLod);\n              #endif\n            #else\n              return texture2D(buffer, fragCoord.xy);\n            #endif\n          }\n          vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n            if ( isinf( attenuationDistance ) ) {\n              // Attenuation distance is +âˆž, i.e. the transmitted color is not attenuated at all.\n              return radiance;\n            } else {\n              // Compute light attenuation using Beer's law.\n              vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n              vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance ); // Beer's law\n              return transmittance * radiance;\n            }\n          }\n          vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n            const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n            const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n            const in vec3 attenuationColor, const in float attenuationDistance ) {\n            vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n            vec3 refractedRayExit = position + transmissionRay;\n            // Project refracted vector on the framebuffer, while mapping to normalized device coordinates.\n            vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n            vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n            refractionCoords += 1.0;\n            refractionCoords /= 2.0;\n            // Sample framebuffer to get pixel the refracted ray hits.\n            vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n            vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n            // Get the specular component.\n            vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n            return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n          }\n        #endif\\n`);\n\n      // Add refraction\n      shader.fragmentShader = shader.fragmentShader.replace('#include <transmission_fragment>', /*glsl*/`  \n        // Improve the refraction to use the world pos\n        material.transmission = _transmission;\n        material.transmissionAlpha = 1.0;\n        material.thickness = thickness;\n        material.attenuationDistance = attenuationDistance;\n        material.attenuationColor = attenuationColor;\n        #ifdef USE_TRANSMISSIONMAP\n          material.transmission *= texture2D( transmissionMap, vUv ).r;\n        #endif\n        #ifdef USE_THICKNESSMAP\n          material.thickness *= texture2D( thicknessMap, vUv ).g;\n        #endif\n        \n        vec3 pos = vWorldPosition;\n        float runningSeed = 0.0;\n        vec3 v = normalize( cameraPosition - pos );\n        vec3 n = inverseTransformDirection( normal, viewMatrix );\n        vec3 transmission = vec3(0.0);\n        float transmissionR, transmissionB, transmissionG;\n        float randomCoords = rand(runningSeed++);\n        float thickness_smear = thickness * max(pow(roughnessFactor, 0.33), anisotropicBlur);\n        vec3 distortionNormal = vec3(0.0);\n        vec3 temporalOffset = vec3(time, -time, -time) * temporalDistortion;\n        if (distortion > 0.0) {\n          distortionNormal = distortion * vec3(snoiseFractal(vec3((pos * distortionScale + temporalOffset))), snoiseFractal(vec3(pos.zxy * distortionScale - temporalOffset)), snoiseFractal(vec3(pos.yxz * distortionScale + temporalOffset)));\n        }\n        for (float i = 0.0; i < ${samples}.0; i ++) {\n          vec3 sampleNorm = normalize(n + roughnessFactor * roughnessFactor * 2.0 * normalize(vec3(rand(runningSeed++) - 0.5, rand(runningSeed++) - 0.5, rand(runningSeed++) - 0.5)) * pow(rand(runningSeed++), 0.33) + distortionNormal);\n          transmissionR = getIBLVolumeRefraction(\n            sampleNorm, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n            pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness  + thickness_smear * (i + randomCoords) / float(${samples}),\n            material.attenuationColor, material.attenuationDistance\n          ).r;\n          transmissionG = getIBLVolumeRefraction(\n            sampleNorm, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n            pos, modelMatrix, viewMatrix, projectionMatrix, material.ior  * (1.0 + chromaticAberration * (i + randomCoords) / float(${samples})) , material.thickness + thickness_smear * (i + randomCoords) / float(${samples}),\n            material.attenuationColor, material.attenuationDistance\n          ).g;\n          transmissionB = getIBLVolumeRefraction(\n            sampleNorm, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n            pos, modelMatrix, viewMatrix, projectionMatrix, material.ior * (1.0 + 2.0 * chromaticAberration * (i + randomCoords) / float(${samples})), material.thickness + thickness_smear * (i + randomCoords) / float(${samples}),\n            material.attenuationColor, material.attenuationDistance\n          ).b;\n          transmission.r += transmissionR;\n          transmission.g += transmissionG;\n          transmission.b += transmissionB;\n        }\n        transmission /= ${samples}.0;\n        totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );\\n`);\n    };\n    Object.keys(this.uniforms).forEach(name => Object.defineProperty(this, name, {\n      get: () => this.uniforms[name].value,\n      set: v => this.uniforms[name].value = v\n    }));\n  }\n}\nconst MeshTransmissionMaterial = /* @__PURE__ */React.forwardRef(({\n  buffer,\n  transmissionSampler = false,\n  backside = false,\n  side = THREE.FrontSide,\n  transmission = 1,\n  thickness = 0,\n  backsideThickness = 0,\n  backsideEnvMapIntensity = 1,\n  samples = 10,\n  resolution,\n  backsideResolution,\n  background,\n  anisotropy,\n  anisotropicBlur,\n  ...props\n}, fref) => {\n  extend({\n    MeshTransmissionMaterial: MeshTransmissionMaterialImpl\n  });\n  const ref = React.useRef(null);\n  const [discardMaterial] = React.useState(() => new DiscardMaterial());\n  const fboBack = useFBO(backsideResolution || resolution);\n  const fboMain = useFBO(resolution);\n  let oldBg;\n  let oldEnvMapIntensity;\n  let oldTone;\n  let parent;\n  useFrame(state => {\n    ref.current.time = state.clock.elapsedTime;\n    // Render only if the buffer matches the built-in and no transmission sampler is set\n    if (ref.current.buffer === fboMain.texture && !transmissionSampler) {\n      var _r3f$parent;\n      parent = (_r3f$parent = ref.current.__r3f.parent) == null ? void 0 : _r3f$parent.object;\n      if (parent) {\n        // Save defaults\n        oldTone = state.gl.toneMapping;\n        oldBg = state.scene.background;\n        oldEnvMapIntensity = ref.current.envMapIntensity;\n\n        // Switch off tonemapping lest it double tone maps\n        // Save the current background and set the HDR as the new BG\n        // Use discardmaterial, the parent will be invisible, but it's shadows will still be cast\n        state.gl.toneMapping = THREE.NoToneMapping;\n        if (background) state.scene.background = background;\n        parent.material = discardMaterial;\n        if (backside) {\n          // Render into the backside buffer\n          state.gl.setRenderTarget(fboBack);\n          state.gl.render(state.scene, state.camera);\n          // And now prepare the material for the main render using the backside buffer\n          parent.material = ref.current;\n          parent.material.buffer = fboBack.texture;\n          parent.material.thickness = backsideThickness;\n          parent.material.side = THREE.BackSide;\n          parent.material.envMapIntensity = backsideEnvMapIntensity;\n        }\n\n        // Render into the main buffer\n        state.gl.setRenderTarget(fboMain);\n        state.gl.render(state.scene, state.camera);\n        parent.material = ref.current;\n        parent.material.thickness = thickness;\n        parent.material.side = side;\n        parent.material.buffer = fboMain.texture;\n        parent.material.envMapIntensity = oldEnvMapIntensity;\n\n        // Set old state back\n        state.scene.background = oldBg;\n        state.gl.setRenderTarget(null);\n        state.gl.toneMapping = oldTone;\n      }\n    }\n  });\n\n  // Forward ref\n  React.useImperativeHandle(fref, () => ref.current, []);\n  return /*#__PURE__*/React.createElement(\"meshTransmissionMaterial\", _extends({\n    // Samples must re-compile the shader so we memoize it\n    args: [samples, transmissionSampler],\n    ref: ref\n  }, props, {\n    buffer: buffer || fboMain.texture\n    // @ts-ignore\n    ,\n    _transmission: transmission\n    // In order for this to not incur extra cost \"transmission\" must be set to 0 and treated as a reserved prop.\n    // This is because THREE.WebGLRenderer will check for transmission > 0 and execute extra renders.\n    // The exception is when transmissionSampler is set, in which case we are using three's built in sampler.\n    ,\n    anisotropicBlur: anisotropicBlur !== null && anisotropicBlur !== void 0 ? anisotropicBlur : anisotropy,\n    transmission: transmissionSampler ? transmission : 0,\n    thickness: thickness,\n    side: side\n  }));\n});\n\nexport { MeshTransmissionMaterial };\n","// This file is part of meshoptimizer library and is distributed under the terms of MIT License.\n// Copyright (C) 2016-2020, by Arseny Kapoulkine (arseny.kapoulkine@gmail.com)\n\ntype API = {\n  ready: Promise<void>\n  supported: boolean\n  decodeVertexBuffer: (target: Uint8Array, count: number, size: number, source: Uint8Array, filter?: string) => void\n  decodeIndexBuffer: (target: Uint8Array, count: number, size: number, source: Uint8Array) => void\n  decodeIndexSequence: (target: Uint8Array, count: number, size: number, source: Uint8Array) => void\n  decodeGltfBuffer: (\n    target: Uint8Array,\n    count: number,\n    size: number,\n    source: Uint8Array,\n    mode: string,\n    filter?: string,\n  ) => void\n}\n\nlet generated: API\n\nconst MeshoptDecoder = () => {\n  if (generated) return generated\n\n  // Built with clang version 11.0.0 (https://github.com/llvm/llvm-project.git 0160ad802e899c2922bc9b29564080c22eb0908c)\n  // Built from meshoptimizer 0.14\n  const wasm_base =\n    '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'\n  const wasm_simd =\n    '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'\n\n  // Uses bulk-memory and simd extensions\n  const detector = new Uint8Array([\n    0,\n    97,\n    115,\n    109,\n    1,\n    0,\n    0,\n    0,\n    1,\n    4,\n    1,\n    96,\n    0,\n    0,\n    3,\n    3,\n    2,\n    0,\n    0,\n    5,\n    3,\n    1,\n    0,\n    1,\n    12,\n    1,\n    0,\n    10,\n    22,\n    2,\n    12,\n    0,\n    65,\n    0,\n    65,\n    0,\n    65,\n    0,\n    252,\n    10,\n    0,\n    0,\n    11,\n    7,\n    0,\n    65,\n    0,\n    253,\n    15,\n    26,\n    11,\n  ])\n\n  // Used to unpack wasm\n  const wasmpack = new Uint8Array([\n    32,\n    0,\n    65,\n    253,\n    3,\n    1,\n    2,\n    34,\n    4,\n    106,\n    6,\n    5,\n    11,\n    8,\n    7,\n    20,\n    13,\n    33,\n    12,\n    16,\n    128,\n    9,\n    116,\n    64,\n    19,\n    113,\n    127,\n    15,\n    10,\n    21,\n    22,\n    14,\n    255,\n    66,\n    24,\n    54,\n    136,\n    107,\n    18,\n    23,\n    192,\n    26,\n    114,\n    118,\n    132,\n    17,\n    77,\n    101,\n    130,\n    144,\n    27,\n    87,\n    131,\n    44,\n    45,\n    74,\n    156,\n    154,\n    70,\n    167,\n  ])\n\n  if (typeof WebAssembly !== 'object') {\n    // This module requires WebAssembly to function\n    return {\n      supported: false,\n    }\n  }\n\n  let wasm = wasm_base\n\n  if (WebAssembly.validate(detector)) {\n    wasm = wasm_simd\n  }\n\n  let instance: any // WebAssembly.Instance\n\n  const promise = WebAssembly.instantiate(unpack(wasm), {}).then((result) => {\n    instance = result.instance\n    instance.exports.__wasm_call_ctors()\n  })\n\n  function unpack(data: string) {\n    const result = new Uint8Array(data.length)\n    for (let i = 0; i < data.length; ++i) {\n      const ch = data.charCodeAt(i)\n      result[i] = ch > 96 ? ch - 71 : ch > 64 ? ch - 65 : ch > 47 ? ch + 4 : ch > 46 ? 63 : 62\n    }\n    let write = 0\n    for (let i = 0; i < data.length; ++i) {\n      result[write++] = result[i] < 60 ? wasmpack[result[i]] : (result[i] - 60) * 64 + result[++i]\n    }\n    return result.buffer.slice(0, write)\n  }\n\n  function decode(\n    fun: Function,\n    target: Uint8Array,\n    count: number,\n    size: number,\n    source: Uint8Array,\n    filter?: Function,\n  ) {\n    const sbrk = instance.exports.sbrk\n    const count4 = (count + 3) & ~3 // pad for SIMD filter\n    const tp = sbrk(count4 * size)\n    const sp = sbrk(source.length)\n    const heap = new Uint8Array(instance.exports.memory.buffer)\n    heap.set(source, sp)\n    const res = fun(tp, count, size, sp, source.length)\n    if (res === 0 && filter) {\n      filter(tp, count4, size)\n    }\n    target.set(heap.subarray(tp, tp + count * size))\n    sbrk(tp - sbrk(0))\n    if (res !== 0) {\n      throw new Error(`Malformed buffer data: ${res}`)\n    }\n  }\n\n  const filters = {\n    // legacy index-based enums for glTF\n    0: '',\n    1: 'meshopt_decodeFilterOct',\n    2: 'meshopt_decodeFilterQuat',\n    3: 'meshopt_decodeFilterExp',\n    // string-based enums for glTF\n    NONE: '',\n    OCTAHEDRAL: 'meshopt_decodeFilterOct',\n    QUATERNION: 'meshopt_decodeFilterQuat',\n    EXPONENTIAL: 'meshopt_decodeFilterExp',\n  }\n\n  const decoders = {\n    // legacy index-based enums for glTF\n    0: 'meshopt_decodeVertexBuffer',\n    1: 'meshopt_decodeIndexBuffer',\n    2: 'meshopt_decodeIndexSequence',\n    // string-based enums for glTF\n    ATTRIBUTES: 'meshopt_decodeVertexBuffer',\n    TRIANGLES: 'meshopt_decodeIndexBuffer',\n    INDICES: 'meshopt_decodeIndexSequence',\n  }\n\n  generated = {\n    ready: promise,\n    supported: true,\n    decodeVertexBuffer(target, count, size, source, filter) {\n      decode(\n        instance.exports.meshopt_decodeVertexBuffer,\n        target,\n        count,\n        size,\n        source,\n        instance.exports[filters[filter as keyof typeof filters]],\n      )\n    },\n    decodeIndexBuffer(target, count, size, source) {\n      decode(instance.exports.meshopt_decodeIndexBuffer, target, count, size, source)\n    },\n    decodeIndexSequence(target, count, size, source) {\n      decode(instance.exports.meshopt_decodeIndexSequence, target, count, size, source)\n    },\n    decodeGltfBuffer(target, count, size, source, mode, filter) {\n      decode(\n        instance.exports[decoders[mode as keyof typeof decoders]],\n        target,\n        count,\n        size,\n        source,\n        instance.exports[filters[filter as keyof typeof filters]],\n      )\n    },\n  }\n\n  return generated\n}\n\nexport { MeshoptDecoder }\n","export const getWithKey = <T, K extends keyof T>(obj: T, key: K): T[K] => obj[key]\n","export function decodeText(array) {\n  if (typeof TextDecoder !== 'undefined') {\n    return new TextDecoder().decode(array)\n  }\n\n  // Avoid the String.fromCharCode.apply(null, array) shortcut, which\n  // throws a \"maximum call stack size exceeded\" error for large arrays.\n\n  let s = ''\n\n  for (let i = 0, il = array.length; i < il; i++) {\n    // Implicitly assumes little-endian.\n    s += String.fromCharCode(array[i])\n  }\n\n  try {\n    // merges multi-byte utf-8 characters.\n\n    return decodeURIComponent(escape(s))\n  } catch (e) {\n    // see https://github.com/mrdoob/three.js/issues/16358\n\n    return s\n  }\n}\n","import * as React from 'react';\nimport { useFrame } from '@react-three/fiber';\nimport * as THREE from 'three';\n\nconst Float = /* @__PURE__ */React.forwardRef(({\n  children,\n  enabled = true,\n  speed = 1,\n  rotationIntensity = 1,\n  floatIntensity = 1,\n  floatingRange = [-0.1, 0.1],\n  autoInvalidate = false,\n  ...props\n}, forwardRef) => {\n  const ref = React.useRef(null);\n  React.useImperativeHandle(forwardRef, () => ref.current, []);\n  const offset = React.useRef(Math.random() * 10000);\n  useFrame(state => {\n    var _floatingRange$, _floatingRange$2;\n    if (!enabled || speed === 0) return;\n    if (autoInvalidate) state.invalidate();\n    const t = offset.current + state.clock.elapsedTime;\n    ref.current.rotation.x = Math.cos(t / 4 * speed) / 8 * rotationIntensity;\n    ref.current.rotation.y = Math.sin(t / 4 * speed) / 8 * rotationIntensity;\n    ref.current.rotation.z = Math.sin(t / 4 * speed) / 20 * rotationIntensity;\n    let yPosition = Math.sin(t / 4 * speed) / 10;\n    yPosition = THREE.MathUtils.mapLinear(yPosition, -0.1, 0.1, (_floatingRange$ = floatingRange == null ? void 0 : floatingRange[0]) !== null && _floatingRange$ !== void 0 ? _floatingRange$ : -0.1, (_floatingRange$2 = floatingRange == null ? void 0 : floatingRange[1]) !== null && _floatingRange$2 !== void 0 ? _floatingRange$2 : 0.1);\n    ref.current.position.y = yPosition * floatIntensity;\n    ref.current.updateMatrix();\n  });\n  return /*#__PURE__*/React.createElement(\"group\", props, /*#__PURE__*/React.createElement(\"group\", {\n    ref: ref,\n    matrixAutoUpdate: false\n  }, children));\n});\n\nexport { Float };\n","import {\n  AnimationClip,\n  AnimationMixer,\n  Matrix4,\n  Quaternion,\n  QuaternionKeyframeTrack,\n  SkeletonHelper,\n  Vector3,\n  VectorKeyframeTrack,\n} from 'three'\n\nfunction retarget(target, source, options = {}) {\n  const pos = new Vector3(),\n    quat = new Quaternion(),\n    scale = new Vector3(),\n    bindBoneMatrix = new Matrix4(),\n    relativeMatrix = new Matrix4(),\n    globalMatrix = new Matrix4()\n\n  options.preserveMatrix = options.preserveMatrix !== undefined ? options.preserveMatrix : true\n  options.preservePosition = options.preservePosition !== undefined ? options.preservePosition : true\n  options.preserveHipPosition = options.preserveHipPosition !== undefined ? options.preserveHipPosition : false\n  options.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false\n  options.hip = options.hip !== undefined ? options.hip : 'hip'\n  options.names = options.names || {}\n\n  const sourceBones = source.isObject3D ? source.skeleton.bones : getBones(source),\n    bones = target.isObject3D ? target.skeleton.bones : getBones(target)\n\n  let bindBones, bone, name, boneTo, bonesPosition\n\n  // reset bones\n\n  if (target.isObject3D) {\n    target.skeleton.pose()\n  } else {\n    options.useTargetMatrix = true\n    options.preserveMatrix = false\n  }\n\n  if (options.preservePosition) {\n    bonesPosition = []\n\n    for (let i = 0; i < bones.length; i++) {\n      bonesPosition.push(bones[i].position.clone())\n    }\n  }\n\n  if (options.preserveMatrix) {\n    // reset matrix\n\n    target.updateMatrixWorld()\n\n    target.matrixWorld.identity()\n\n    // reset children matrix\n\n    for (let i = 0; i < target.children.length; ++i) {\n      target.children[i].updateMatrixWorld(true)\n    }\n  }\n\n  if (options.offsets) {\n    bindBones = []\n\n    for (let i = 0; i < bones.length; ++i) {\n      bone = bones[i]\n      name = options.names[bone.name] || bone.name\n\n      if (options.offsets[name]) {\n        bone.matrix.multiply(options.offsets[name])\n\n        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale)\n\n        bone.updateMatrixWorld()\n      }\n\n      bindBones.push(bone.matrixWorld.clone())\n    }\n  }\n\n  for (let i = 0; i < bones.length; ++i) {\n    bone = bones[i]\n    name = options.names[bone.name] || bone.name\n\n    boneTo = getBoneByName(name, sourceBones)\n\n    globalMatrix.copy(bone.matrixWorld)\n\n    if (boneTo) {\n      boneTo.updateMatrixWorld()\n\n      if (options.useTargetMatrix) {\n        relativeMatrix.copy(boneTo.matrixWorld)\n      } else {\n        relativeMatrix.copy(target.matrixWorld).invert()\n        relativeMatrix.multiply(boneTo.matrixWorld)\n      }\n\n      // ignore scale to extract rotation\n\n      scale.setFromMatrixScale(relativeMatrix)\n      relativeMatrix.scale(scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z))\n\n      // apply to global matrix\n\n      globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix))\n\n      if (target.isObject3D) {\n        const boneIndex = bones.indexOf(bone),\n          wBindMatrix = bindBones\n            ? bindBones[boneIndex]\n            : bindBoneMatrix.copy(target.skeleton.boneInverses[boneIndex]).invert()\n\n        globalMatrix.multiply(wBindMatrix)\n      }\n\n      globalMatrix.copyPosition(relativeMatrix)\n    }\n\n    if (bone.parent && bone.parent.isBone) {\n      bone.matrix.copy(bone.parent.matrixWorld).invert()\n      bone.matrix.multiply(globalMatrix)\n    } else {\n      bone.matrix.copy(globalMatrix)\n    }\n\n    if (options.preserveHipPosition && name === options.hip) {\n      bone.matrix.setPosition(pos.set(0, bone.position.y, 0))\n    }\n\n    bone.matrix.decompose(bone.position, bone.quaternion, bone.scale)\n\n    bone.updateMatrixWorld()\n  }\n\n  if (options.preservePosition) {\n    for (let i = 0; i < bones.length; ++i) {\n      bone = bones[i]\n      name = options.names[bone.name] || bone.name\n\n      if (name !== options.hip) {\n        bone.position.copy(bonesPosition[i])\n      }\n    }\n  }\n\n  if (options.preserveMatrix) {\n    // restore matrix\n\n    target.updateMatrixWorld(true)\n  }\n}\n\nfunction retargetClip(target, source, clip, options = {}) {\n  options.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false\n  options.fps = options.fps !== undefined ? options.fps : 30\n  options.names = options.names || []\n\n  if (!source.isObject3D) {\n    source = getHelperFromSkeleton(source)\n  }\n\n  const numFrames = Math.round(clip.duration * (options.fps / 1000) * 1000),\n    delta = 1 / options.fps,\n    convertedTracks = [],\n    mixer = new AnimationMixer(source),\n    bones = getBones(target.skeleton),\n    boneDatas = []\n  let positionOffset, bone, boneTo, boneData, name\n\n  mixer.clipAction(clip).play()\n  mixer.update(0)\n\n  source.updateMatrixWorld()\n\n  for (let i = 0; i < numFrames; ++i) {\n    const time = i * delta\n\n    retarget(target, source, options)\n\n    for (let j = 0; j < bones.length; ++j) {\n      name = options.names[bones[j].name] || bones[j].name\n\n      boneTo = getBoneByName(name, source.skeleton)\n\n      if (boneTo) {\n        bone = bones[j]\n        boneData = boneDatas[j] = boneDatas[j] || { bone: bone }\n\n        if (options.hip === name) {\n          if (!boneData.pos) {\n            boneData.pos = {\n              times: new Float32Array(numFrames),\n              values: new Float32Array(numFrames * 3),\n            }\n          }\n\n          if (options.useFirstFramePosition) {\n            if (i === 0) {\n              positionOffset = bone.position.clone()\n            }\n\n            bone.position.sub(positionOffset)\n          }\n\n          boneData.pos.times[i] = time\n\n          bone.position.toArray(boneData.pos.values, i * 3)\n        }\n\n        if (!boneData.quat) {\n          boneData.quat = {\n            times: new Float32Array(numFrames),\n            values: new Float32Array(numFrames * 4),\n          }\n        }\n\n        boneData.quat.times[i] = time\n\n        bone.quaternion.toArray(boneData.quat.values, i * 4)\n      }\n    }\n\n    mixer.update(delta)\n\n    source.updateMatrixWorld()\n  }\n\n  for (let i = 0; i < boneDatas.length; ++i) {\n    boneData = boneDatas[i]\n\n    if (boneData) {\n      if (boneData.pos) {\n        convertedTracks.push(\n          new VectorKeyframeTrack(\n            '.bones[' + boneData.bone.name + '].position',\n            boneData.pos.times,\n            boneData.pos.values,\n          ),\n        )\n      }\n\n      convertedTracks.push(\n        new QuaternionKeyframeTrack(\n          '.bones[' + boneData.bone.name + '].quaternion',\n          boneData.quat.times,\n          boneData.quat.values,\n        ),\n      )\n    }\n  }\n\n  mixer.uncacheAction(clip)\n\n  return new AnimationClip(clip.name, -1, convertedTracks)\n}\n\nfunction clone(source) {\n  const sourceLookup = new Map()\n  const cloneLookup = new Map()\n\n  const clone = source.clone()\n\n  parallelTraverse(source, clone, function (sourceNode, clonedNode) {\n    sourceLookup.set(clonedNode, sourceNode)\n    cloneLookup.set(sourceNode, clonedNode)\n  })\n\n  clone.traverse(function (node) {\n    if (!node.isSkinnedMesh) return\n\n    const clonedMesh = node\n    const sourceMesh = sourceLookup.get(node)\n    const sourceBones = sourceMesh.skeleton.bones\n\n    clonedMesh.skeleton = sourceMesh.skeleton.clone()\n    clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix)\n\n    clonedMesh.skeleton.bones = sourceBones.map(function (bone) {\n      return cloneLookup.get(bone)\n    })\n\n    clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix)\n  })\n\n  return clone\n}\n\n// internal helper\n\nfunction getBoneByName(name, skeleton) {\n  for (let i = 0, bones = getBones(skeleton); i < bones.length; i++) {\n    if (name === bones[i].name) return bones[i]\n  }\n}\n\nfunction getBones(skeleton) {\n  return Array.isArray(skeleton) ? skeleton : skeleton.bones\n}\n\nfunction getHelperFromSkeleton(skeleton) {\n  const source = new SkeletonHelper(skeleton.bones[0])\n  source.skeleton = skeleton\n\n  return source\n}\n\nfunction parallelTraverse(a, b, callback) {\n  callback(a, b)\n\n  for (let i = 0; i < a.children.length; i++) {\n    parallelTraverse(a.children[i], b.children[i], callback)\n  }\n}\n\nexport const SkeletonUtils = { retarget, retargetClip, clone }\n","import { BufferAttribute, BufferGeometry, FileLoader, Loader } from 'three'\n\nconst _taskCache = new WeakMap()\n\nclass DRACOLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    this.decoderPath = ''\n    this.decoderConfig = {}\n    this.decoderBinary = null\n    this.decoderPending = null\n\n    this.workerLimit = 4\n    this.workerPool = []\n    this.workerNextTaskID = 1\n    this.workerSourceURL = ''\n\n    this.defaultAttributeIDs = {\n      position: 'POSITION',\n      normal: 'NORMAL',\n      color: 'COLOR',\n      uv: 'TEX_COORD',\n    }\n    this.defaultAttributeTypes = {\n      position: 'Float32Array',\n      normal: 'Float32Array',\n      color: 'Float32Array',\n      uv: 'Float32Array',\n    }\n  }\n\n  setDecoderPath(path) {\n    this.decoderPath = path\n\n    return this\n  }\n\n  setDecoderConfig(config) {\n    this.decoderConfig = config\n\n    return this\n  }\n\n  setWorkerLimit(workerLimit) {\n    this.workerLimit = workerLimit\n\n    return this\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager)\n\n    loader.setPath(this.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(this.requestHeader)\n    loader.setWithCredentials(this.withCredentials)\n\n    loader.load(\n      url,\n      (buffer) => {\n        const taskConfig = {\n          attributeIDs: this.defaultAttributeIDs,\n          attributeTypes: this.defaultAttributeTypes,\n          useUniqueIDs: false,\n        }\n\n        this.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError)\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */\n  decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {\n    const taskConfig = {\n      attributeIDs: attributeIDs || this.defaultAttributeIDs,\n      attributeTypes: attributeTypes || this.defaultAttributeTypes,\n      useUniqueIDs: !!attributeIDs,\n    }\n\n    this.decodeGeometry(buffer, taskConfig).then(callback)\n  }\n\n  decodeGeometry(buffer, taskConfig) {\n    // TODO: For backward-compatibility, support 'attributeTypes' objects containing\n    // references (rather than names) to typed array constructors. These must be\n    // serialized before sending them to the worker.\n    for (const attribute in taskConfig.attributeTypes) {\n      const type = taskConfig.attributeTypes[attribute]\n\n      if (type.BYTES_PER_ELEMENT !== undefined) {\n        taskConfig.attributeTypes[attribute] = type.name\n      }\n    }\n\n    //\n\n    const taskKey = JSON.stringify(taskConfig)\n\n    // Check for an existing task using this buffer. A transferred buffer cannot be transferred\n    // again from this thread.\n    if (_taskCache.has(buffer)) {\n      const cachedTask = _taskCache.get(buffer)\n\n      if (cachedTask.key === taskKey) {\n        return cachedTask.promise\n      } else if (buffer.byteLength === 0) {\n        // Technically, it would be possible to wait for the previous task to complete,\n        // transfer the buffer back, and decode again with the second configuration. That\n        // is complex, and I don't know of any reason to decode a Draco buffer twice in\n        // different ways, so this is left unimplemented.\n        throw new Error(\n          'THREE.DRACOLoader: Unable to re-decode a buffer with different ' +\n            'settings. Buffer has already been transferred.',\n        )\n      }\n    }\n\n    //\n\n    let worker\n    const taskID = this.workerNextTaskID++\n    const taskCost = buffer.byteLength\n\n    // Obtain a worker and assign a task, and construct a geometry instance\n    // when the task completes.\n    const geometryPending = this._getWorker(taskID, taskCost)\n      .then((_worker) => {\n        worker = _worker\n\n        return new Promise((resolve, reject) => {\n          worker._callbacks[taskID] = { resolve, reject }\n\n          worker.postMessage({ type: 'decode', id: taskID, taskConfig, buffer }, [buffer])\n\n          // this.debug();\n        })\n      })\n      .then((message) => this._createGeometry(message.geometry))\n\n    // Remove task from the task list.\n    // Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n    geometryPending\n      .catch(() => true)\n      .then(() => {\n        if (worker && taskID) {\n          this._releaseTask(worker, taskID)\n\n          // this.debug();\n        }\n      })\n\n    // Cache the task result.\n    _taskCache.set(buffer, {\n      key: taskKey,\n      promise: geometryPending,\n    })\n\n    return geometryPending\n  }\n\n  _createGeometry(geometryData) {\n    const geometry = new BufferGeometry()\n\n    if (geometryData.index) {\n      geometry.setIndex(new BufferAttribute(geometryData.index.array, 1))\n    }\n\n    for (let i = 0; i < geometryData.attributes.length; i++) {\n      const attribute = geometryData.attributes[i]\n      const name = attribute.name\n      const array = attribute.array\n      const itemSize = attribute.itemSize\n\n      geometry.setAttribute(name, new BufferAttribute(array, itemSize))\n    }\n\n    return geometry\n  }\n\n  _loadLibrary(url, responseType) {\n    const loader = new FileLoader(this.manager)\n    loader.setPath(this.decoderPath)\n    loader.setResponseType(responseType)\n    loader.setWithCredentials(this.withCredentials)\n\n    return new Promise((resolve, reject) => {\n      loader.load(url, resolve, undefined, reject)\n    })\n  }\n\n  preload() {\n    this._initDecoder()\n\n    return this\n  }\n\n  _initDecoder() {\n    if (this.decoderPending) return this.decoderPending\n\n    const useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js'\n    const librariesPending = []\n\n    if (useJS) {\n      librariesPending.push(this._loadLibrary('draco_decoder.js', 'text'))\n    } else {\n      librariesPending.push(this._loadLibrary('draco_wasm_wrapper.js', 'text'))\n      librariesPending.push(this._loadLibrary('draco_decoder.wasm', 'arraybuffer'))\n    }\n\n    this.decoderPending = Promise.all(librariesPending).then((libraries) => {\n      const jsContent = libraries[0]\n\n      if (!useJS) {\n        this.decoderConfig.wasmBinary = libraries[1]\n      }\n\n      const fn = DRACOWorker.toString()\n\n      const body = [\n        '/* draco decoder */',\n        jsContent,\n        '',\n        '/* worker */',\n        fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}')),\n      ].join('\\n')\n\n      this.workerSourceURL = URL.createObjectURL(new Blob([body]))\n    })\n\n    return this.decoderPending\n  }\n\n  _getWorker(taskID, taskCost) {\n    return this._initDecoder().then(() => {\n      if (this.workerPool.length < this.workerLimit) {\n        const worker = new Worker(this.workerSourceURL)\n\n        worker._callbacks = {}\n        worker._taskCosts = {}\n        worker._taskLoad = 0\n\n        worker.postMessage({ type: 'init', decoderConfig: this.decoderConfig })\n\n        worker.onmessage = function (e) {\n          const message = e.data\n\n          switch (message.type) {\n            case 'decode':\n              worker._callbacks[message.id].resolve(message)\n              break\n\n            case 'error':\n              worker._callbacks[message.id].reject(message)\n              break\n\n            default:\n              console.error('THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"')\n          }\n        }\n\n        this.workerPool.push(worker)\n      } else {\n        this.workerPool.sort(function (a, b) {\n          return a._taskLoad > b._taskLoad ? -1 : 1\n        })\n      }\n\n      const worker = this.workerPool[this.workerPool.length - 1]\n      worker._taskCosts[taskID] = taskCost\n      worker._taskLoad += taskCost\n      return worker\n    })\n  }\n\n  _releaseTask(worker, taskID) {\n    worker._taskLoad -= worker._taskCosts[taskID]\n    delete worker._callbacks[taskID]\n    delete worker._taskCosts[taskID]\n  }\n\n  debug() {\n    console.log(\n      'Task load: ',\n      this.workerPool.map((worker) => worker._taskLoad),\n    )\n  }\n\n  dispose() {\n    for (let i = 0; i < this.workerPool.length; ++i) {\n      this.workerPool[i].terminate()\n    }\n\n    this.workerPool.length = 0\n\n    return this\n  }\n}\n\n/* WEB WORKER */\n\nfunction DRACOWorker() {\n  let decoderConfig\n  let decoderPending\n\n  onmessage = function (e) {\n    const message = e.data\n\n    switch (message.type) {\n      case 'init':\n        decoderConfig = message.decoderConfig\n        decoderPending = new Promise(function (resolve /*, reject*/) {\n          decoderConfig.onModuleLoaded = function (draco) {\n            // Module is Promise-like. Wrap before resolving to avoid loop.\n            resolve({ draco: draco })\n          }\n\n          DracoDecoderModule(decoderConfig)\n        })\n        break\n\n      case 'decode':\n        const buffer = message.buffer\n        const taskConfig = message.taskConfig\n        decoderPending.then((module) => {\n          const draco = module.draco\n          const decoder = new draco.Decoder()\n          const decoderBuffer = new draco.DecoderBuffer()\n          decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength)\n\n          try {\n            const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig)\n\n            const buffers = geometry.attributes.map((attr) => attr.array.buffer)\n\n            if (geometry.index) buffers.push(geometry.index.array.buffer)\n\n            self.postMessage({ type: 'decode', id: message.id, geometry }, buffers)\n          } catch (error) {\n            console.error(error)\n\n            self.postMessage({ type: 'error', id: message.id, error: error.message })\n          } finally {\n            draco.destroy(decoderBuffer)\n            draco.destroy(decoder)\n          }\n        })\n        break\n    }\n  }\n\n  function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n    const attributeIDs = taskConfig.attributeIDs\n    const attributeTypes = taskConfig.attributeTypes\n\n    let dracoGeometry\n    let decodingStatus\n\n    const geometryType = decoder.GetEncodedGeometryType(decoderBuffer)\n\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      dracoGeometry = new draco.Mesh()\n      decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry)\n    } else if (geometryType === draco.POINT_CLOUD) {\n      dracoGeometry = new draco.PointCloud()\n      decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry)\n    } else {\n      throw new Error('THREE.DRACOLoader: Unexpected geometry type.')\n    }\n\n    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n      throw new Error('THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg())\n    }\n\n    const geometry = { index: null, attributes: [] }\n\n    // Gather all vertex attributes.\n    for (const attributeName in attributeIDs) {\n      const attributeType = self[attributeTypes[attributeName]]\n\n      let attribute\n      let attributeID\n\n      // A Draco file may be created with default vertex attributes, whose attribute IDs\n      // are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n      // a Draco file may contain a custom set of attributes, identified by known unique\n      // IDs. glTF files always do the latter, and `.drc` files typically do the former.\n      if (taskConfig.useUniqueIDs) {\n        attributeID = attributeIDs[attributeName]\n        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID)\n      } else {\n        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]])\n\n        if (attributeID === -1) continue\n\n        attribute = decoder.GetAttribute(dracoGeometry, attributeID)\n      }\n\n      geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute))\n    }\n\n    // Add index.\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      geometry.index = decodeIndex(draco, decoder, dracoGeometry)\n    }\n\n    draco.destroy(dracoGeometry)\n\n    return geometry\n  }\n\n  function decodeIndex(draco, decoder, dracoGeometry) {\n    const numFaces = dracoGeometry.num_faces()\n    const numIndices = numFaces * 3\n    const byteLength = numIndices * 4\n\n    const ptr = draco._malloc(byteLength)\n    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr)\n    const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice()\n    draco._free(ptr)\n\n    return { array: index, itemSize: 1 }\n  }\n\n  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n    const numComponents = attribute.num_components()\n    const numPoints = dracoGeometry.num_points()\n    const numValues = numPoints * numComponents\n    const byteLength = numValues * attributeType.BYTES_PER_ELEMENT\n    const dataType = getDracoDataType(draco, attributeType)\n\n    const ptr = draco._malloc(byteLength)\n    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr)\n    const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice()\n    draco._free(ptr)\n\n    return {\n      name: attributeName,\n      array: array,\n      itemSize: numComponents,\n    }\n  }\n\n  function getDracoDataType(draco, attributeType) {\n    switch (attributeType) {\n      case Float32Array:\n        return draco.DT_FLOAT32\n      case Int8Array:\n        return draco.DT_INT8\n      case Int16Array:\n        return draco.DT_INT16\n      case Int32Array:\n        return draco.DT_INT32\n      case Uint8Array:\n        return draco.DT_UINT8\n      case Uint16Array:\n        return draco.DT_UINT16\n      case Uint32Array:\n        return draco.DT_UINT32\n    }\n  }\n}\n\nexport { DRACOLoader }\n","import { shaderMaterial } from '../core/shaderMaterial.js';\n\nconst DiscardMaterial = /* @__PURE__ */shaderMaterial({}, 'void main() { }', 'void main() { gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0); discard;  }');\n\nexport { DiscardMaterial };\n","import * as THREE from 'three';\n\nfunction shaderMaterial(uniforms, vertexShader, fragmentShader, onInit) {\n  var _Class;\n  return _Class = class extends THREE.ShaderMaterial {\n    constructor(parameters) {\n      super({\n        vertexShader,\n        fragmentShader,\n        ...parameters\n      });\n      for (const key in uniforms) {\n        this.uniforms[key] = new THREE.Uniform(uniforms[key]);\n        Object.defineProperty(this, key, {\n          get() {\n            return this.uniforms[key].value;\n          },\n          set(value) {\n            this.uniforms[key].value = value;\n          }\n        });\n      }\n      this.uniforms = THREE.UniformsUtils.clone(this.uniforms);\n      onInit == null || onInit(this);\n    }\n  }, _Class.key = THREE.MathUtils.generateUUID(), _Class;\n}\n\nexport { shaderMaterial };\n","import {\n  BufferAttribute,\n  BufferGeometry,\n  Float32BufferAttribute,\n  InterleavedBuffer,\n  InterleavedBufferAttribute,\n  TriangleFanDrawMode,\n  TriangleStripDrawMode,\n  TrianglesDrawMode,\n  Vector3,\n  Mesh,\n  Line,\n  Points,\n  Material,\n  SkinnedMesh,\n} from 'three'\n\nimport { getWithKey } from '../types/helpers'\nimport type { TypedArrayConstructors, TypedArray } from '../types/shared'\n\n/**\n * @param  {Array<BufferGeometry>} geometries\n * @param  {Boolean} useGroups\n * @return {BufferGeometry}\n */\nexport const mergeBufferGeometries = (geometries: BufferGeometry[], useGroups?: boolean): BufferGeometry | null => {\n  const isIndexed = geometries[0].index !== null\n\n  const attributesUsed = new Set(Object.keys(geometries[0].attributes))\n  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes))\n\n  const attributes: { [key: string]: Array<InterleavedBufferAttribute | BufferAttribute> } = {}\n  const morphAttributes: { [key: string]: Array<BufferAttribute | InterleavedBufferAttribute>[] } = {}\n\n  const morphTargetsRelative = geometries[0].morphTargetsRelative\n\n  const mergedGeometry = new BufferGeometry()\n\n  let offset = 0\n\n  geometries.forEach((geom, i) => {\n    let attributesCount = 0\n\n    // ensure that all geometries are indexed, or none\n\n    if (isIndexed !== (geom.index !== null)) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n          i +\n          '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.',\n      )\n      return null\n    }\n\n    // gather attributes, exit early if they're different\n\n    for (let name in geom.attributes) {\n      if (!attributesUsed.has(name)) {\n        console.error(\n          'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n            i +\n            '. All geometries must have compatible attributes; make sure \"' +\n            name +\n            '\" attribute exists among all geometries, or in none of them.',\n        )\n        return null\n      }\n\n      if (attributes[name] === undefined) {\n        attributes[name] = []\n      }\n\n      attributes[name].push(geom.attributes[name])\n\n      attributesCount++\n    }\n\n    // ensure geometries have the same number of attributes\n\n    if (attributesCount !== attributesUsed.size) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n          i +\n          '. Make sure all geometries have the same number of attributes.',\n      )\n      return null\n    }\n\n    // gather morph attributes, exit early if they're different\n\n    if (morphTargetsRelative !== geom.morphTargetsRelative) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n          i +\n          '. .morphTargetsRelative must be consistent throughout all geometries.',\n      )\n      return null\n    }\n\n    for (let name in geom.morphAttributes) {\n      if (!morphAttributesUsed.has(name)) {\n        console.error(\n          'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n            i +\n            '.  .morphAttributes must be consistent throughout all geometries.',\n        )\n        return null\n      }\n\n      if (morphAttributes[name] === undefined) morphAttributes[name] = []\n\n      morphAttributes[name].push(geom.morphAttributes[name])\n    }\n\n    // gather .userData\n\n    mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || []\n    mergedGeometry.userData.mergedUserData.push(geom.userData)\n\n    if (useGroups) {\n      let count\n\n      if (geom.index) {\n        count = geom.index.count\n      } else if (geom.attributes.position !== undefined) {\n        count = geom.attributes.position.count\n      } else {\n        console.error(\n          'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n            i +\n            '. The geometry must have either an index or a position attribute',\n        )\n        return null\n      }\n\n      mergedGeometry.addGroup(offset, count, i)\n\n      offset += count\n    }\n  })\n\n  // merge indices\n\n  if (isIndexed) {\n    let indexOffset = 0\n    const mergedIndex: number[] = []\n\n    geometries.forEach((geom) => {\n      const index = geom.index as BufferAttribute\n\n      for (let j = 0; j < index.count; ++j) {\n        mergedIndex.push(index.getX(j) + indexOffset)\n      }\n\n      indexOffset += geom.attributes.position.count\n    })\n\n    mergedGeometry.setIndex(mergedIndex)\n  }\n\n  // merge attributes\n\n  for (let name in attributes) {\n    const mergedAttribute = mergeBufferAttributes(attributes[name] as BufferAttribute[])\n\n    if (!mergedAttribute) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' attribute.',\n      )\n      return null\n    }\n\n    mergedGeometry.setAttribute(name, mergedAttribute)\n  }\n\n  // merge morph attributes\n\n  for (let name in morphAttributes) {\n    const numMorphTargets = morphAttributes[name][0].length\n\n    if (numMorphTargets === 0) break\n\n    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {}\n    mergedGeometry.morphAttributes[name] = []\n\n    for (let i = 0; i < numMorphTargets; ++i) {\n      const morphAttributesToMerge = []\n\n      for (let j = 0; j < morphAttributes[name].length; ++j) {\n        morphAttributesToMerge.push(morphAttributes[name][j][i])\n      }\n\n      const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge as BufferAttribute[])\n\n      if (!mergedMorphAttribute) {\n        console.error(\n          'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' +\n            name +\n            ' morphAttribute.',\n        )\n        return null\n      }\n\n      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute)\n    }\n  }\n\n  return mergedGeometry\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */\nexport const mergeBufferAttributes = (attributes: BufferAttribute[]): BufferAttribute | null | undefined => {\n  let TypedArray: TypedArrayConstructors | undefined = undefined\n  let itemSize: number | undefined = undefined\n  let normalized: boolean | undefined = undefined\n  let arrayLength = 0\n\n  attributes.forEach((attr) => {\n    if (TypedArray === undefined) {\n      TypedArray = attr.array.constructor\n    }\n    if (TypedArray !== attr.array.constructor) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.',\n      )\n      return null\n    }\n\n    if (itemSize === undefined) itemSize = attr.itemSize\n    if (itemSize !== attr.itemSize) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.',\n      )\n      return null\n    }\n\n    if (normalized === undefined) normalized = attr.normalized\n    if (normalized !== attr.normalized) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.',\n      )\n      return null\n    }\n\n    arrayLength += attr.array.length\n  })\n\n  if (TypedArray && itemSize) {\n    // @ts-ignore this works in JS and TS is complaining but it's such a tiny thing I can live with the guilt\n    const array = new TypedArray(arrayLength)\n    let offset = 0\n\n    attributes.forEach((attr) => {\n      array.set(attr.array, offset)\n      offset += attr.array.length\n    })\n\n    return new BufferAttribute(array, itemSize, normalized)\n  }\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */\nexport const interleaveAttributes = (attributes: BufferAttribute[]): InterleavedBufferAttribute[] | null => {\n  // Interleaves the provided attributes into an InterleavedBuffer and returns\n  // a set of InterleavedBufferAttributes for each attribute\n  let TypedArray: TypedArrayConstructors | undefined = undefined\n  let arrayLength = 0\n  let stride = 0\n\n  // calculate the the length and type of the interleavedBuffer\n  for (let i = 0, l = attributes.length; i < l; ++i) {\n    const attribute = attributes[i]\n\n    if (TypedArray === undefined) TypedArray = attribute.array.constructor\n    if (TypedArray !== attribute.array.constructor) {\n      console.error('AttributeBuffers of different types cannot be interleaved')\n      return null\n    }\n\n    arrayLength += attribute.array.length\n    stride += attribute.itemSize\n  }\n\n  // Create the set of buffer attributes\n  // @ts-ignore this works in JS and TS is complaining but it's such a tiny thing I can live with the guilt\n  const interleavedBuffer = new InterleavedBuffer(new TypedArray(arrayLength), stride)\n  let offset = 0\n  const res = []\n  const getters = ['getX', 'getY', 'getZ', 'getW']\n  const setters = ['setX', 'setY', 'setZ', 'setW']\n\n  for (let j = 0, l = attributes.length; j < l; j++) {\n    const attribute = attributes[j]\n    const itemSize = attribute.itemSize\n    const count = attribute.count\n    const iba = new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized)\n    res.push(iba)\n\n    offset += itemSize\n\n    // Move the data for each attribute into the new interleavedBuffer\n    // at the appropriate offset\n    for (let c = 0; c < count; c++) {\n      for (let k = 0; k < itemSize; k++) {\n        const set = getWithKey(iba, setters[k] as keyof InterleavedBufferAttribute) as InterleavedBufferAttribute[\n          | 'setX'\n          | 'setY'\n          | 'setZ'\n          | 'setW']\n        const get = getWithKey(attribute, getters[k] as keyof BufferAttribute) as BufferAttribute[\n          | 'getX'\n          | 'getY'\n          | 'getZ'\n          | 'getW']\n        set(c, get(c))\n      }\n    }\n  }\n\n  return res\n}\n\n/**\n * @param {Array<BufferGeometry>} geometry\n * @return {number}\n */\nexport function estimateBytesUsed(geometry: BufferGeometry): number {\n  // Return the estimated memory used by this geometry in bytes\n  // Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n  // for InterleavedBufferAttributes.\n  let mem = 0\n  for (let name in geometry.attributes) {\n    const attr = geometry.getAttribute(name)\n    mem += attr.count * attr.itemSize * (attr.array as TypedArray).BYTES_PER_ELEMENT\n  }\n\n  const indices = geometry.getIndex()\n  mem += indices ? indices.count * indices.itemSize * (indices.array as TypedArray).BYTES_PER_ELEMENT : 0\n  return mem\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry>}\n */\nexport function mergeVertices(geometry: BufferGeometry, tolerance = 1e-4): BufferGeometry {\n  tolerance = Math.max(tolerance, Number.EPSILON)\n\n  // Generate an index buffer if the geometry doesn't have one, or optimize it\n  // if it's already available.\n  const hashToIndex: {\n    [key: string]: number\n  } = {}\n  const indices = geometry.getIndex()\n  const positions = geometry.getAttribute('position')\n  const vertexCount = indices ? indices.count : positions.count\n\n  // next value for triangle indices\n  let nextIndex = 0\n\n  // attributes and new attribute arrays\n  const attributeNames = Object.keys(geometry.attributes)\n  const attrArrays: {\n    [key: string]: []\n  } = {}\n  const morphAttrsArrays: {\n    [key: string]: Array<Array<BufferAttribute | InterleavedBufferAttribute>>\n  } = {}\n  const newIndices = []\n  const getters = ['getX', 'getY', 'getZ', 'getW']\n\n  // initialize the arrays\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i]\n\n    attrArrays[name] = []\n\n    const morphAttr = geometry.morphAttributes[name]\n    if (morphAttr) {\n      morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(() => [])\n    }\n  }\n\n  // convert the error tolerance to an amount of decimal places to truncate to\n  const decimalShift = Math.log10(1 / tolerance)\n  const shiftMultiplier = Math.pow(10, decimalShift)\n  for (let i = 0; i < vertexCount; i++) {\n    const index = indices ? indices.getX(i) : i\n\n    // Generate a hash for the vertex attributes at the current index 'i'\n    let hash = ''\n    for (let j = 0, l = attributeNames.length; j < l; j++) {\n      const name = attributeNames[j]\n      const attribute = geometry.getAttribute(name)\n      const itemSize = attribute.itemSize\n\n      for (let k = 0; k < itemSize; k++) {\n        // double tilde truncates the decimal value\n        // @ts-ignore no\n        hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`\n      }\n    }\n\n    // Add another reference to the vertex if it's already\n    // used by another index\n    if (hash in hashToIndex) {\n      newIndices.push(hashToIndex[hash])\n    } else {\n      // copy data to the new index in the attribute arrays\n      for (let j = 0, l = attributeNames.length; j < l; j++) {\n        const name = attributeNames[j]\n        const attribute = geometry.getAttribute(name)\n        const morphAttr = geometry.morphAttributes[name]\n        const itemSize = attribute.itemSize\n        const newarray = attrArrays[name]\n        const newMorphArrays = morphAttrsArrays[name]\n\n        for (let k = 0; k < itemSize; k++) {\n          const getterFunc = getters[k]\n          // @ts-ignore\n          newarray.push(attribute[getterFunc](index))\n\n          if (morphAttr) {\n            for (let m = 0, ml = morphAttr.length; m < ml; m++) {\n              // @ts-ignore\n              newMorphArrays[m].push(morphAttr[m][getterFunc](index))\n            }\n          }\n        }\n      }\n\n      hashToIndex[hash] = nextIndex\n      newIndices.push(nextIndex)\n      nextIndex++\n    }\n  }\n\n  // Generate typed arrays from new attribute arrays and update\n  // the attributeBuffers\n  const result = geometry.clone()\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i]\n    const oldAttribute = geometry.getAttribute(name)\n    //@ts-expect-error  something to do with functions and constructors and new\n    const buffer = new (oldAttribute.array as TypedArray).constructor(attrArrays[name])\n    const attribute = new BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized)\n\n    result.setAttribute(name, attribute)\n\n    // Update the attribute arrays\n    if (name in morphAttrsArrays) {\n      for (let j = 0; j < morphAttrsArrays[name].length; j++) {\n        const oldMorphAttribute = geometry.morphAttributes[name][j]\n        //@ts-expect-error something to do with functions and constructors and new\n        const buffer = new (oldMorphAttribute.array as TypedArray).constructor(morphAttrsArrays[name][j])\n        const morphAttribute = new BufferAttribute(buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized)\n        result.morphAttributes[name][j] = morphAttribute\n      }\n    }\n  }\n\n  // indices\n\n  result.setIndex(newIndices)\n\n  return result\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry}\n */\nexport function toTrianglesDrawMode(geometry: BufferGeometry, drawMode: number): BufferGeometry {\n  if (drawMode === TrianglesDrawMode) {\n    console.warn('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.')\n    return geometry\n  }\n\n  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {\n    let index = geometry.getIndex()\n\n    // generate index if not present\n\n    if (index === null) {\n      const indices = []\n\n      const position = geometry.getAttribute('position')\n\n      if (position !== undefined) {\n        for (let i = 0; i < position.count; i++) {\n          indices.push(i)\n        }\n\n        geometry.setIndex(indices)\n        index = geometry.getIndex()\n      } else {\n        console.error(\n          'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.',\n        )\n        return geometry\n      }\n    }\n\n    //\n\n    const numberOfTriangles = (index as BufferAttribute).count - 2\n    const newIndices = []\n\n    if (index) {\n      if (drawMode === TriangleFanDrawMode) {\n        // gl.TRIANGLE_FAN\n\n        for (let i = 1; i <= numberOfTriangles; i++) {\n          newIndices.push(index.getX(0))\n          newIndices.push(index.getX(i))\n          newIndices.push(index.getX(i + 1))\n        }\n      } else {\n        // gl.TRIANGLE_STRIP\n\n        for (let i = 0; i < numberOfTriangles; i++) {\n          if (i % 2 === 0) {\n            newIndices.push(index.getX(i))\n            newIndices.push(index.getX(i + 1))\n            newIndices.push(index.getX(i + 2))\n          } else {\n            newIndices.push(index.getX(i + 2))\n            newIndices.push(index.getX(i + 1))\n            newIndices.push(index.getX(i))\n          }\n        }\n      }\n    }\n\n    if (newIndices.length / 3 !== numberOfTriangles) {\n      console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.')\n    }\n\n    // build final geometry\n\n    const newGeometry = geometry.clone()\n    newGeometry.setIndex(newIndices)\n    newGeometry.clearGroups()\n\n    return newGeometry\n  } else {\n    console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode)\n    return geometry\n  }\n}\n\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */\nexport type ComputedMorphedAttribute = {\n  positionAttribute: BufferAttribute | InterleavedBufferAttribute\n  normalAttribute: BufferAttribute | InterleavedBufferAttribute\n  morphedPositionAttribute: Float32BufferAttribute\n  morphedNormalAttribute: Float32BufferAttribute\n}\n\nexport function computeMorphedAttributes(object: Mesh | Line | Points): ComputedMorphedAttribute | null {\n  if (object.geometry.isBufferGeometry !== true) {\n    console.error('THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.')\n    return null\n  }\n\n  const _vA = new Vector3()\n  const _vB = new Vector3()\n  const _vC = new Vector3()\n\n  const _tempA = new Vector3()\n  const _tempB = new Vector3()\n  const _tempC = new Vector3()\n\n  const _morphA = new Vector3()\n  const _morphB = new Vector3()\n  const _morphC = new Vector3()\n\n  function _calculateMorphedAttributeData(\n    object: Mesh | Line | Points,\n    material: Material,\n    attribute: BufferAttribute | InterleavedBufferAttribute,\n    morphAttribute: (BufferAttribute | InterleavedBufferAttribute)[],\n    morphTargetsRelative: boolean,\n    a: number,\n    b: number,\n    c: number,\n    modifiedAttributeArray: Float32Array,\n  ): void {\n    _vA.fromBufferAttribute(attribute, a)\n    _vB.fromBufferAttribute(attribute, b)\n    _vC.fromBufferAttribute(attribute, c)\n\n    const morphInfluences = object.morphTargetInfluences\n\n    if (\n      // @ts-ignore\n      material.morphTargets &&\n      morphAttribute &&\n      morphInfluences\n    ) {\n      _morphA.set(0, 0, 0)\n      _morphB.set(0, 0, 0)\n      _morphC.set(0, 0, 0)\n\n      for (let i = 0, il = morphAttribute.length; i < il; i++) {\n        const influence = morphInfluences[i]\n        const morph = morphAttribute[i]\n\n        if (influence === 0) continue\n\n        _tempA.fromBufferAttribute(morph, a)\n        _tempB.fromBufferAttribute(morph, b)\n        _tempC.fromBufferAttribute(morph, c)\n\n        if (morphTargetsRelative) {\n          _morphA.addScaledVector(_tempA, influence)\n          _morphB.addScaledVector(_tempB, influence)\n          _morphC.addScaledVector(_tempC, influence)\n        } else {\n          _morphA.addScaledVector(_tempA.sub(_vA), influence)\n          _morphB.addScaledVector(_tempB.sub(_vB), influence)\n          _morphC.addScaledVector(_tempC.sub(_vC), influence)\n        }\n      }\n\n      _vA.add(_morphA)\n      _vB.add(_morphB)\n      _vC.add(_morphC)\n    }\n\n    if ((object as SkinnedMesh).isSkinnedMesh) {\n      // @ts-ignore â€“ https://github.com/three-types/three-ts-types/issues/37\n      object.boneTransform(a, _vA)\n      // @ts-ignore â€“ https://github.com/three-types/three-ts-types/issues/37\n      object.boneTransform(b, _vB)\n      // @ts-ignore â€“ https://github.com/three-types/three-ts-types/issues/37\n      object.boneTransform(c, _vC)\n    }\n\n    modifiedAttributeArray[a * 3 + 0] = _vA.x\n    modifiedAttributeArray[a * 3 + 1] = _vA.y\n    modifiedAttributeArray[a * 3 + 2] = _vA.z\n    modifiedAttributeArray[b * 3 + 0] = _vB.x\n    modifiedAttributeArray[b * 3 + 1] = _vB.y\n    modifiedAttributeArray[b * 3 + 2] = _vB.z\n    modifiedAttributeArray[c * 3 + 0] = _vC.x\n    modifiedAttributeArray[c * 3 + 1] = _vC.y\n    modifiedAttributeArray[c * 3 + 2] = _vC.z\n  }\n\n  const geometry = object.geometry\n  const material = object.material\n\n  let a, b, c\n  const index = geometry.index\n  const positionAttribute = geometry.attributes.position\n  const morphPosition = geometry.morphAttributes.position\n  const morphTargetsRelative = geometry.morphTargetsRelative\n  const normalAttribute = geometry.attributes.normal\n  const morphNormal = geometry.morphAttributes.position\n\n  const groups = geometry.groups\n  const drawRange = geometry.drawRange\n  let i, j, il, jl\n  let group, groupMaterial\n  let start, end\n\n  const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize)\n  const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize)\n\n  if (index !== null) {\n    // indexed buffer geometry\n\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i]\n        groupMaterial = material[group.materialIndex as number]\n\n        start = Math.max(group.start, drawRange.start)\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count)\n\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = index.getX(j)\n          b = index.getX(j + 1)\n          c = index.getX(j + 2)\n\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition,\n          )\n\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal,\n          )\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start)\n      end = Math.min(index.count, drawRange.start + drawRange.count)\n\n      for (i = start, il = end; i < il; i += 3) {\n        a = index.getX(i)\n        b = index.getX(i + 1)\n        c = index.getX(i + 2)\n\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition,\n        )\n\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal,\n        )\n      }\n    }\n  } else if (positionAttribute !== undefined) {\n    // non-indexed buffer geometry\n\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i]\n        groupMaterial = material[group.materialIndex as number]\n\n        start = Math.max(group.start, drawRange.start)\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count)\n\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = j\n          b = j + 1\n          c = j + 2\n\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition,\n          )\n\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal,\n          )\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start)\n      end = Math.min(positionAttribute.count, drawRange.start + drawRange.count)\n\n      for (i = start, il = end; i < il; i += 3) {\n        a = i\n        b = i + 1\n        c = i + 2\n\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition,\n        )\n\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal,\n        )\n      }\n    }\n  }\n\n  const morphedPositionAttribute = new Float32BufferAttribute(modifiedPosition, 3)\n  const morphedNormalAttribute = new Float32BufferAttribute(modifiedNormal, 3)\n\n  return {\n    positionAttribute: positionAttribute,\n    normalAttribute: normalAttribute,\n    morphedPositionAttribute: morphedPositionAttribute,\n    morphedNormalAttribute: morphedNormalAttribute,\n  }\n}\n\n/**\n * Modifies the supplied geometry if it is non-indexed, otherwise creates a new,\n * non-indexed geometry. Returns the geometry with smooth normals everywhere except\n * faces that meet at an angle greater than the crease angle.\n *\n * Backwards compatible with code such as @react-three/drei's `<RoundedBox>`\n * which uses this method to operate on the original geometry.\n *\n * As of this writing, BufferGeometry.toNonIndexed() warns if the geometry is\n * non-indexed and returns `this`, i.e. the same geometry on which it was called:\n * `BufferGeometry is already non-indexed.`\n *\n * @param geometry\n * @param creaseAngle\n */\nexport function toCreasedNormals(geometry: BufferGeometry, creaseAngle = Math.PI / 3 /* 60 degrees */): BufferGeometry {\n  const creaseDot = Math.cos(creaseAngle)\n  const hashMultiplier = (1 + 1e-10) * 1e2\n\n  // reusable vectors\n  const verts = [new Vector3(), new Vector3(), new Vector3()]\n  const tempVec1 = new Vector3()\n  const tempVec2 = new Vector3()\n  const tempNorm = new Vector3()\n  const tempNorm2 = new Vector3()\n\n  // hashes a vector\n  function hashVertex(v: Vector3): string {\n    const x = ~~(v.x * hashMultiplier)\n    const y = ~~(v.y * hashMultiplier)\n    const z = ~~(v.z * hashMultiplier)\n    return `${x},${y},${z}`\n  }\n\n  const resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry\n  const posAttr = resultGeometry.attributes.position\n  const vertexMap: { [key: string]: Vector3[] } = {}\n\n  // find all the normals shared by commonly located vertices\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0)\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1)\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2)\n\n    tempVec1.subVectors(c, b)\n    tempVec2.subVectors(a, b)\n\n    // add the normal to the map for all vertices\n    const normal = new Vector3().crossVectors(tempVec1, tempVec2).normalize()\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n]\n      const hash = hashVertex(vert)\n      if (!(hash in vertexMap)) {\n        vertexMap[hash] = []\n      }\n\n      vertexMap[hash].push(normal)\n    }\n  }\n\n  // average normals from all vertices that share a common location if they are within the\n  // provided crease threshold\n  const normalArray = new Float32Array(posAttr.count * 3)\n  const normAttr = new BufferAttribute(normalArray, 3, false)\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    // get the face normal for this vertex\n    const i3 = 3 * i\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0)\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1)\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2)\n\n    tempVec1.subVectors(c, b)\n    tempVec2.subVectors(a, b)\n\n    tempNorm.crossVectors(tempVec1, tempVec2).normalize()\n\n    // average all normals that meet the threshold and set the normal value\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n]\n      const hash = hashVertex(vert)\n      const otherNormals = vertexMap[hash]\n      tempNorm2.set(0, 0, 0)\n\n      for (let k = 0, lk = otherNormals.length; k < lk; k++) {\n        const otherNorm = otherNormals[k]\n        if (tempNorm.dot(otherNorm) > creaseDot) {\n          tempNorm2.add(otherNorm)\n        }\n      }\n\n      tempNorm2.normalize()\n      normAttr.setXYZ(i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z)\n    }\n  }\n\n  resultGeometry.setAttribute('normal', normAttr)\n  return resultGeometry\n}\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport { GLTFLoader, DRACOLoader, MeshoptDecoder } from 'three-stdlib';\nimport { useLoader } from '@react-three/fiber';\nimport { Clone } from './Clone.js';\n\nlet dracoLoader = null;\nlet decoderPath = 'https://www.gstatic.com/draco/versioned/decoders/1.5.5/';\nfunction extensions(useDraco = true, useMeshopt = true, extendLoader) {\n  return loader => {\n    if (extendLoader) {\n      extendLoader(loader);\n    }\n    if (useDraco) {\n      if (!dracoLoader) {\n        dracoLoader = new DRACOLoader();\n      }\n      dracoLoader.setDecoderPath(typeof useDraco === 'string' ? useDraco : decoderPath);\n      loader.setDRACOLoader(dracoLoader);\n    }\n    if (useMeshopt) {\n      loader.setMeshoptDecoder(typeof MeshoptDecoder === 'function' ? MeshoptDecoder() : MeshoptDecoder);\n    }\n  };\n}\nconst useGLTF = (path, useDraco, useMeshopt, extendLoader) => useLoader(GLTFLoader, path, extensions(useDraco, useMeshopt, extendLoader));\nuseGLTF.preload = (path, useDraco, useMeshopt, extendLoader) => useLoader.preload(GLTFLoader, path, extensions(useDraco, useMeshopt, extendLoader));\nuseGLTF.clear = path => useLoader.clear(GLTFLoader, path);\nuseGLTF.setDecoderPath = path => {\n  decoderPath = path;\n};\n\n//\n\nconst Gltf = /* @__PURE__ */React.forwardRef(({\n  src,\n  useDraco,\n  useMeshOpt,\n  extendLoader,\n  ...props\n}, ref) => {\n  const {\n    scene\n  } = useGLTF(src, useDraco, useMeshOpt, extendLoader);\n  return /*#__PURE__*/React.createElement(Clone, _extends({\n    ref: ref\n  }, props, {\n    object: scene\n  }));\n});\n\nexport { Gltf, useGLTF };\n","import {\n  AnimationClip,\n  Bone,\n  Box3,\n  BufferAttribute,\n  BufferGeometry,\n  ClampToEdgeWrapping,\n  Color,\n  DirectionalLight,\n  DoubleSide,\n  FileLoader,\n  FrontSide,\n  Group,\n  ImageBitmapLoader,\n  InstancedMesh,\n  InterleavedBuffer,\n  InterleavedBufferAttribute,\n  Interpolant,\n  InterpolateDiscrete,\n  InterpolateLinear,\n  Line,\n  LineBasicMaterial,\n  LineLoop,\n  LineSegments,\n  LinearFilter,\n  LinearMipmapLinearFilter,\n  LinearMipmapNearestFilter,\n  Loader,\n  LoaderUtils,\n  Material,\n  MathUtils,\n  Matrix4,\n  Mesh,\n  MeshBasicMaterial,\n  MeshPhysicalMaterial,\n  MeshStandardMaterial,\n  MirroredRepeatWrapping,\n  NearestFilter,\n  NearestMipmapLinearFilter,\n  NearestMipmapNearestFilter,\n  NumberKeyframeTrack,\n  Object3D,\n  OrthographicCamera,\n  PerspectiveCamera,\n  PointLight,\n  Points,\n  PointsMaterial,\n  PropertyBinding,\n  Quaternion,\n  QuaternionKeyframeTrack,\n  RepeatWrapping,\n  Skeleton,\n  SkinnedMesh,\n  Sphere,\n  SpotLight,\n  Texture,\n  TextureLoader,\n  TriangleFanDrawMode,\n  TriangleStripDrawMode,\n  Vector2,\n  Vector3,\n  VectorKeyframeTrack,\n  InstancedBufferAttribute,\n} from 'three'\nimport { toTrianglesDrawMode } from '../utils/BufferGeometryUtils'\nimport { version } from '../_polyfill/constants'\nimport { decodeText } from '../_polyfill/LoaderUtils'\n\nconst SRGBColorSpace = 'srgb'\nconst LinearSRGBColorSpace = 'srgb-linear'\nconst sRGBEncoding = 3001\nconst LinearEncoding = 3000\n\nclass GLTFLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    this.dracoLoader = null\n    this.ktx2Loader = null\n    this.meshoptDecoder = null\n\n    this.pluginCallbacks = []\n\n    this.register(function (parser) {\n      return new GLTFMaterialsClearcoatExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsDispersionExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFTextureBasisUExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFTextureWebPExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFTextureAVIFExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsSheenExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsTransmissionExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsVolumeExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsIorExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsEmissiveStrengthExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsSpecularExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsIridescenceExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsAnisotropyExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsBumpExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFLightsExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMeshoptCompression(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMeshGpuInstancing(parser)\n    })\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    let resourcePath\n\n    if (this.resourcePath !== '') {\n      resourcePath = this.resourcePath\n    } else if (this.path !== '') {\n      // If a base path is set, resources will be relative paths from that plus the relative path of the gltf file\n      // Example  path = 'https://my-cnd-server.com/', url = 'assets/models/model.gltf'\n      // resourcePath = 'https://my-cnd-server.com/assets/models/'\n      // referenced resource 'model.bin' will be loaded from 'https://my-cnd-server.com/assets/models/model.bin'\n      // referenced resource '../textures/texture.png' will be loaded from 'https://my-cnd-server.com/assets/textures/texture.png'\n      const relativeUrl = LoaderUtils.extractUrlBase(url)\n      resourcePath = LoaderUtils.resolveURL(relativeUrl, this.path)\n    } else {\n      resourcePath = LoaderUtils.extractUrlBase(url)\n    }\n\n    // Tells the LoadingManager to track an extra item, which resolves after\n    // the model is fully loaded. This means the count of items loaded will\n    // be incorrect, but ensures manager.onLoad() does not fire early.\n    this.manager.itemStart(url)\n\n    const _onError = function (e) {\n      if (onError) {\n        onError(e)\n      } else {\n        console.error(e)\n      }\n\n      scope.manager.itemError(url)\n      scope.manager.itemEnd(url)\n    }\n\n    const loader = new FileLoader(this.manager)\n\n    loader.setPath(this.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(this.requestHeader)\n    loader.setWithCredentials(this.withCredentials)\n\n    loader.load(\n      url,\n      function (data) {\n        try {\n          scope.parse(\n            data,\n            resourcePath,\n            function (gltf) {\n              onLoad(gltf)\n\n              scope.manager.itemEnd(url)\n            },\n            _onError,\n          )\n        } catch (e) {\n          _onError(e)\n        }\n      },\n      onProgress,\n      _onError,\n    )\n  }\n\n  setDRACOLoader(dracoLoader) {\n    this.dracoLoader = dracoLoader\n    return this\n  }\n\n  setDDSLoader() {\n    throw new Error('THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".')\n  }\n\n  setKTX2Loader(ktx2Loader) {\n    this.ktx2Loader = ktx2Loader\n    return this\n  }\n\n  setMeshoptDecoder(meshoptDecoder) {\n    this.meshoptDecoder = meshoptDecoder\n    return this\n  }\n\n  register(callback) {\n    if (this.pluginCallbacks.indexOf(callback) === -1) {\n      this.pluginCallbacks.push(callback)\n    }\n\n    return this\n  }\n\n  unregister(callback) {\n    if (this.pluginCallbacks.indexOf(callback) !== -1) {\n      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1)\n    }\n\n    return this\n  }\n\n  parse(data, path, onLoad, onError) {\n    let json\n    const extensions = {}\n    const plugins = {}\n\n    if (typeof data === 'string') {\n      json = JSON.parse(data)\n    } else if (data instanceof ArrayBuffer) {\n      const magic = decodeText(new Uint8Array(data.slice(0, 4)))\n\n      if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n        try {\n          extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data)\n        } catch (error) {\n          if (onError) onError(error)\n          return\n        }\n\n        json = JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content)\n      } else {\n        json = JSON.parse(decodeText(new Uint8Array(data)))\n      }\n    } else {\n      json = data\n    }\n\n    if (json.asset === undefined || json.asset.version[0] < 2) {\n      if (onError) onError(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.'))\n      return\n    }\n\n    const parser = new GLTFParser(json, {\n      path: path || this.resourcePath || '',\n      crossOrigin: this.crossOrigin,\n      requestHeader: this.requestHeader,\n      manager: this.manager,\n      ktx2Loader: this.ktx2Loader,\n      meshoptDecoder: this.meshoptDecoder,\n    })\n\n    parser.fileLoader.setRequestHeader(this.requestHeader)\n\n    for (let i = 0; i < this.pluginCallbacks.length; i++) {\n      const plugin = this.pluginCallbacks[i](parser)\n\n      if (!plugin.name) console.error('THREE.GLTFLoader: Invalid plugin found: missing name')\n\n      plugins[plugin.name] = plugin\n\n      // Workaround to avoid determining as unknown extension\n      // in addUnknownExtensionsToUserData().\n      // Remove this workaround if we move all the existing\n      // extension handlers to plugin system\n      extensions[plugin.name] = true\n    }\n\n    if (json.extensionsUsed) {\n      for (let i = 0; i < json.extensionsUsed.length; ++i) {\n        const extensionName = json.extensionsUsed[i]\n        const extensionsRequired = json.extensionsRequired || []\n\n        switch (extensionName) {\n          case EXTENSIONS.KHR_MATERIALS_UNLIT:\n            extensions[extensionName] = new GLTFMaterialsUnlitExtension()\n            break\n\n          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader)\n            break\n\n          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n            extensions[extensionName] = new GLTFTextureTransformExtension()\n            break\n\n          case EXTENSIONS.KHR_MESH_QUANTIZATION:\n            extensions[extensionName] = new GLTFMeshQuantizationExtension()\n            break\n\n          default:\n            if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === undefined) {\n              console.warn('THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".')\n            }\n        }\n      }\n    }\n\n    parser.setExtensions(extensions)\n    parser.setPlugins(plugins)\n    parser.parse(onLoad, onError)\n  }\n\n  parseAsync(data, path) {\n    const scope = this\n\n    return new Promise(function (resolve, reject) {\n      scope.parse(data, path, resolve, reject)\n    })\n  }\n}\n\n/* GLTFREGISTRY */\n\nfunction GLTFRegistry() {\n  let objects = {}\n\n  return {\n    get: function (key) {\n      return objects[key]\n    },\n\n    add: function (key, object) {\n      objects[key] = object\n    },\n\n    remove: function (key) {\n      delete objects[key]\n    },\n\n    removeAll: function () {\n      objects = {}\n    },\n  }\n}\n\n/*********************************/\n/********** EXTENSIONS ***********/\n/*********************************/\n\nconst EXTENSIONS = {\n  KHR_BINARY_GLTF: 'KHR_binary_glTF',\n  KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\n  KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\n  KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',\n  KHR_MATERIALS_DISPERSION: 'KHR_materials_dispersion',\n  KHR_MATERIALS_IOR: 'KHR_materials_ior',\n  KHR_MATERIALS_SHEEN: 'KHR_materials_sheen',\n  KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',\n  KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',\n  KHR_MATERIALS_IRIDESCENCE: 'KHR_materials_iridescence',\n  KHR_MATERIALS_ANISOTROPY: 'KHR_materials_anisotropy',\n  KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\n  KHR_MATERIALS_VOLUME: 'KHR_materials_volume',\n  KHR_TEXTURE_BASISU: 'KHR_texture_basisu',\n  KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\n  KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',\n  KHR_MATERIALS_EMISSIVE_STRENGTH: 'KHR_materials_emissive_strength',\n  EXT_MATERIALS_BUMP: 'EXT_materials_bump',\n  EXT_TEXTURE_WEBP: 'EXT_texture_webp',\n  EXT_TEXTURE_AVIF: 'EXT_texture_avif',\n  EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression',\n  EXT_MESH_GPU_INSTANCING: 'EXT_mesh_gpu_instancing',\n}\n\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n */\nclass GLTFLightsExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL\n\n    // Object3D instance caches\n    this.cache = { refs: {}, uses: {} }\n  }\n\n  _markDefs() {\n    const parser = this.parser\n    const nodeDefs = this.parser.json.nodes || []\n\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex]\n\n      if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== undefined) {\n        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light)\n      }\n    }\n  }\n\n  _loadLight(lightIndex) {\n    const parser = this.parser\n    const cacheKey = 'light:' + lightIndex\n    let dependency = parser.cache.get(cacheKey)\n\n    if (dependency) return dependency\n\n    const json = parser.json\n    const extensions = (json.extensions && json.extensions[this.name]) || {}\n    const lightDefs = extensions.lights || []\n    const lightDef = lightDefs[lightIndex]\n    let lightNode\n\n    const color = new Color(0xffffff)\n\n    if (lightDef.color !== undefined)\n      color.setRGB(lightDef.color[0], lightDef.color[1], lightDef.color[2], LinearSRGBColorSpace)\n\n    const range = lightDef.range !== undefined ? lightDef.range : 0\n\n    switch (lightDef.type) {\n      case 'directional':\n        lightNode = new DirectionalLight(color)\n        lightNode.target.position.set(0, 0, -1)\n        lightNode.add(lightNode.target)\n        break\n\n      case 'point':\n        lightNode = new PointLight(color)\n        lightNode.distance = range\n        break\n\n      case 'spot':\n        lightNode = new SpotLight(color)\n        lightNode.distance = range\n        // Handle spotlight properties.\n        lightDef.spot = lightDef.spot || {}\n        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0\n        lightDef.spot.outerConeAngle =\n          lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0\n        lightNode.angle = lightDef.spot.outerConeAngle\n        lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle\n        lightNode.target.position.set(0, 0, -1)\n        lightNode.add(lightNode.target)\n        break\n\n      default:\n        throw new Error('THREE.GLTFLoader: Unexpected light type: ' + lightDef.type)\n    }\n\n    // Some lights (e.g. spot) default to a position other than the origin. Reset the position\n    // here, because node-level parsing will only override position if explicitly specified.\n    lightNode.position.set(0, 0, 0)\n\n    lightNode.decay = 2\n\n    assignExtrasToUserData(lightNode, lightDef)\n\n    if (lightDef.intensity !== undefined) lightNode.intensity = lightDef.intensity\n\n    lightNode.name = parser.createUniqueName(lightDef.name || 'light_' + lightIndex)\n\n    dependency = Promise.resolve(lightNode)\n\n    parser.cache.add(cacheKey, dependency)\n\n    return dependency\n  }\n\n  getDependency(type, index) {\n    if (type !== 'light') return\n\n    return this._loadLight(index)\n  }\n\n  createNodeAttachment(nodeIndex) {\n    const self = this\n    const parser = this.parser\n    const json = parser.json\n    const nodeDef = json.nodes[nodeIndex]\n    const lightDef = (nodeDef.extensions && nodeDef.extensions[this.name]) || {}\n    const lightIndex = lightDef.light\n\n    if (lightIndex === undefined) return null\n\n    return this._loadLight(lightIndex).then(function (light) {\n      return parser._getNodeRef(self.cache, lightIndex, light)\n    })\n  }\n}\n\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n */\nclass GLTFMaterialsUnlitExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT\n  }\n\n  getMaterialType() {\n    return MeshBasicMaterial\n  }\n\n  extendParams(materialParams, materialDef, parser) {\n    const pending = []\n\n    materialParams.color = new Color(1.0, 1.0, 1.0)\n    materialParams.opacity = 1.0\n\n    const metallicRoughness = materialDef.pbrMetallicRoughness\n\n    if (metallicRoughness) {\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor\n\n        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace)\n        materialParams.opacity = array[3]\n      }\n\n      if (metallicRoughness.baseColorTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace))\n      }\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials Emissive Strength Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md\n */\nclass GLTFMaterialsEmissiveStrengthExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const emissiveStrength = materialDef.extensions[this.name].emissiveStrength\n\n    if (emissiveStrength !== undefined) {\n      materialParams.emissiveIntensity = emissiveStrength\n    }\n\n    return Promise.resolve()\n  }\n}\n\n/**\n * Clearcoat Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n */\nclass GLTFMaterialsClearcoatExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    if (extension.clearcoatFactor !== undefined) {\n      materialParams.clearcoat = extension.clearcoatFactor\n    }\n\n    if (extension.clearcoatTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'clearcoatMap', extension.clearcoatTexture))\n    }\n\n    if (extension.clearcoatRoughnessFactor !== undefined) {\n      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor\n    }\n\n    if (extension.clearcoatRoughnessTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture))\n    }\n\n    if (extension.clearcoatNormalTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture))\n\n      if (extension.clearcoatNormalTexture.scale !== undefined) {\n        const scale = extension.clearcoatNormalTexture.scale\n\n        materialParams.clearcoatNormalScale = new Vector2(scale, scale)\n      }\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials dispersion Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_dispersion\n */\nclass GLTFMaterialsDispersionExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_DISPERSION\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const extension = materialDef.extensions[this.name]\n\n    materialParams.dispersion = extension.dispersion !== undefined ? extension.dispersion : 0\n\n    return Promise.resolve()\n  }\n}\n\n/**\n * Iridescence Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence\n */\nclass GLTFMaterialsIridescenceExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    if (extension.iridescenceFactor !== undefined) {\n      materialParams.iridescence = extension.iridescenceFactor\n    }\n\n    if (extension.iridescenceTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'iridescenceMap', extension.iridescenceTexture))\n    }\n\n    if (extension.iridescenceIor !== undefined) {\n      materialParams.iridescenceIOR = extension.iridescenceIor\n    }\n\n    if (materialParams.iridescenceThicknessRange === undefined) {\n      materialParams.iridescenceThicknessRange = [100, 400]\n    }\n\n    if (extension.iridescenceThicknessMinimum !== undefined) {\n      materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum\n    }\n\n    if (extension.iridescenceThicknessMaximum !== undefined) {\n      materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum\n    }\n\n    if (extension.iridescenceThicknessTexture !== undefined) {\n      pending.push(\n        parser.assignTexture(materialParams, 'iridescenceThicknessMap', extension.iridescenceThicknessTexture),\n      )\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Sheen Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen\n */\nclass GLTFMaterialsSheenExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_SHEEN\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    materialParams.sheenColor = new Color(0, 0, 0)\n    materialParams.sheenRoughness = 0\n    materialParams.sheen = 1\n\n    const extension = materialDef.extensions[this.name]\n\n    if (extension.sheenColorFactor !== undefined) {\n      const colorFactor = extension.sheenColorFactor\n      materialParams.sheenColor.setRGB(colorFactor[0], colorFactor[1], colorFactor[2], LinearSRGBColorSpace)\n    }\n\n    if (extension.sheenRoughnessFactor !== undefined) {\n      materialParams.sheenRoughness = extension.sheenRoughnessFactor\n    }\n\n    if (extension.sheenColorTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'sheenColorMap', extension.sheenColorTexture, SRGBColorSpace))\n    }\n\n    if (extension.sheenRoughnessTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'sheenRoughnessMap', extension.sheenRoughnessTexture))\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n * Draft: https://github.com/KhronosGroup/glTF/pull/1698\n */\nclass GLTFMaterialsTransmissionExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    if (extension.transmissionFactor !== undefined) {\n      materialParams.transmission = extension.transmissionFactor\n    }\n\n    if (extension.transmissionTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'transmissionMap', extension.transmissionTexture))\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n */\nclass GLTFMaterialsVolumeExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_VOLUME\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    materialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0\n\n    if (extension.thicknessTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'thicknessMap', extension.thicknessTexture))\n    }\n\n    materialParams.attenuationDistance = extension.attenuationDistance || Infinity\n\n    const colorArray = extension.attenuationColor || [1, 1, 1]\n    materialParams.attenuationColor = new Color().setRGB(\n      colorArray[0],\n      colorArray[1],\n      colorArray[2],\n      LinearSRGBColorSpace,\n    )\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials ior Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior\n */\nclass GLTFMaterialsIorExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_IOR\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const extension = materialDef.extensions[this.name]\n\n    materialParams.ior = extension.ior !== undefined ? extension.ior : 1.5\n\n    return Promise.resolve()\n  }\n}\n\n/**\n * Materials specular Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular\n */\nclass GLTFMaterialsSpecularExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    materialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0\n\n    if (extension.specularTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'specularIntensityMap', extension.specularTexture))\n    }\n\n    const colorArray = extension.specularColorFactor || [1, 1, 1]\n    materialParams.specularColor = new Color().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace)\n\n    if (extension.specularColorTexture !== undefined) {\n      pending.push(\n        parser.assignTexture(materialParams, 'specularColorMap', extension.specularColorTexture, SRGBColorSpace),\n      )\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials bump Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/EXT_materials_bump\n */\nclass GLTFMaterialsBumpExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.EXT_MATERIALS_BUMP\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    materialParams.bumpScale = extension.bumpFactor !== undefined ? extension.bumpFactor : 1.0\n\n    if (extension.bumpTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'bumpMap', extension.bumpTexture))\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials anisotropy Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_anisotropy\n */\nclass GLTFMaterialsAnisotropyExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    if (extension.anisotropyStrength !== undefined) {\n      materialParams.anisotropy = extension.anisotropyStrength\n    }\n\n    if (extension.anisotropyRotation !== undefined) {\n      materialParams.anisotropyRotation = extension.anisotropyRotation\n    }\n\n    if (extension.anisotropyTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'anisotropyMap', extension.anisotropyTexture))\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * BasisU Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu\n */\nclass GLTFTextureBasisUExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_TEXTURE_BASISU\n  }\n\n  loadTexture(textureIndex) {\n    const parser = this.parser\n    const json = parser.json\n\n    const textureDef = json.textures[textureIndex]\n\n    if (!textureDef.extensions || !textureDef.extensions[this.name]) {\n      return null\n    }\n\n    const extension = textureDef.extensions[this.name]\n    const loader = parser.options.ktx2Loader\n\n    if (!loader) {\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n        throw new Error('THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures')\n      } else {\n        // Assumes that the extension is optional and that a fallback texture is present\n        return null\n      }\n    }\n\n    return parser.loadTextureImage(textureIndex, extension.source, loader)\n  }\n}\n\n/**\n * WebP Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp\n */\nclass GLTFTextureWebPExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.EXT_TEXTURE_WEBP\n    this.isSupported = null\n  }\n\n  loadTexture(textureIndex) {\n    const name = this.name\n    const parser = this.parser\n    const json = parser.json\n\n    const textureDef = json.textures[textureIndex]\n\n    if (!textureDef.extensions || !textureDef.extensions[name]) {\n      return null\n    }\n\n    const extension = textureDef.extensions[name]\n    const source = json.images[extension.source]\n\n    let loader = parser.textureLoader\n    if (source.uri) {\n      const handler = parser.options.manager.getHandler(source.uri)\n      if (handler !== null) loader = handler\n    }\n\n    return this.detectSupport().then(function (isSupported) {\n      if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader)\n\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n        throw new Error('THREE.GLTFLoader: WebP required by asset but unsupported.')\n      }\n\n      // Fall back to PNG or JPEG.\n      return parser.loadTexture(textureIndex)\n    })\n  }\n\n  detectSupport() {\n    if (!this.isSupported) {\n      this.isSupported = new Promise(function (resolve) {\n        const image = new Image()\n\n        // Lossy test image. Support for lossy images doesn't guarantee support for all\n        // WebP images, unfortunately.\n        image.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA'\n\n        image.onload = image.onerror = function () {\n          resolve(image.height === 1)\n        }\n      })\n    }\n\n    return this.isSupported\n  }\n}\n\n/**\n * AVIF Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_avif\n */\nclass GLTFTextureAVIFExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.EXT_TEXTURE_AVIF\n    this.isSupported = null\n  }\n\n  loadTexture(textureIndex) {\n    const name = this.name\n    const parser = this.parser\n    const json = parser.json\n\n    const textureDef = json.textures[textureIndex]\n\n    if (!textureDef.extensions || !textureDef.extensions[name]) {\n      return null\n    }\n\n    const extension = textureDef.extensions[name]\n    const source = json.images[extension.source]\n\n    let loader = parser.textureLoader\n    if (source.uri) {\n      const handler = parser.options.manager.getHandler(source.uri)\n      if (handler !== null) loader = handler\n    }\n\n    return this.detectSupport().then(function (isSupported) {\n      if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader)\n\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n        throw new Error('THREE.GLTFLoader: AVIF required by asset but unsupported.')\n      }\n\n      // Fall back to PNG or JPEG.\n      return parser.loadTexture(textureIndex)\n    })\n  }\n\n  detectSupport() {\n    if (!this.isSupported) {\n      this.isSupported = new Promise(function (resolve) {\n        const image = new Image()\n\n        // Lossy test image.\n        image.src =\n          'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI='\n        image.onload = image.onerror = function () {\n          resolve(image.height === 1)\n        }\n      })\n    }\n\n    return this.isSupported\n  }\n}\n\n/**\n * meshopt BufferView Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression\n */\nclass GLTFMeshoptCompression {\n  constructor(parser) {\n    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION\n    this.parser = parser\n  }\n\n  loadBufferView(index) {\n    const json = this.parser.json\n    const bufferView = json.bufferViews[index]\n\n    if (bufferView.extensions && bufferView.extensions[this.name]) {\n      const extensionDef = bufferView.extensions[this.name]\n\n      const buffer = this.parser.getDependency('buffer', extensionDef.buffer)\n      const decoder = this.parser.options.meshoptDecoder\n\n      if (!decoder || !decoder.supported) {\n        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n          throw new Error('THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files')\n        } else {\n          // Assumes that the extension is optional and that fallback buffer data is present\n          return null\n        }\n      }\n\n      return buffer.then(function (res) {\n        const byteOffset = extensionDef.byteOffset || 0\n        const byteLength = extensionDef.byteLength || 0\n\n        const count = extensionDef.count\n        const stride = extensionDef.byteStride\n\n        const source = new Uint8Array(res, byteOffset, byteLength)\n\n        if (decoder.decodeGltfBufferAsync) {\n          return decoder\n            .decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter)\n            .then(function (res) {\n              return res.buffer\n            })\n        } else {\n          // Support for MeshoptDecoder 0.18 or earlier, without decodeGltfBufferAsync\n          return decoder.ready.then(function () {\n            const result = new ArrayBuffer(count * stride)\n            decoder.decodeGltfBuffer(\n              new Uint8Array(result),\n              count,\n              stride,\n              source,\n              extensionDef.mode,\n              extensionDef.filter,\n            )\n            return result\n          })\n        }\n      })\n    } else {\n      return null\n    }\n  }\n}\n\n/**\n * GPU Instancing Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing\n *\n */\nclass GLTFMeshGpuInstancing {\n  constructor(parser) {\n    this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING\n    this.parser = parser\n  }\n\n  createNodeMesh(nodeIndex) {\n    const json = this.parser.json\n    const nodeDef = json.nodes[nodeIndex]\n\n    if (!nodeDef.extensions || !nodeDef.extensions[this.name] || nodeDef.mesh === undefined) {\n      return null\n    }\n\n    const meshDef = json.meshes[nodeDef.mesh]\n\n    // No Points or Lines + Instancing support yet\n\n    for (const primitive of meshDef.primitives) {\n      if (\n        primitive.mode !== WEBGL_CONSTANTS.TRIANGLES &&\n        primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP &&\n        primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN &&\n        primitive.mode !== undefined\n      ) {\n        return null\n      }\n    }\n\n    const extensionDef = nodeDef.extensions[this.name]\n    const attributesDef = extensionDef.attributes\n\n    // @TODO: Can we support InstancedMesh + SkinnedMesh?\n\n    const pending = []\n    const attributes = {}\n\n    for (const key in attributesDef) {\n      pending.push(\n        this.parser.getDependency('accessor', attributesDef[key]).then((accessor) => {\n          attributes[key] = accessor\n          return attributes[key]\n        }),\n      )\n    }\n\n    if (pending.length < 1) {\n      return null\n    }\n\n    pending.push(this.parser.createNodeMesh(nodeIndex))\n\n    return Promise.all(pending).then((results) => {\n      const nodeObject = results.pop()\n      const meshes = nodeObject.isGroup ? nodeObject.children : [nodeObject]\n      const count = results[0].count // All attribute counts should be same\n      const instancedMeshes = []\n\n      for (const mesh of meshes) {\n        // Temporal variables\n        const m = new Matrix4()\n        const p = new Vector3()\n        const q = new Quaternion()\n        const s = new Vector3(1, 1, 1)\n\n        const instancedMesh = new InstancedMesh(mesh.geometry, mesh.material, count)\n\n        for (let i = 0; i < count; i++) {\n          if (attributes.TRANSLATION) {\n            p.fromBufferAttribute(attributes.TRANSLATION, i)\n          }\n\n          if (attributes.ROTATION) {\n            q.fromBufferAttribute(attributes.ROTATION, i)\n          }\n\n          if (attributes.SCALE) {\n            s.fromBufferAttribute(attributes.SCALE, i)\n          }\n\n          instancedMesh.setMatrixAt(i, m.compose(p, q, s))\n        }\n\n        // Add instance attributes to the geometry, excluding TRS.\n        for (const attributeName in attributes) {\n          if (attributeName === '_COLOR_0') {\n            const attr = attributes[attributeName]\n            instancedMesh.instanceColor = new InstancedBufferAttribute(attr.array, attr.itemSize, attr.normalized)\n          } else if (attributeName !== 'TRANSLATION' && attributeName !== 'ROTATION' && attributeName !== 'SCALE') {\n            mesh.geometry.setAttribute(attributeName, attributes[attributeName])\n          }\n        }\n\n        // Just in case\n        Object3D.prototype.copy.call(instancedMesh, mesh)\n\n        this.parser.assignFinalMaterial(instancedMesh)\n\n        instancedMeshes.push(instancedMesh)\n      }\n\n      if (nodeObject.isGroup) {\n        nodeObject.clear()\n\n        nodeObject.add(...instancedMeshes)\n\n        return nodeObject\n      }\n\n      return instancedMeshes[0]\n    })\n  }\n}\n\n/* BINARY EXTENSION */\nconst BINARY_EXTENSION_HEADER_MAGIC = 'glTF'\nconst BINARY_EXTENSION_HEADER_LENGTH = 12\nconst BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4e4f534a, BIN: 0x004e4942 }\n\nclass GLTFBinaryExtension {\n  constructor(data) {\n    this.name = EXTENSIONS.KHR_BINARY_GLTF\n    this.content = null\n    this.body = null\n\n    const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH)\n\n    this.header = {\n      magic: decodeText(new Uint8Array(data.slice(0, 4))),\n      version: headerView.getUint32(4, true),\n      length: headerView.getUint32(8, true),\n    }\n\n    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\n      throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.')\n    } else if (this.header.version < 2.0) {\n      throw new Error('THREE.GLTFLoader: Legacy binary file detected.')\n    }\n\n    const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH\n    const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH)\n    let chunkIndex = 0\n\n    while (chunkIndex < chunkContentsLength) {\n      const chunkLength = chunkView.getUint32(chunkIndex, true)\n      chunkIndex += 4\n\n      const chunkType = chunkView.getUint32(chunkIndex, true)\n      chunkIndex += 4\n\n      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n        const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength)\n        this.content = decodeText(contentArray)\n      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n        const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex\n        this.body = data.slice(byteOffset, byteOffset + chunkLength)\n      }\n\n      // Clients must ignore chunks with unknown types.\n\n      chunkIndex += chunkLength\n    }\n\n    if (this.content === null) {\n      throw new Error('THREE.GLTFLoader: JSON content not found.')\n    }\n  }\n}\n\n/**\n * DRACO Mesh Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n */\nclass GLTFDracoMeshCompressionExtension {\n  constructor(json, dracoLoader) {\n    if (!dracoLoader) {\n      throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.')\n    }\n\n    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION\n    this.json = json\n    this.dracoLoader = dracoLoader\n    this.dracoLoader.preload()\n  }\n\n  decodePrimitive(primitive, parser) {\n    const json = this.json\n    const dracoLoader = this.dracoLoader\n    const bufferViewIndex = primitive.extensions[this.name].bufferView\n    const gltfAttributeMap = primitive.extensions[this.name].attributes\n    const threeAttributeMap = {}\n    const attributeNormalizedMap = {}\n    const attributeTypeMap = {}\n\n    for (const attributeName in gltfAttributeMap) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase()\n\n      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName]\n    }\n\n    for (const attributeName in primitive.attributes) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase()\n\n      if (gltfAttributeMap[attributeName] !== undefined) {\n        const accessorDef = json.accessors[primitive.attributes[attributeName]]\n        const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType]\n\n        attributeTypeMap[threeAttributeName] = componentType.name\n        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true\n      }\n    }\n\n    return parser.getDependency('bufferView', bufferViewIndex).then(function (bufferView) {\n      return new Promise(function (resolve, reject) {\n        dracoLoader.decodeDracoFile(\n          bufferView,\n          function (geometry) {\n            for (const attributeName in geometry.attributes) {\n              const attribute = geometry.attributes[attributeName]\n              const normalized = attributeNormalizedMap[attributeName]\n\n              if (normalized !== undefined) attribute.normalized = normalized\n            }\n\n            resolve(geometry)\n          },\n          threeAttributeMap,\n          attributeTypeMap,\n          LinearSRGBColorSpace,\n          reject,\n        )\n      })\n    })\n  }\n}\n\n/**\n * Texture Transform Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform\n */\nclass GLTFTextureTransformExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM\n  }\n\n  extendTexture(texture, transform) {\n    if (\n      (transform.texCoord === undefined || transform.texCoord === texture.channel) &&\n      transform.offset === undefined &&\n      transform.rotation === undefined &&\n      transform.scale === undefined\n    ) {\n      // See https://github.com/mrdoob/three.js/issues/21819.\n      return texture\n    }\n\n    texture = texture.clone()\n\n    if (transform.texCoord !== undefined) {\n      texture.channel = transform.texCoord\n    }\n\n    if (transform.offset !== undefined) {\n      texture.offset.fromArray(transform.offset)\n    }\n\n    if (transform.rotation !== undefined) {\n      texture.rotation = transform.rotation\n    }\n\n    if (transform.scale !== undefined) {\n      texture.repeat.fromArray(transform.scale)\n    }\n\n    texture.needsUpdate = true\n\n    return texture\n  }\n}\n\n/**\n * Mesh Quantization Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\n */\nclass GLTFMeshQuantizationExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION\n  }\n}\n\n/*********************************/\n/********** INTERPOLATION ********/\n/*********************************/\n\n// Spline Interpolation\n// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\nclass GLTFCubicSplineInterpolant extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer)\n  }\n\n  copySampleValue_(index) {\n    // Copies a sample value to the result buffer. See description of glTF\n    // CUBICSPLINE values layout in interpolate_() function below.\n\n    const result = this.resultBuffer,\n      values = this.sampleValues,\n      valueSize = this.valueSize,\n      offset = index * valueSize * 3 + valueSize\n\n    for (let i = 0; i !== valueSize; i++) {\n      result[i] = values[offset + i]\n    }\n\n    return result\n  }\n\n  interpolate_(i1, t0, t, t1) {\n    const result = this.resultBuffer\n    const values = this.sampleValues\n    const stride = this.valueSize\n\n    const stride2 = stride * 2\n    const stride3 = stride * 3\n\n    const td = t1 - t0\n\n    const p = (t - t0) / td\n    const pp = p * p\n    const ppp = pp * p\n\n    const offset1 = i1 * stride3\n    const offset0 = offset1 - stride3\n\n    const s2 = -2 * ppp + 3 * pp\n    const s3 = ppp - pp\n    const s0 = 1 - s2\n    const s1 = s3 - pp + p\n\n    // Layout of keyframe output values for CUBICSPLINE animations:\n    //   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\n    for (let i = 0; i !== stride; i++) {\n      const p0 = values[offset0 + i + stride] // splineVertex_k\n      const m0 = values[offset0 + i + stride2] * td // outTangent_k * (t_k+1 - t_k)\n      const p1 = values[offset1 + i + stride] // splineVertex_k+1\n      const m1 = values[offset1 + i] * td // inTangent_k+1 * (t_k+1 - t_k)\n\n      result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1\n    }\n\n    return result\n  }\n}\n\nconst _q = /* @__PURE__ */ new Quaternion()\n\nclass GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {\n  interpolate_(i1, t0, t, t1) {\n    const result = super.interpolate_(i1, t0, t, t1)\n\n    _q.fromArray(result).normalize().toArray(result)\n\n    return result\n  }\n}\n\n/*********************************/\n/********** INTERNALS ************/\n/*********************************/\n\n/* CONSTANTS */\n\nconst WEBGL_CONSTANTS = {\n  FLOAT: 5126,\n  //FLOAT_MAT2: 35674,\n  FLOAT_MAT3: 35675,\n  FLOAT_MAT4: 35676,\n  FLOAT_VEC2: 35664,\n  FLOAT_VEC3: 35665,\n  FLOAT_VEC4: 35666,\n  LINEAR: 9729,\n  REPEAT: 10497,\n  SAMPLER_2D: 35678,\n  POINTS: 0,\n  LINES: 1,\n  LINE_LOOP: 2,\n  LINE_STRIP: 3,\n  TRIANGLES: 4,\n  TRIANGLE_STRIP: 5,\n  TRIANGLE_FAN: 6,\n  UNSIGNED_BYTE: 5121,\n  UNSIGNED_SHORT: 5123,\n}\n\nconst WEBGL_COMPONENT_TYPES = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array,\n}\n\nconst WEBGL_FILTERS = {\n  9728: NearestFilter,\n  9729: LinearFilter,\n  9984: NearestMipmapNearestFilter,\n  9985: LinearMipmapNearestFilter,\n  9986: NearestMipmapLinearFilter,\n  9987: LinearMipmapLinearFilter,\n}\n\nconst WEBGL_WRAPPINGS = {\n  33071: ClampToEdgeWrapping,\n  33648: MirroredRepeatWrapping,\n  10497: RepeatWrapping,\n}\n\nconst WEBGL_TYPE_SIZES = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16,\n}\n\nconst ATTRIBUTES = {\n  POSITION: 'position',\n  NORMAL: 'normal',\n  TANGENT: 'tangent',\n  // uv => uv1, 4 uv channels\n  // https://github.com/mrdoob/three.js/pull/25943\n  // https://github.com/mrdoob/three.js/pull/25788\n  ...(version >= 152\n    ? {\n        TEXCOORD_0: 'uv',\n        TEXCOORD_1: 'uv1',\n        TEXCOORD_2: 'uv2',\n        TEXCOORD_3: 'uv3',\n      }\n    : {\n        TEXCOORD_0: 'uv',\n        TEXCOORD_1: 'uv2',\n      }),\n\n  COLOR_0: 'color',\n  WEIGHTS_0: 'skinWeight',\n  JOINTS_0: 'skinIndex',\n}\n\nconst PATH_PROPERTIES = {\n  scale: 'scale',\n  translation: 'position',\n  rotation: 'quaternion',\n  weights: 'morphTargetInfluences',\n}\n\nconst INTERPOLATION = {\n  CUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n  // keyframe track will be initialized with a default interpolation type, then modified.\n  LINEAR: InterpolateLinear,\n  STEP: InterpolateDiscrete,\n}\n\nconst ALPHA_MODES = {\n  OPAQUE: 'OPAQUE',\n  MASK: 'MASK',\n  BLEND: 'BLEND',\n}\n\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\n */\nfunction createDefaultMaterial(cache) {\n  if (cache['DefaultMaterial'] === undefined) {\n    cache['DefaultMaterial'] = new MeshStandardMaterial({\n      color: 0xffffff,\n      emissive: 0x000000,\n      metalness: 1,\n      roughness: 1,\n      transparent: false,\n      depthTest: true,\n      side: FrontSide,\n    })\n  }\n\n  return cache['DefaultMaterial']\n}\n\nfunction addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {\n  // Add unknown glTF extensions to an object's userData.\n\n  for (const name in objectDef.extensions) {\n    if (knownExtensions[name] === undefined) {\n      object.userData.gltfExtensions = object.userData.gltfExtensions || {}\n      object.userData.gltfExtensions[name] = objectDef.extensions[name]\n    }\n  }\n}\n\n/**\n * @param {Object3D|Material|BufferGeometry} object\n * @param {GLTF.definition} gltfDef\n */\nfunction assignExtrasToUserData(object, gltfDef) {\n  if (gltfDef.extras !== undefined) {\n    if (typeof gltfDef.extras === 'object') {\n      Object.assign(object.userData, gltfDef.extras)\n    } else {\n      console.warn('THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras)\n    }\n  }\n}\n\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\n *\n * @param {BufferGeometry} geometry\n * @param {Array<GLTF.Target>} targets\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\nfunction addMorphTargets(geometry, targets, parser) {\n  let hasMorphPosition = false\n  let hasMorphNormal = false\n  let hasMorphColor = false\n\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i]\n\n    if (target.POSITION !== undefined) hasMorphPosition = true\n    if (target.NORMAL !== undefined) hasMorphNormal = true\n    if (target.COLOR_0 !== undefined) hasMorphColor = true\n\n    if (hasMorphPosition && hasMorphNormal && hasMorphColor) break\n  }\n\n  if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor) return Promise.resolve(geometry)\n\n  const pendingPositionAccessors = []\n  const pendingNormalAccessors = []\n  const pendingColorAccessors = []\n\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i]\n\n    if (hasMorphPosition) {\n      const pendingAccessor =\n        target.POSITION !== undefined ? parser.getDependency('accessor', target.POSITION) : geometry.attributes.position\n\n      pendingPositionAccessors.push(pendingAccessor)\n    }\n\n    if (hasMorphNormal) {\n      const pendingAccessor =\n        target.NORMAL !== undefined ? parser.getDependency('accessor', target.NORMAL) : geometry.attributes.normal\n\n      pendingNormalAccessors.push(pendingAccessor)\n    }\n\n    if (hasMorphColor) {\n      const pendingAccessor =\n        target.COLOR_0 !== undefined ? parser.getDependency('accessor', target.COLOR_0) : geometry.attributes.color\n\n      pendingColorAccessors.push(pendingAccessor)\n    }\n  }\n\n  return Promise.all([\n    Promise.all(pendingPositionAccessors),\n    Promise.all(pendingNormalAccessors),\n    Promise.all(pendingColorAccessors),\n  ]).then(function (accessors) {\n    const morphPositions = accessors[0]\n    const morphNormals = accessors[1]\n    const morphColors = accessors[2]\n\n    if (hasMorphPosition) geometry.morphAttributes.position = morphPositions\n    if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals\n    if (hasMorphColor) geometry.morphAttributes.color = morphColors\n    geometry.morphTargetsRelative = true\n\n    return geometry\n  })\n}\n\n/**\n * @param {Mesh} mesh\n * @param {GLTF.Mesh} meshDef\n */\nfunction updateMorphTargets(mesh, meshDef) {\n  mesh.updateMorphTargets()\n\n  if (meshDef.weights !== undefined) {\n    for (let i = 0, il = meshDef.weights.length; i < il; i++) {\n      mesh.morphTargetInfluences[i] = meshDef.weights[i]\n    }\n  }\n\n  // .extras has user-defined data, so check that .extras.targetNames is an array.\n  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\n    const targetNames = meshDef.extras.targetNames\n\n    if (mesh.morphTargetInfluences.length === targetNames.length) {\n      mesh.morphTargetDictionary = {}\n\n      for (let i = 0, il = targetNames.length; i < il; i++) {\n        mesh.morphTargetDictionary[targetNames[i]] = i\n      }\n    } else {\n      console.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.')\n    }\n  }\n}\n\nfunction createPrimitiveKey(primitiveDef) {\n  let geometryKey\n\n  const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]\n\n  if (dracoExtension) {\n    geometryKey =\n      'draco:' +\n      dracoExtension.bufferView +\n      ':' +\n      dracoExtension.indices +\n      ':' +\n      createAttributesKey(dracoExtension.attributes)\n  } else {\n    geometryKey = primitiveDef.indices + ':' + createAttributesKey(primitiveDef.attributes) + ':' + primitiveDef.mode\n  }\n\n  if (primitiveDef.targets !== undefined) {\n    for (let i = 0, il = primitiveDef.targets.length; i < il; i++) {\n      geometryKey += ':' + createAttributesKey(primitiveDef.targets[i])\n    }\n  }\n\n  return geometryKey\n}\n\nfunction createAttributesKey(attributes) {\n  let attributesKey = ''\n\n  const keys = Object.keys(attributes).sort()\n\n  for (let i = 0, il = keys.length; i < il; i++) {\n    attributesKey += keys[i] + ':' + attributes[keys[i]] + ';'\n  }\n\n  return attributesKey\n}\n\nfunction getNormalizedComponentScale(constructor) {\n  // Reference:\n  // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data\n\n  switch (constructor) {\n    case Int8Array:\n      return 1 / 127\n\n    case Uint8Array:\n      return 1 / 255\n\n    case Int16Array:\n      return 1 / 32767\n\n    case Uint16Array:\n      return 1 / 65535\n\n    default:\n      throw new Error('THREE.GLTFLoader: Unsupported normalized accessor component type.')\n  }\n}\n\nfunction getImageURIMimeType(uri) {\n  if (uri.search(/\\.jpe?g($|\\?)/i) > 0 || uri.search(/^data\\:image\\/jpeg/) === 0) return 'image/jpeg'\n  if (uri.search(/\\.webp($|\\?)/i) > 0 || uri.search(/^data\\:image\\/webp/) === 0) return 'image/webp'\n\n  return 'image/png'\n}\n\nconst _identityMatrix = /* @__PURE__ */ new Matrix4()\n\n/* GLTF PARSER */\n\nclass GLTFParser {\n  constructor(json = {}, options = {}) {\n    this.json = json\n    this.extensions = {}\n    this.plugins = {}\n    this.options = options\n\n    // loader object cache\n    this.cache = new GLTFRegistry()\n\n    // associations between Three.js objects and glTF elements\n    this.associations = new Map()\n\n    // BufferGeometry caching\n    this.primitiveCache = {}\n\n    // Node cache\n    this.nodeCache = {}\n\n    // Object3D instance caches\n    this.meshCache = { refs: {}, uses: {} }\n    this.cameraCache = { refs: {}, uses: {} }\n    this.lightCache = { refs: {}, uses: {} }\n\n    this.sourceCache = {}\n    this.textureCache = {}\n\n    // Track node names, to ensure no duplicates\n    this.nodeNamesUsed = {}\n\n    // Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the\n    // expensive work of uploading a texture to the GPU off the main thread.\n\n    let isSafari = false\n    let isFirefox = false\n    let firefoxVersion = -1\n\n    if (typeof navigator !== 'undefined' && typeof navigator.userAgent !== 'undefined') {\n      isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === true\n      isFirefox = navigator.userAgent.indexOf('Firefox') > -1\n      firefoxVersion = isFirefox ? navigator.userAgent.match(/Firefox\\/([0-9]+)\\./)[1] : -1\n    }\n\n    if (typeof createImageBitmap === 'undefined' || isSafari || (isFirefox && firefoxVersion < 98)) {\n      this.textureLoader = new TextureLoader(this.options.manager)\n    } else {\n      this.textureLoader = new ImageBitmapLoader(this.options.manager)\n    }\n\n    this.textureLoader.setCrossOrigin(this.options.crossOrigin)\n    this.textureLoader.setRequestHeader(this.options.requestHeader)\n\n    this.fileLoader = new FileLoader(this.options.manager)\n    this.fileLoader.setResponseType('arraybuffer')\n\n    if (this.options.crossOrigin === 'use-credentials') {\n      this.fileLoader.setWithCredentials(true)\n    }\n  }\n\n  setExtensions(extensions) {\n    this.extensions = extensions\n  }\n\n  setPlugins(plugins) {\n    this.plugins = plugins\n  }\n\n  parse(onLoad, onError) {\n    const parser = this\n    const json = this.json\n    const extensions = this.extensions\n\n    // Clear the loader cache\n    this.cache.removeAll()\n    this.nodeCache = {}\n\n    // Mark the special nodes/meshes in json for efficient parse\n    this._invokeAll(function (ext) {\n      return ext._markDefs && ext._markDefs()\n    })\n\n    Promise.all(\n      this._invokeAll(function (ext) {\n        return ext.beforeRoot && ext.beforeRoot()\n      }),\n    )\n      .then(function () {\n        return Promise.all([\n          parser.getDependencies('scene'),\n          parser.getDependencies('animation'),\n          parser.getDependencies('camera'),\n        ])\n      })\n      .then(function (dependencies) {\n        const result = {\n          scene: dependencies[0][json.scene || 0],\n          scenes: dependencies[0],\n          animations: dependencies[1],\n          cameras: dependencies[2],\n          asset: json.asset,\n          parser: parser,\n          userData: {},\n        }\n\n        addUnknownExtensionsToUserData(extensions, result, json)\n\n        assignExtrasToUserData(result, json)\n\n        return Promise.all(\n          parser._invokeAll(function (ext) {\n            return ext.afterRoot && ext.afterRoot(result)\n          }),\n        ).then(function () {\n          for (const scene of result.scenes) {\n            scene.updateMatrixWorld()\n          }\n\n          onLoad(result)\n        })\n      })\n      .catch(onError)\n  }\n\n  /**\n   * Marks the special nodes/meshes in json for efficient parse.\n   */\n  _markDefs() {\n    const nodeDefs = this.json.nodes || []\n    const skinDefs = this.json.skins || []\n    const meshDefs = this.json.meshes || []\n\n    // Nothing in the node definition indicates whether it is a Bone or an\n    // Object3D. Use the skins' joint references to mark bones.\n    for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {\n      const joints = skinDefs[skinIndex].joints\n\n      for (let i = 0, il = joints.length; i < il; i++) {\n        nodeDefs[joints[i]].isBone = true\n      }\n    }\n\n    // Iterate over all nodes, marking references to shared resources,\n    // as well as skeleton joints.\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex]\n\n      if (nodeDef.mesh !== undefined) {\n        this._addNodeRef(this.meshCache, nodeDef.mesh)\n\n        // Nothing in the mesh definition indicates whether it is\n        // a SkinnedMesh or Mesh. Use the node's mesh reference\n        // to mark SkinnedMesh if node has skin.\n        if (nodeDef.skin !== undefined) {\n          meshDefs[nodeDef.mesh].isSkinnedMesh = true\n        }\n      }\n\n      if (nodeDef.camera !== undefined) {\n        this._addNodeRef(this.cameraCache, nodeDef.camera)\n      }\n    }\n  }\n\n  /**\n   * Counts references to shared node / Object3D resources. These resources\n   * can be reused, or \"instantiated\", at multiple nodes in the scene\n   * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n   * be marked. Non-scenegraph resources (like Materials, Geometries, and\n   * Textures) can be reused directly and are not marked here.\n   *\n   * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n   */\n  _addNodeRef(cache, index) {\n    if (index === undefined) return\n\n    if (cache.refs[index] === undefined) {\n      cache.refs[index] = cache.uses[index] = 0\n    }\n\n    cache.refs[index]++\n  }\n\n  /** Returns a reference to a shared resource, cloning it if necessary. */\n  _getNodeRef(cache, index, object) {\n    if (cache.refs[index] <= 1) return object\n\n    const ref = object.clone()\n\n    // Propagates mappings to the cloned object, prevents mappings on the\n    // original object from being lost.\n    const updateMappings = (original, clone) => {\n      const mappings = this.associations.get(original)\n      if (mappings != null) {\n        this.associations.set(clone, mappings)\n      }\n\n      for (const [i, child] of original.children.entries()) {\n        updateMappings(child, clone.children[i])\n      }\n    }\n\n    updateMappings(object, ref)\n\n    ref.name += '_instance_' + cache.uses[index]++\n\n    return ref\n  }\n\n  _invokeOne(func) {\n    const extensions = Object.values(this.plugins)\n    extensions.push(this)\n\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i])\n\n      if (result) return result\n    }\n\n    return null\n  }\n\n  _invokeAll(func) {\n    const extensions = Object.values(this.plugins)\n    extensions.unshift(this)\n\n    const pending = []\n\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i])\n\n      if (result) pending.push(result)\n    }\n\n    return pending\n  }\n\n  /**\n   * Requests the specified dependency asynchronously, with caching.\n   * @param {string} type\n   * @param {number} index\n   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n   */\n  getDependency(type, index) {\n    const cacheKey = type + ':' + index\n    let dependency = this.cache.get(cacheKey)\n\n    if (!dependency) {\n      switch (type) {\n        case 'scene':\n          dependency = this.loadScene(index)\n          break\n\n        case 'node':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadNode && ext.loadNode(index)\n          })\n          break\n\n        case 'mesh':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadMesh && ext.loadMesh(index)\n          })\n          break\n\n        case 'accessor':\n          dependency = this.loadAccessor(index)\n          break\n\n        case 'bufferView':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadBufferView && ext.loadBufferView(index)\n          })\n          break\n\n        case 'buffer':\n          dependency = this.loadBuffer(index)\n          break\n\n        case 'material':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadMaterial && ext.loadMaterial(index)\n          })\n          break\n\n        case 'texture':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadTexture && ext.loadTexture(index)\n          })\n          break\n\n        case 'skin':\n          dependency = this.loadSkin(index)\n          break\n\n        case 'animation':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadAnimation && ext.loadAnimation(index)\n          })\n          break\n\n        case 'camera':\n          dependency = this.loadCamera(index)\n          break\n\n        default:\n          dependency = this._invokeOne(function (ext) {\n            return ext != this && ext.getDependency && ext.getDependency(type, index)\n          })\n\n          if (!dependency) {\n            throw new Error('Unknown type: ' + type)\n          }\n\n          break\n      }\n\n      this.cache.add(cacheKey, dependency)\n    }\n\n    return dependency\n  }\n\n  /**\n   * Requests all dependencies of the specified type asynchronously, with caching.\n   * @param {string} type\n   * @return {Promise<Array<Object>>}\n   */\n  getDependencies(type) {\n    let dependencies = this.cache.get(type)\n\n    if (!dependencies) {\n      const parser = this\n      const defs = this.json[type + (type === 'mesh' ? 'es' : 's')] || []\n\n      dependencies = Promise.all(\n        defs.map(function (def, index) {\n          return parser.getDependency(type, index)\n        }),\n      )\n\n      this.cache.add(type, dependencies)\n    }\n\n    return dependencies\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n  loadBuffer(bufferIndex) {\n    const bufferDef = this.json.buffers[bufferIndex]\n    const loader = this.fileLoader\n\n    if (bufferDef.type && bufferDef.type !== 'arraybuffer') {\n      throw new Error('THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.')\n    }\n\n    // If present, GLB container is required to be the first buffer.\n    if (bufferDef.uri === undefined && bufferIndex === 0) {\n      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body)\n    }\n\n    const options = this.options\n\n    return new Promise(function (resolve, reject) {\n      loader.load(LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, undefined, function () {\n        reject(new Error('THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'))\n      })\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferViewIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n  loadBufferView(bufferViewIndex) {\n    const bufferViewDef = this.json.bufferViews[bufferViewIndex]\n\n    return this.getDependency('buffer', bufferViewDef.buffer).then(function (buffer) {\n      const byteLength = bufferViewDef.byteLength || 0\n      const byteOffset = bufferViewDef.byteOffset || 0\n      return buffer.slice(byteOffset, byteOffset + byteLength)\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n   * @param {number} accessorIndex\n   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n   */\n  loadAccessor(accessorIndex) {\n    const parser = this\n    const json = this.json\n\n    const accessorDef = this.json.accessors[accessorIndex]\n\n    if (accessorDef.bufferView === undefined && accessorDef.sparse === undefined) {\n      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type]\n      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType]\n      const normalized = accessorDef.normalized === true\n\n      const array = new TypedArray(accessorDef.count * itemSize)\n      return Promise.resolve(new BufferAttribute(array, itemSize, normalized))\n    }\n\n    const pendingBufferViews = []\n\n    if (accessorDef.bufferView !== undefined) {\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.bufferView))\n    } else {\n      pendingBufferViews.push(null)\n    }\n\n    if (accessorDef.sparse !== undefined) {\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.indices.bufferView))\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.values.bufferView))\n    }\n\n    return Promise.all(pendingBufferViews).then(function (bufferViews) {\n      const bufferView = bufferViews[0]\n\n      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type]\n      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType]\n\n      // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n      const elementBytes = TypedArray.BYTES_PER_ELEMENT\n      const itemBytes = elementBytes * itemSize\n      const byteOffset = accessorDef.byteOffset || 0\n      const byteStride =\n        accessorDef.bufferView !== undefined ? json.bufferViews[accessorDef.bufferView].byteStride : undefined\n      const normalized = accessorDef.normalized === true\n      let array, bufferAttribute\n\n      // The buffer is not interleaved if the stride is the item size in bytes.\n      if (byteStride && byteStride !== itemBytes) {\n        // Each \"slice\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer\n        // This makes sure that IBA.count reflects accessor.count properly\n        const ibSlice = Math.floor(byteOffset / byteStride)\n        const ibCacheKey =\n          'InterleavedBuffer:' +\n          accessorDef.bufferView +\n          ':' +\n          accessorDef.componentType +\n          ':' +\n          ibSlice +\n          ':' +\n          accessorDef.count\n        let ib = parser.cache.get(ibCacheKey)\n\n        if (!ib) {\n          array = new TypedArray(bufferView, ibSlice * byteStride, (accessorDef.count * byteStride) / elementBytes)\n\n          // Integer parameters to IB/IBA are in array elements, not bytes.\n          ib = new InterleavedBuffer(array, byteStride / elementBytes)\n\n          parser.cache.add(ibCacheKey, ib)\n        }\n\n        bufferAttribute = new InterleavedBufferAttribute(\n          ib,\n          itemSize,\n          (byteOffset % byteStride) / elementBytes,\n          normalized,\n        )\n      } else {\n        if (bufferView === null) {\n          array = new TypedArray(accessorDef.count * itemSize)\n        } else {\n          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize)\n        }\n\n        bufferAttribute = new BufferAttribute(array, itemSize, normalized)\n      }\n\n      // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\n      if (accessorDef.sparse !== undefined) {\n        const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR\n        const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType]\n\n        const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0\n        const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0\n\n        const sparseIndices = new TypedArrayIndices(\n          bufferViews[1],\n          byteOffsetIndices,\n          accessorDef.sparse.count * itemSizeIndices,\n        )\n        const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize)\n\n        if (bufferView !== null) {\n          // Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\n          bufferAttribute = new BufferAttribute(\n            bufferAttribute.array.slice(),\n            bufferAttribute.itemSize,\n            bufferAttribute.normalized,\n          )\n        }\n\n        for (let i = 0, il = sparseIndices.length; i < il; i++) {\n          const index = sparseIndices[i]\n\n          bufferAttribute.setX(index, sparseValues[i * itemSize])\n          if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1])\n          if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2])\n          if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3])\n          if (itemSize >= 5) throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.')\n        }\n      }\n\n      return bufferAttribute\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n   * @param {number} textureIndex\n   * @return {Promise<THREE.Texture|null>}\n   */\n  loadTexture(textureIndex) {\n    const json = this.json\n    const options = this.options\n    const textureDef = json.textures[textureIndex]\n    const sourceIndex = textureDef.source\n    const sourceDef = json.images[sourceIndex]\n\n    let loader = this.textureLoader\n\n    if (sourceDef.uri) {\n      const handler = options.manager.getHandler(sourceDef.uri)\n      if (handler !== null) loader = handler\n    }\n\n    return this.loadTextureImage(textureIndex, sourceIndex, loader)\n  }\n\n  loadTextureImage(textureIndex, sourceIndex, loader) {\n    const parser = this\n    const json = this.json\n\n    const textureDef = json.textures[textureIndex]\n    const sourceDef = json.images[sourceIndex]\n\n    const cacheKey = (sourceDef.uri || sourceDef.bufferView) + ':' + textureDef.sampler\n\n    if (this.textureCache[cacheKey]) {\n      // See https://github.com/mrdoob/three.js/issues/21559.\n      return this.textureCache[cacheKey]\n    }\n\n    const promise = this.loadImageSource(sourceIndex, loader)\n      .then(function (texture) {\n        texture.flipY = false\n\n        texture.name = textureDef.name || sourceDef.name || ''\n\n        if (\n          texture.name === '' &&\n          typeof sourceDef.uri === 'string' &&\n          sourceDef.uri.startsWith('data:image/') === false\n        ) {\n          texture.name = sourceDef.uri\n        }\n\n        const samplers = json.samplers || {}\n        const sampler = samplers[textureDef.sampler] || {}\n\n        texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter\n        texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter\n        texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping\n        texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping\n\n        parser.associations.set(texture, { textures: textureIndex })\n\n        return texture\n      })\n      .catch(function () {\n        return null\n      })\n\n    this.textureCache[cacheKey] = promise\n\n    return promise\n  }\n\n  loadImageSource(sourceIndex, loader) {\n    const parser = this\n    const json = this.json\n    const options = this.options\n\n    if (this.sourceCache[sourceIndex] !== undefined) {\n      return this.sourceCache[sourceIndex].then((texture) => texture.clone())\n    }\n\n    const sourceDef = json.images[sourceIndex]\n\n    const URL = self.URL || self.webkitURL\n\n    let sourceURI = sourceDef.uri || ''\n    let isObjectURL = false\n\n    if (sourceDef.bufferView !== undefined) {\n      // Load binary image data from bufferView, if provided.\n\n      sourceURI = parser.getDependency('bufferView', sourceDef.bufferView).then(function (bufferView) {\n        isObjectURL = true\n        const blob = new Blob([bufferView], { type: sourceDef.mimeType })\n        sourceURI = URL.createObjectURL(blob)\n        return sourceURI\n      })\n    } else if (sourceDef.uri === undefined) {\n      throw new Error('THREE.GLTFLoader: Image ' + sourceIndex + ' is missing URI and bufferView')\n    }\n\n    const promise = Promise.resolve(sourceURI)\n      .then(function (sourceURI) {\n        return new Promise(function (resolve, reject) {\n          let onLoad = resolve\n\n          if (loader.isImageBitmapLoader === true) {\n            onLoad = function (imageBitmap) {\n              const texture = new Texture(imageBitmap)\n              texture.needsUpdate = true\n\n              resolve(texture)\n            }\n          }\n\n          loader.load(LoaderUtils.resolveURL(sourceURI, options.path), onLoad, undefined, reject)\n        })\n      })\n      .then(function (texture) {\n        // Clean up resources and configure Texture.\n\n        if (isObjectURL === true) {\n          URL.revokeObjectURL(sourceURI)\n        }\n\n        assignExtrasToUserData(texture, sourceDef)\n\n        texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri)\n\n        return texture\n      })\n      .catch(function (error) {\n        console.error(\"THREE.GLTFLoader: Couldn't load texture\", sourceURI)\n        throw error\n      })\n\n    this.sourceCache[sourceIndex] = promise\n    return promise\n  }\n\n  /**\n   * Asynchronously assigns a texture to the given material parameters.\n   * @param {Object} materialParams\n   * @param {string} mapName\n   * @param {Object} mapDef\n   * @return {Promise<Texture>}\n   */\n  assignTexture(materialParams, mapName, mapDef, colorSpace) {\n    const parser = this\n\n    return this.getDependency('texture', mapDef.index).then(function (texture) {\n      if (!texture) return null\n\n      if (mapDef.texCoord !== undefined && mapDef.texCoord > 0) {\n        texture = texture.clone()\n        texture.channel = mapDef.texCoord\n      }\n\n      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {\n        const transform =\n          mapDef.extensions !== undefined ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : undefined\n\n        if (transform) {\n          const gltfReference = parser.associations.get(texture)\n          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform)\n          parser.associations.set(texture, gltfReference)\n        }\n      }\n\n      if (colorSpace !== undefined) {\n        // Convert from legacy encoding to colorSpace\n        if (typeof colorSpace === 'number')\n          colorSpace = colorSpace === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace\n\n        // Set colorSpace if able, fallback to legacy encoding\n        if ('colorSpace' in texture) texture.colorSpace = colorSpace\n        else texture.encoding = colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding\n      }\n\n      materialParams[mapName] = texture\n\n      return texture\n    })\n  }\n\n  /**\n   * Assigns final material to a Mesh, Line, or Points instance. The instance\n   * already has a material (generated from the glTF material options alone)\n   * but reuse of the same glTF material may require multiple threejs materials\n   * to accommodate different primitive types, defines, etc. New materials will\n   * be created if necessary, and reused from a cache.\n   * @param  {Object3D} mesh Mesh, Line, or Points instance.\n   */\n  assignFinalMaterial(mesh) {\n    const geometry = mesh.geometry\n    let material = mesh.material\n\n    const useDerivativeTangents = geometry.attributes.tangent === undefined\n    const useVertexColors = geometry.attributes.color !== undefined\n    const useFlatShading = geometry.attributes.normal === undefined\n\n    if (mesh.isPoints) {\n      const cacheKey = 'PointsMaterial:' + material.uuid\n\n      let pointsMaterial = this.cache.get(cacheKey)\n\n      if (!pointsMaterial) {\n        pointsMaterial = new PointsMaterial()\n        Material.prototype.copy.call(pointsMaterial, material)\n        pointsMaterial.color.copy(material.color)\n        pointsMaterial.map = material.map\n        pointsMaterial.sizeAttenuation = false // glTF spec says points should be 1px\n\n        this.cache.add(cacheKey, pointsMaterial)\n      }\n\n      material = pointsMaterial\n    } else if (mesh.isLine) {\n      const cacheKey = 'LineBasicMaterial:' + material.uuid\n\n      let lineMaterial = this.cache.get(cacheKey)\n\n      if (!lineMaterial) {\n        lineMaterial = new LineBasicMaterial()\n        Material.prototype.copy.call(lineMaterial, material)\n        lineMaterial.color.copy(material.color)\n        lineMaterial.map = material.map\n\n        this.cache.add(cacheKey, lineMaterial)\n      }\n\n      material = lineMaterial\n    }\n\n    // Clone the material if it will be modified\n    if (useDerivativeTangents || useVertexColors || useFlatShading) {\n      let cacheKey = 'ClonedMaterial:' + material.uuid + ':'\n\n      if (useDerivativeTangents) cacheKey += 'derivative-tangents:'\n      if (useVertexColors) cacheKey += 'vertex-colors:'\n      if (useFlatShading) cacheKey += 'flat-shading:'\n\n      let cachedMaterial = this.cache.get(cacheKey)\n\n      if (!cachedMaterial) {\n        cachedMaterial = material.clone()\n\n        if (useVertexColors) cachedMaterial.vertexColors = true\n        if (useFlatShading) cachedMaterial.flatShading = true\n\n        if (useDerivativeTangents) {\n          // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n          if (cachedMaterial.normalScale) cachedMaterial.normalScale.y *= -1\n          if (cachedMaterial.clearcoatNormalScale) cachedMaterial.clearcoatNormalScale.y *= -1\n        }\n\n        this.cache.add(cacheKey, cachedMaterial)\n\n        this.associations.set(cachedMaterial, this.associations.get(material))\n      }\n\n      material = cachedMaterial\n    }\n\n    mesh.material = material\n  }\n\n  getMaterialType(/* materialIndex */) {\n    return MeshStandardMaterial\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n   * @param {number} materialIndex\n   * @return {Promise<Material>}\n   */\n  loadMaterial(materialIndex) {\n    const parser = this\n    const json = this.json\n    const extensions = this.extensions\n    const materialDef = json.materials[materialIndex]\n\n    let materialType\n    const materialParams = {}\n    const materialExtensions = materialDef.extensions || {}\n\n    const pending = []\n\n    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\n      const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT]\n      materialType = kmuExtension.getMaterialType()\n      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser))\n    } else {\n      // Specification:\n      // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n\n      const metallicRoughness = materialDef.pbrMetallicRoughness || {}\n\n      materialParams.color = new Color(1.0, 1.0, 1.0)\n      materialParams.opacity = 1.0\n\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor\n\n        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace)\n        materialParams.opacity = array[3]\n      }\n\n      if (metallicRoughness.baseColorTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace))\n      }\n\n      materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0\n      materialParams.roughness =\n        metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0\n\n      if (metallicRoughness.metallicRoughnessTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture))\n        pending.push(parser.assignTexture(materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture))\n      }\n\n      materialType = this._invokeOne(function (ext) {\n        return ext.getMaterialType && ext.getMaterialType(materialIndex)\n      })\n\n      pending.push(\n        Promise.all(\n          this._invokeAll(function (ext) {\n            return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams)\n          }),\n        ),\n      )\n    }\n\n    if (materialDef.doubleSided === true) {\n      materialParams.side = DoubleSide\n    }\n\n    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE\n\n    if (alphaMode === ALPHA_MODES.BLEND) {\n      materialParams.transparent = true\n\n      // See: https://github.com/mrdoob/three.js/issues/17706\n      materialParams.depthWrite = false\n    } else {\n      materialParams.transparent = false\n\n      if (alphaMode === ALPHA_MODES.MASK) {\n        materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5\n      }\n    }\n\n    if (materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'normalMap', materialDef.normalTexture))\n\n      materialParams.normalScale = new Vector2(1, 1)\n\n      if (materialDef.normalTexture.scale !== undefined) {\n        const scale = materialDef.normalTexture.scale\n\n        materialParams.normalScale.set(scale, scale)\n      }\n    }\n\n    if (materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'aoMap', materialDef.occlusionTexture))\n\n      if (materialDef.occlusionTexture.strength !== undefined) {\n        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength\n      }\n    }\n\n    if (materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial) {\n      const emissiveFactor = materialDef.emissiveFactor\n      materialParams.emissive = new Color().setRGB(\n        emissiveFactor[0],\n        emissiveFactor[1],\n        emissiveFactor[2],\n        LinearSRGBColorSpace,\n      )\n    }\n\n    if (materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'emissiveMap', materialDef.emissiveTexture, SRGBColorSpace))\n    }\n\n    return Promise.all(pending).then(function () {\n      const material = new materialType(materialParams)\n\n      if (materialDef.name) material.name = materialDef.name\n\n      assignExtrasToUserData(material, materialDef)\n\n      parser.associations.set(material, { materials: materialIndex })\n\n      if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef)\n\n      return material\n    })\n  }\n\n  /** When Object3D instances are targeted by animation, they need unique names. */\n  createUniqueName(originalName) {\n    const sanitizedName = PropertyBinding.sanitizeNodeName(originalName || '')\n\n    if (sanitizedName in this.nodeNamesUsed) {\n      return sanitizedName + '_' + ++this.nodeNamesUsed[sanitizedName]\n    } else {\n      this.nodeNamesUsed[sanitizedName] = 0\n\n      return sanitizedName\n    }\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n   *\n   * Creates BufferGeometries from primitives.\n   *\n   * @param {Array<GLTF.Primitive>} primitives\n   * @return {Promise<Array<BufferGeometry>>}\n   */\n  loadGeometries(primitives) {\n    const parser = this\n    const extensions = this.extensions\n    const cache = this.primitiveCache\n\n    function createDracoPrimitive(primitive) {\n      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]\n        .decodePrimitive(primitive, parser)\n        .then(function (geometry) {\n          return addPrimitiveAttributes(geometry, primitive, parser)\n        })\n    }\n\n    const pending = []\n\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const primitive = primitives[i]\n      const cacheKey = createPrimitiveKey(primitive)\n\n      // See if we've already created this geometry\n      const cached = cache[cacheKey]\n\n      if (cached) {\n        // Use the cached geometry if it exists\n        pending.push(cached.promise)\n      } else {\n        let geometryPromise\n\n        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\n          // Use DRACO geometry if available\n          geometryPromise = createDracoPrimitive(primitive)\n        } else {\n          // Otherwise create a new geometry\n          geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser)\n        }\n\n        // Cache this geometry\n        cache[cacheKey] = { primitive: primitive, promise: geometryPromise }\n\n        pending.push(geometryPromise)\n      }\n    }\n\n    return Promise.all(pending)\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n   * @param {number} meshIndex\n   * @return {Promise<Group|Mesh|SkinnedMesh>}\n   */\n  loadMesh(meshIndex) {\n    const parser = this\n    const json = this.json\n    const extensions = this.extensions\n\n    const meshDef = json.meshes[meshIndex]\n    const primitives = meshDef.primitives\n\n    const pending = []\n\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const material =\n        primitives[i].material === undefined\n          ? createDefaultMaterial(this.cache)\n          : this.getDependency('material', primitives[i].material)\n\n      pending.push(material)\n    }\n\n    pending.push(parser.loadGeometries(primitives))\n\n    return Promise.all(pending).then(function (results) {\n      const materials = results.slice(0, results.length - 1)\n      const geometries = results[results.length - 1]\n\n      const meshes = []\n\n      for (let i = 0, il = geometries.length; i < il; i++) {\n        const geometry = geometries[i]\n        const primitive = primitives[i]\n\n        // 1. create Mesh\n\n        let mesh\n\n        const material = materials[i]\n\n        if (\n          primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||\n          primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||\n          primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||\n          primitive.mode === undefined\n        ) {\n          // .isSkinnedMesh isn't in glTF spec. See ._markDefs()\n          mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material)\n\n          if (mesh.isSkinnedMesh === true) {\n            // normalize skin weights to fix malformed assets (see #15319)\n            mesh.normalizeSkinWeights()\n          }\n\n          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\n            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode)\n          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\n            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode)\n          }\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {\n          mesh = new LineSegments(geometry, material)\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\n          mesh = new Line(geometry, material)\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\n          mesh = new LineLoop(geometry, material)\n        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\n          mesh = new Points(geometry, material)\n        } else {\n          throw new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode)\n        }\n\n        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {\n          updateMorphTargets(mesh, meshDef)\n        }\n\n        mesh.name = parser.createUniqueName(meshDef.name || 'mesh_' + meshIndex)\n\n        assignExtrasToUserData(mesh, meshDef)\n\n        if (primitive.extensions) addUnknownExtensionsToUserData(extensions, mesh, primitive)\n\n        parser.assignFinalMaterial(mesh)\n\n        meshes.push(mesh)\n      }\n\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        parser.associations.set(meshes[i], {\n          meshes: meshIndex,\n          primitives: i,\n        })\n      }\n\n      if (meshes.length === 1) {\n        if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, meshes[0], meshDef)\n\n        return meshes[0]\n      }\n\n      const group = new Group()\n\n      if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, group, meshDef)\n\n      parser.associations.set(group, { meshes: meshIndex })\n\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        group.add(meshes[i])\n      }\n\n      return group\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n   * @param {number} cameraIndex\n   * @return {Promise<THREE.Camera>}\n   */\n  loadCamera(cameraIndex) {\n    let camera\n    const cameraDef = this.json.cameras[cameraIndex]\n    const params = cameraDef[cameraDef.type]\n\n    if (!params) {\n      console.warn('THREE.GLTFLoader: Missing camera parameters.')\n      return\n    }\n\n    if (cameraDef.type === 'perspective') {\n      camera = new PerspectiveCamera(\n        MathUtils.radToDeg(params.yfov),\n        params.aspectRatio || 1,\n        params.znear || 1,\n        params.zfar || 2e6,\n      )\n    } else if (cameraDef.type === 'orthographic') {\n      camera = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar)\n    }\n\n    if (cameraDef.name) camera.name = this.createUniqueName(cameraDef.name)\n\n    assignExtrasToUserData(camera, cameraDef)\n\n    return Promise.resolve(camera)\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n   * @param {number} skinIndex\n   * @return {Promise<Skeleton>}\n   */\n  loadSkin(skinIndex) {\n    const skinDef = this.json.skins[skinIndex]\n\n    const pending = []\n\n    for (let i = 0, il = skinDef.joints.length; i < il; i++) {\n      pending.push(this._loadNodeShallow(skinDef.joints[i]))\n    }\n\n    if (skinDef.inverseBindMatrices !== undefined) {\n      pending.push(this.getDependency('accessor', skinDef.inverseBindMatrices))\n    } else {\n      pending.push(null)\n    }\n\n    return Promise.all(pending).then(function (results) {\n      const inverseBindMatrices = results.pop()\n      const jointNodes = results\n\n      // Note that bones (joint nodes) may or may not be in the\n      // scene graph at this time.\n\n      const bones = []\n      const boneInverses = []\n\n      for (let i = 0, il = jointNodes.length; i < il; i++) {\n        const jointNode = jointNodes[i]\n\n        if (jointNode) {\n          bones.push(jointNode)\n\n          const mat = new Matrix4()\n\n          if (inverseBindMatrices !== null) {\n            mat.fromArray(inverseBindMatrices.array, i * 16)\n          }\n\n          boneInverses.push(mat)\n        } else {\n          console.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', skinDef.joints[i])\n        }\n      }\n\n      return new Skeleton(bones, boneInverses)\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n   * @param {number} animationIndex\n   * @return {Promise<AnimationClip>}\n   */\n  loadAnimation(animationIndex) {\n    const json = this.json\n    const parser = this\n\n    const animationDef = json.animations[animationIndex]\n    const animationName = animationDef.name ? animationDef.name : 'animation_' + animationIndex\n\n    const pendingNodes = []\n    const pendingInputAccessors = []\n    const pendingOutputAccessors = []\n    const pendingSamplers = []\n    const pendingTargets = []\n\n    for (let i = 0, il = animationDef.channels.length; i < il; i++) {\n      const channel = animationDef.channels[i]\n      const sampler = animationDef.samplers[channel.sampler]\n      const target = channel.target\n      const name = target.node\n      const input = animationDef.parameters !== undefined ? animationDef.parameters[sampler.input] : sampler.input\n      const output = animationDef.parameters !== undefined ? animationDef.parameters[sampler.output] : sampler.output\n\n      if (target.node === undefined) continue\n\n      pendingNodes.push(this.getDependency('node', name))\n      pendingInputAccessors.push(this.getDependency('accessor', input))\n      pendingOutputAccessors.push(this.getDependency('accessor', output))\n      pendingSamplers.push(sampler)\n      pendingTargets.push(target)\n    }\n\n    return Promise.all([\n      Promise.all(pendingNodes),\n      Promise.all(pendingInputAccessors),\n      Promise.all(pendingOutputAccessors),\n      Promise.all(pendingSamplers),\n      Promise.all(pendingTargets),\n    ]).then(function (dependencies) {\n      const nodes = dependencies[0]\n      const inputAccessors = dependencies[1]\n      const outputAccessors = dependencies[2]\n      const samplers = dependencies[3]\n      const targets = dependencies[4]\n\n      const tracks = []\n\n      for (let i = 0, il = nodes.length; i < il; i++) {\n        const node = nodes[i]\n        const inputAccessor = inputAccessors[i]\n        const outputAccessor = outputAccessors[i]\n        const sampler = samplers[i]\n        const target = targets[i]\n\n        if (node === undefined) continue\n\n        if (node.updateMatrix) {\n          node.updateMatrix()\n        }\n\n        const createdTracks = parser._createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target)\n\n        if (createdTracks) {\n          for (let k = 0; k < createdTracks.length; k++) {\n            tracks.push(createdTracks[k])\n          }\n        }\n      }\n\n      return new AnimationClip(animationName, undefined, tracks)\n    })\n  }\n\n  createNodeMesh(nodeIndex) {\n    const json = this.json\n    const parser = this\n    const nodeDef = json.nodes[nodeIndex]\n\n    if (nodeDef.mesh === undefined) return null\n\n    return parser.getDependency('mesh', nodeDef.mesh).then(function (mesh) {\n      const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh)\n\n      // if weights are provided on the node, override weights on the mesh.\n      if (nodeDef.weights !== undefined) {\n        node.traverse(function (o) {\n          if (!o.isMesh) return\n\n          for (let i = 0, il = nodeDef.weights.length; i < il; i++) {\n            o.morphTargetInfluences[i] = nodeDef.weights[i]\n          }\n        })\n      }\n\n      return node\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n   * @param {number} nodeIndex\n   * @return {Promise<Object3D>}\n   */\n  loadNode(nodeIndex) {\n    const json = this.json\n    const parser = this\n\n    const nodeDef = json.nodes[nodeIndex]\n\n    const nodePending = parser._loadNodeShallow(nodeIndex)\n\n    const childPending = []\n    const childrenDef = nodeDef.children || []\n\n    for (let i = 0, il = childrenDef.length; i < il; i++) {\n      childPending.push(parser.getDependency('node', childrenDef[i]))\n    }\n\n    const skeletonPending =\n      nodeDef.skin === undefined ? Promise.resolve(null) : parser.getDependency('skin', nodeDef.skin)\n\n    return Promise.all([nodePending, Promise.all(childPending), skeletonPending]).then(function (results) {\n      const node = results[0]\n      const children = results[1]\n      const skeleton = results[2]\n\n      if (skeleton !== null) {\n        // This full traverse should be fine because\n        // child glTF nodes have not been added to this node yet.\n        node.traverse(function (mesh) {\n          if (!mesh.isSkinnedMesh) return\n\n          mesh.bind(skeleton, _identityMatrix)\n        })\n      }\n\n      for (let i = 0, il = children.length; i < il; i++) {\n        node.add(children[i])\n      }\n\n      return node\n    })\n  }\n\n  // ._loadNodeShallow() parses a single node.\n  // skin and child nodes are created and added in .loadNode() (no '_' prefix).\n  _loadNodeShallow(nodeIndex) {\n    const json = this.json\n    const extensions = this.extensions\n    const parser = this\n\n    // This method is called from .loadNode() and .loadSkin().\n    // Cache a node to avoid duplication.\n\n    if (this.nodeCache[nodeIndex] !== undefined) {\n      return this.nodeCache[nodeIndex]\n    }\n\n    const nodeDef = json.nodes[nodeIndex]\n\n    // reserve node's name before its dependencies, so the root has the intended name.\n    const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : ''\n\n    const pending = []\n\n    const meshPromise = parser._invokeOne(function (ext) {\n      return ext.createNodeMesh && ext.createNodeMesh(nodeIndex)\n    })\n\n    if (meshPromise) {\n      pending.push(meshPromise)\n    }\n\n    if (nodeDef.camera !== undefined) {\n      pending.push(\n        parser.getDependency('camera', nodeDef.camera).then(function (camera) {\n          return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera)\n        }),\n      )\n    }\n\n    parser\n      ._invokeAll(function (ext) {\n        return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex)\n      })\n      .forEach(function (promise) {\n        pending.push(promise)\n      })\n\n    this.nodeCache[nodeIndex] = Promise.all(pending).then(function (objects) {\n      let node\n\n      // .isBone isn't in glTF spec. See ._markDefs\n      if (nodeDef.isBone === true) {\n        node = new Bone()\n      } else if (objects.length > 1) {\n        node = new Group()\n      } else if (objects.length === 1) {\n        node = objects[0]\n      } else {\n        node = new Object3D()\n      }\n\n      if (node !== objects[0]) {\n        for (let i = 0, il = objects.length; i < il; i++) {\n          node.add(objects[i])\n        }\n      }\n\n      if (nodeDef.name) {\n        node.userData.name = nodeDef.name\n        node.name = nodeName\n      }\n\n      assignExtrasToUserData(node, nodeDef)\n\n      if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef)\n\n      if (nodeDef.matrix !== undefined) {\n        const matrix = new Matrix4()\n        matrix.fromArray(nodeDef.matrix)\n        node.applyMatrix4(matrix)\n      } else {\n        if (nodeDef.translation !== undefined) {\n          node.position.fromArray(nodeDef.translation)\n        }\n\n        if (nodeDef.rotation !== undefined) {\n          node.quaternion.fromArray(nodeDef.rotation)\n        }\n\n        if (nodeDef.scale !== undefined) {\n          node.scale.fromArray(nodeDef.scale)\n        }\n      }\n\n      if (!parser.associations.has(node)) {\n        parser.associations.set(node, {})\n      }\n\n      parser.associations.get(node).nodes = nodeIndex\n\n      return node\n    })\n\n    return this.nodeCache[nodeIndex]\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n   * @param {number} sceneIndex\n   * @return {Promise<Group>}\n   */\n  loadScene(sceneIndex) {\n    const extensions = this.extensions\n    const sceneDef = this.json.scenes[sceneIndex]\n    const parser = this\n\n    // Loader returns Group, not Scene.\n    // See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172\n    const scene = new Group()\n    if (sceneDef.name) scene.name = parser.createUniqueName(sceneDef.name)\n\n    assignExtrasToUserData(scene, sceneDef)\n\n    if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef)\n\n    const nodeIds = sceneDef.nodes || []\n\n    const pending = []\n\n    for (let i = 0, il = nodeIds.length; i < il; i++) {\n      pending.push(parser.getDependency('node', nodeIds[i]))\n    }\n\n    return Promise.all(pending).then(function (nodes) {\n      for (let i = 0, il = nodes.length; i < il; i++) {\n        scene.add(nodes[i])\n      }\n\n      // Removes dangling associations, associations that reference a node that\n      // didn't make it into the scene.\n      const reduceAssociations = (node) => {\n        const reducedAssociations = new Map()\n\n        for (const [key, value] of parser.associations) {\n          if (key instanceof Material || key instanceof Texture) {\n            reducedAssociations.set(key, value)\n          }\n        }\n\n        node.traverse((node) => {\n          const mappings = parser.associations.get(node)\n\n          if (mappings != null) {\n            reducedAssociations.set(node, mappings)\n          }\n        })\n\n        return reducedAssociations\n      }\n\n      parser.associations = reduceAssociations(scene)\n\n      return scene\n    })\n  }\n\n  _createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target) {\n    const tracks = []\n\n    const targetName = node.name ? node.name : node.uuid\n    const targetNames = []\n\n    if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\n      node.traverse(function (object) {\n        if (object.morphTargetInfluences) {\n          targetNames.push(object.name ? object.name : object.uuid)\n        }\n      })\n    } else {\n      targetNames.push(targetName)\n    }\n\n    let TypedKeyframeTrack\n\n    switch (PATH_PROPERTIES[target.path]) {\n      case PATH_PROPERTIES.weights:\n        TypedKeyframeTrack = NumberKeyframeTrack\n        break\n\n      case PATH_PROPERTIES.rotation:\n        TypedKeyframeTrack = QuaternionKeyframeTrack\n        break\n\n      case PATH_PROPERTIES.position:\n      case PATH_PROPERTIES.scale:\n        TypedKeyframeTrack = VectorKeyframeTrack\n        break\n\n      default:\n        switch (outputAccessor.itemSize) {\n          case 1:\n            TypedKeyframeTrack = NumberKeyframeTrack\n            break\n          case 2:\n          case 3:\n          default:\n            TypedKeyframeTrack = VectorKeyframeTrack\n            break\n        }\n\n        break\n    }\n\n    const interpolation = sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : InterpolateLinear\n\n    const outputArray = this._getArrayFromAccessor(outputAccessor)\n\n    for (let j = 0, jl = targetNames.length; j < jl; j++) {\n      const track = new TypedKeyframeTrack(\n        targetNames[j] + '.' + PATH_PROPERTIES[target.path],\n        inputAccessor.array,\n        outputArray,\n        interpolation,\n      )\n\n      // Override interpolation with custom factory method.\n      if (sampler.interpolation === 'CUBICSPLINE') {\n        this._createCubicSplineTrackInterpolant(track)\n      }\n\n      tracks.push(track)\n    }\n\n    return tracks\n  }\n\n  _getArrayFromAccessor(accessor) {\n    let outputArray = accessor.array\n\n    if (accessor.normalized) {\n      const scale = getNormalizedComponentScale(outputArray.constructor)\n      const scaled = new Float32Array(outputArray.length)\n\n      for (let j = 0, jl = outputArray.length; j < jl; j++) {\n        scaled[j] = outputArray[j] * scale\n      }\n\n      outputArray = scaled\n    }\n\n    return outputArray\n  }\n\n  _createCubicSplineTrackInterpolant(track) {\n    track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {\n      // A CUBICSPLINE keyframe in glTF has three output values for each input value,\n      // representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\n      // must be divided by three to get the interpolant's sampleSize argument.\n\n      const interpolantType =\n        this instanceof QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant\n\n      return new interpolantType(this.times, this.values, this.getValueSize() / 3, result)\n    }\n\n    // Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\n    track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true\n  }\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n */\nfunction computeBounds(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes\n\n  const box = new Box3()\n\n  if (attributes.POSITION !== undefined) {\n    const accessor = parser.json.accessors[attributes.POSITION]\n\n    const min = accessor.min\n    const max = accessor.max\n\n    // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n    if (min !== undefined && max !== undefined) {\n      box.set(new Vector3(min[0], min[1], min[2]), new Vector3(max[0], max[1], max[2]))\n\n      if (accessor.normalized) {\n        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType])\n        box.min.multiplyScalar(boxScale)\n        box.max.multiplyScalar(boxScale)\n      }\n    } else {\n      console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.')\n\n      return\n    }\n  } else {\n    return\n  }\n\n  const targets = primitiveDef.targets\n\n  if (targets !== undefined) {\n    const maxDisplacement = new Vector3()\n    const vector = new Vector3()\n\n    for (let i = 0, il = targets.length; i < il; i++) {\n      const target = targets[i]\n\n      if (target.POSITION !== undefined) {\n        const accessor = parser.json.accessors[target.POSITION]\n        const min = accessor.min\n        const max = accessor.max\n\n        // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n        if (min !== undefined && max !== undefined) {\n          // we need to get max of absolute components because target weight is [-1,1]\n          vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])))\n          vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])))\n          vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])))\n\n          if (accessor.normalized) {\n            const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType])\n            vector.multiplyScalar(boxScale)\n          }\n\n          // Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative\n          // to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets\n          // are used to implement key-frame animations and as such only two are active at a time - this results in very large\n          // boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.\n          maxDisplacement.max(vector)\n        } else {\n          console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.')\n        }\n      }\n    }\n\n    // As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.\n    box.expandByVector(maxDisplacement)\n  }\n\n  geometry.boundingBox = box\n\n  const sphere = new Sphere()\n\n  box.getCenter(sphere.center)\n  sphere.radius = box.min.distanceTo(box.max) / 2\n\n  geometry.boundingSphere = sphere\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\nfunction addPrimitiveAttributes(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes\n\n  const pending = []\n\n  function assignAttributeAccessor(accessorIndex, attributeName) {\n    return parser.getDependency('accessor', accessorIndex).then(function (accessor) {\n      geometry.setAttribute(attributeName, accessor)\n    })\n  }\n\n  for (const gltfAttributeName in attributes) {\n    const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase()\n\n    // Skip attributes already provided by e.g. Draco extension.\n    if (threeAttributeName in geometry.attributes) continue\n\n    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName))\n  }\n\n  if (primitiveDef.indices !== undefined && !geometry.index) {\n    const accessor = parser.getDependency('accessor', primitiveDef.indices).then(function (accessor) {\n      geometry.setIndex(accessor)\n    })\n\n    pending.push(accessor)\n  }\n\n  assignExtrasToUserData(geometry, primitiveDef)\n\n  computeBounds(geometry, primitiveDef, parser)\n\n  return Promise.all(pending).then(function () {\n    return primitiveDef.targets !== undefined ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry\n  })\n}\n\nexport { GLTFLoader }\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { SkeletonUtils } from 'three-stdlib';\n\nfunction createSpread(child, {\n  keys = ['near', 'far', 'color', 'distance', 'decay', 'penumbra', 'angle', 'intensity', 'skeleton', 'visible', 'castShadow', 'receiveShadow', 'morphTargetDictionary', 'morphTargetInfluences', 'name', 'geometry', 'material', 'position', 'rotation', 'scale', 'up', 'userData', 'bindMode', 'bindMatrix', 'bindMatrixInverse', 'skeleton'],\n  deep,\n  inject,\n  castShadow,\n  receiveShadow\n}) {\n  let spread = {};\n  for (const key of keys) {\n    spread[key] = child[key];\n  }\n  if (deep) {\n    if (spread.geometry && deep !== 'materialsOnly') spread.geometry = spread.geometry.clone();\n    if (spread.material && deep !== 'geometriesOnly') spread.material = spread.material.clone();\n  }\n  if (inject) {\n    if (typeof inject === 'function') spread = {\n      ...spread,\n      children: inject(child)\n    };else if (/*#__PURE__*/React.isValidElement(inject)) spread = {\n      ...spread,\n      children: inject\n    };else spread = {\n      ...spread,\n      ...inject\n    };\n  }\n  if (child instanceof THREE.Mesh) {\n    if (castShadow) spread.castShadow = true;\n    if (receiveShadow) spread.receiveShadow = true;\n  }\n  return spread;\n}\nconst Clone = /* @__PURE__ */React.forwardRef(({\n  isChild = false,\n  object,\n  children,\n  deep,\n  castShadow,\n  receiveShadow,\n  inject,\n  keys,\n  ...props\n}, forwardRef) => {\n  const config = {\n    keys,\n    deep,\n    inject,\n    castShadow,\n    receiveShadow\n  };\n  object = React.useMemo(() => {\n    if (isChild === false && !Array.isArray(object)) {\n      let isSkinned = false;\n      object.traverse(object => {\n        if (object.isSkinnedMesh) isSkinned = true;\n      });\n      if (isSkinned) return SkeletonUtils.clone(object);\n    }\n    return object;\n  }, [object, isChild]);\n\n  // Deal with arrayed clones\n  if (Array.isArray(object)) {\n    return /*#__PURE__*/React.createElement(\"group\", _extends({}, props, {\n      ref: forwardRef\n    }), object.map(o => /*#__PURE__*/React.createElement(Clone, _extends({\n      key: o.uuid,\n      object: o\n    }, config))), children);\n  }\n\n  // Singleton clones\n  const {\n    children: injectChildren,\n    ...spread\n  } = createSpread(object, config);\n  const Element = object.type[0].toLowerCase() + object.type.slice(1);\n  return /*#__PURE__*/React.createElement(Element, _extends({}, spread, props, {\n    ref: forwardRef\n  }), object.children.map(child => {\n    if (child.type === 'Bone') return /*#__PURE__*/React.createElement(\"primitive\", _extends({\n      key: child.uuid,\n      object: child\n    }, config));\n    return /*#__PURE__*/React.createElement(Clone, _extends({\n      key: child.uuid,\n      object: child\n    }, config, {\n      isChild: true\n    }));\n  }), children, injectChildren);\n});\n\nexport { Clone };\n"],"names":["worker","clone","buffer","self","object","material","morphTargetsRelative","a","b","c","i","il","res","sourceURI","node","accessor"],"mappings":"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","ignoreList":[1,2,3,4,5,6,7,8,9,10,11,12,13]}