{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/danilonovais/_danilonov_portfolio/src/hooks/useWebGLSupport.ts"],"sourcesContent":["import { useEffect, useState } from 'react';\n\nconst checkWebGLSupport = (): boolean => {\n  if (typeof window === 'undefined') return false;\n  try {\n    const canvas = document.createElement('canvas');\n    return Boolean(\n      window.WebGLRenderingContext &&\n      (canvas.getContext('webgl') || canvas.getContext('experimental-webgl'))\n    );\n  } catch {\n    return false;\n  }\n};\n\nexport const useWebGLSupport = (): boolean => {\n  const [supportsWebGL, setSupportsWebGL] = useState(false);\n\n  useEffect(() => {\n    setSupportsWebGL(checkWebGLSupport());\n  }, []);\n\n  return supportsWebGL;\n};\n"],"names":[],"mappings":";;;;AAAA;;;AAEA,MAAM,oBAAoB;IACxB;;IACA,IAAI;QACF,MAAM,SAAS,SAAS,aAAa,CAAC;QACtC,OAAO,QACL,OAAO,qBAAqB,IAC5B,CAAC,OAAO,UAAU,CAAC,YAAY,OAAO,UAAU,CAAC,qBAAqB;IAE1E,EAAE,OAAM;QACN,OAAO;IACT;AACF;AAEO,MAAM,kBAAkB;;IAC7B,MAAM,CAAC,eAAe,iBAAiB,GAAG,IAAA,yKAAQ,EAAC;IAEnD,IAAA,0KAAS;qCAAC;YACR,iBAAiB;QACnB;oCAAG,EAAE;IAEL,OAAO;AACT;GARa"}},
    {"offset": {"line": 39, "column": 0}, "map": {"version":3,"sources":["file:///Users/danilonovais/_danilonov_portfolio/src/hooks/usePrefersReducedMotion.ts"],"sourcesContent":["import { useState, useEffect } from 'react';\n\nexport function usePrefersReducedMotion() {\n  const [prefersReducedMotion, setPrefersReducedMotion] = useState(false);\n\n  useEffect(() => {\n    // Verifica se window.matchMedia estÃ¡ disponÃ­vel (SSR e test safety)\n    if (typeof window === 'undefined' || !window.matchMedia) {\n      return;\n    }\n\n    const mediaQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n    setPrefersReducedMotion(mediaQuery.matches);\n\n    const handler = (event: MediaQueryListEvent) => {\n      setPrefersReducedMotion(event.matches);\n    };\n\n    mediaQuery.addEventListener('change', handler);\n    return () => mediaQuery.removeEventListener('change', handler);\n  }, []);\n\n  return prefersReducedMotion;\n}\n"],"names":[],"mappings":";;;;AAAA;;;AAEO,SAAS;;IACd,MAAM,CAAC,sBAAsB,wBAAwB,GAAG,IAAA,yKAAQ,EAAC;IAEjE,IAAA,0KAAS;6CAAC;YACR,oEAAoE;YACpE,IAAI,+CAAkB,eAAe,CAAC,OAAO,UAAU,EAAE;gBACvD;YACF;YAEA,MAAM,aAAa,OAAO,UAAU,CAAC;YACrC,wBAAwB,WAAW,OAAO;YAE1C,MAAM;6DAAU,CAAC;oBACf,wBAAwB,MAAM,OAAO;gBACvC;;YAEA,WAAW,gBAAgB,CAAC,UAAU;YACtC;qDAAO,IAAM,WAAW,mBAAmB,CAAC,UAAU;;QACxD;4CAAG,EAAE;IAEL,OAAO;AACT;GArBgB"}},
    {"offset": {"line": 78, "column": 0}, "map": {"version":3,"sources":["file:///Users/danilonovais/_danilonov_portfolio/src/hooks/usePerformanceAdaptive.ts"],"sourcesContent":["import { useEffect, useState } from 'react';\n\ntype QualityLevel = 'high' | 'medium' | 'low';\n\nexport interface PerformanceConfig {\n  quality: QualityLevel;\n  fireflyCount: number;\n  particleCount: number;\n  enablePostProcessing: boolean;\n  pixelRatio: number;\n}\n\nexport function usePerformanceAdaptive(): PerformanceConfig {\n  const [quality, setQuality] = useState<QualityLevel>('high');\n\n  useEffect(() => {\n    const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);\n    const isLowEnd =\n      navigator.hardwareConcurrency && navigator.hardwareConcurrency <= 4;\n    const hasLowMemory =\n      'deviceMemory' in navigator && (navigator as any).deviceMemory < 4;\n\n    if (isMobile || isLowEnd || hasLowMemory) {\n      setQuality('low');\n      return;\n    }\n\n    if (window.devicePixelRatio > 2) {\n      setQuality('medium');\n      return;\n    }\n\n    let frames = 0;\n    let lastTime = performance.now();\n    let rafId: number;\n\n    const checkFPS = () => {\n      frames++;\n      const now = performance.now();\n\n      if (now >= lastTime + 1000) {\n        const fps = Math.round((frames * 1000) / (now - lastTime));\n        if (fps < 30 && quality !== 'low') {\n          setQuality((prev) => (prev === 'high' ? 'medium' : 'low'));\n        }\n        frames = 0;\n        lastTime = now;\n      }\n      rafId = requestAnimationFrame(checkFPS);\n    };\n\n    rafId = requestAnimationFrame(checkFPS);\n    return () => cancelAnimationFrame(rafId);\n  }, [quality]);\n\n  const configs: Record<QualityLevel, PerformanceConfig> = {\n    high: {\n      quality: 'high',\n      fireflyCount: 20,\n      particleCount: 50,\n      enablePostProcessing: true,\n      pixelRatio: Math.min(window.devicePixelRatio, 2),\n    },\n    medium: {\n      quality: 'medium',\n      fireflyCount: 12,\n      particleCount: 25,\n      enablePostProcessing: false,\n      pixelRatio: 1.5,\n    },\n    low: {\n      quality: 'low',\n      fireflyCount: 6,\n      particleCount: 10,\n      enablePostProcessing: false,\n      pixelRatio: 1,\n    },\n  };\n\n  return configs[quality];\n}\n"],"names":[],"mappings":";;;;AAAA;;;AAYO,SAAS;;IACd,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,yKAAQ,EAAe;IAErD,IAAA,0KAAS;4CAAC;YACR,MAAM,WAAW,4BAA4B,IAAI,CAAC,UAAU,SAAS;YACrE,MAAM,WACJ,UAAU,mBAAmB,IAAI,UAAU,mBAAmB,IAAI;YACpE,MAAM,eACJ,kBAAkB,aAAa,AAAC,UAAkB,YAAY,GAAG;YAEnE,IAAI,YAAY,YAAY,cAAc;gBACxC,WAAW;gBACX;YACF;YAEA,IAAI,OAAO,gBAAgB,GAAG,GAAG;gBAC/B,WAAW;gBACX;YACF;YAEA,IAAI,SAAS;YACb,IAAI,WAAW,YAAY,GAAG;YAC9B,IAAI;YAEJ,MAAM;6DAAW;oBACf;oBACA,MAAM,MAAM,YAAY,GAAG;oBAE3B,IAAI,OAAO,WAAW,MAAM;wBAC1B,MAAM,MAAM,KAAK,KAAK,CAAC,AAAC,SAAS,OAAQ,CAAC,MAAM,QAAQ;wBACxD,IAAI,MAAM,MAAM,YAAY,OAAO;4BACjC;6EAAW,CAAC,OAAU,SAAS,SAAS,WAAW;;wBACrD;wBACA,SAAS;wBACT,WAAW;oBACb;oBACA,QAAQ,sBAAsB;gBAChC;;YAEA,QAAQ,sBAAsB;YAC9B;oDAAO,IAAM,qBAAqB;;QACpC;2CAAG;QAAC;KAAQ;IAEZ,MAAM,UAAmD;QACvD,MAAM;YACJ,SAAS;YACT,cAAc;YACd,eAAe;YACf,sBAAsB;YACtB,YAAY,KAAK,GAAG,CAAC,OAAO,gBAAgB,EAAE;QAChD;QACA,QAAQ;YACN,SAAS;YACT,cAAc;YACd,eAAe;YACf,sBAAsB;YACtB,YAAY;QACd;QACA,KAAK;YACH,SAAS;YACT,cAAc;YACd,eAAe;YACf,sBAAsB;YACtB,YAAY;QACd;IACF;IAEA,OAAO,OAAO,CAAC,QAAQ;AACzB;GApEgB"}},
    {"offset": {"line": 162, "column": 0}, "map": {"version":3,"sources":["file:///Users/danilonovais/_danilonov_portfolio/src/config/ghostConfig.ts"],"sourcesContent":["// src/config/ghostConfig.ts\n\n// Paleta de cores fluorescentes\nexport const FLUORESCENT_COLORS = {\n  cyan: '#00ffff',\n  lime: '#00ff00',\n  magenta: '#ff00ff',\n  yellow: '#ffff00',\n  orange: '#ff4500',\n  pink: '#ff1493',\n  purple: '#9400d3',\n  blue: '#0080ff', // Corrigido para coincidir com a referÃªncia do CodePen\n  green: '#00ff80',\n  red: '#ff0040',\n  teal: '#00ffaa',\n  violet: '#8a2be2',\n} as const;\n\n// Tipo para as chaves da paleta\nexport type FluorescentColorName = keyof typeof FLUORESCENT_COLORS;\n\n// Paleta Extendida (cores personalizadas para o Ghost)\nexport const EXTENDED_FLUORESCENT_COLORS = {\n  ...FLUORESCENT_COLORS,\n  // Cores personalizadas do Ghost\n  deepSpace: '#0f2027',\n  neonCyan: '#50e3c2',\n  violetGlow: '#8a2be2',\n  midnightBlue: '#040013',\n  electricBlue: '#0080ff',\n  voidSky: '#020112',\n  ghostBlue: '#0048ff',\n  darkVoid: '#01010f',\n  fogBlue: '#051f51',\n} as const;\n\n// Tipo para cores extendidas\nexport type ExtendedColorName = keyof typeof EXTENDED_FLUORESCENT_COLORS;\n\n// FunÃ§Ã£o para resolver nomes de cores para valores hex\nexport function resolveFluorescentColor(color: FluorescentColorName): string {\n  return FLUORESCENT_COLORS[color];\n}\n\n// FunÃ§Ã£o para resolver cores do config (suporta nomes personalizados)\nexport function resolveConfigColor(colorName: string): string {\n  if (!colorName || typeof colorName !== 'string') {\n    console.warn('resolveConfigColor received invalid color:', colorName);\n    return '#00ffff'; // Safe fallback\n  }\n\n  // Tenta a paleta extendida primeiro\n  const extendedColor =\n    EXTENDED_FLUORESCENT_COLORS[colorName as ExtendedColorName];\n  if (extendedColor !== undefined) {\n    return extendedColor;\n  }\n  // Retorna o prÃ³prio valor se jÃ¡ for hex\n  if (colorName.startsWith('#') || colorName.startsWith('0x')) {\n    return colorName;\n  }\n  // Fallback para cyan se nÃ£o encontrar\n  console.warn(`[ghostConfig] Cor nÃ£o encontrada: ${colorName}, usando cyan`);\n  return FLUORESCENT_COLORS.cyan;\n}\n\n// Interface para a configuraÃ§Ã£o do Ghost\nexport interface GhostConfig {\n  // Fundo e nÃ©voa\n  backgroundColor: string;\n  fogColor: string;\n  fogNear: number;\n  fogFar: number;\n\n  // CÃ¢mera e renderizaÃ§Ã£o\n  cameraDistance: number;\n  cameraFov: number;\n  rendererDPR: [number, number];\n\n  // AparÃªncia do Ghost\n  ghostScale: number;\n  bodyColor: string;\n  glowColor: string;\n  eyeGlowColor: string;\n  ghostOpacity: number;\n  emissiveIntensity: number;\n  pulseSpeed: number;\n  pulseIntensity: number;\n  floatSpeed: number;\n\n  // Comportamento do Ghost\n  followSpeed: number;\n  movementThreshold: number;\n\n  // IluminaÃ§Ã£o\n  rimLightIntensity: number;\n  ambientLightColor: string;\n  ambientLightIntensity: number;\n\n  // VÃ©u AtmosfÃ©rico (RevelaÃ§Ã£o)\n  veilColor: string;\n  veilEmissive: string;\n  veilEmissiveIntensity: number;\n  veilOpacity: number;\n  veilPulseAmount: number;\n  veilBackgroundColor: string;\n  veilBackgroundOpacity: number;\n\n  // Fireflies\n  fireflyCount: number;\n  fireflySpeed: number;\n  fireflyBaseRadius: number;\n  fireflyRadiusVariance: number;\n  fireflyScaleBase: number;\n  fireflyScaleVariance: number;\n  fireflyFloatFrequency: number;\n  fireflyFloatAmplitude: number;\n  fireflyWobbleFrequency: number;\n  fireflyWobbleIntensity: number;\n  fireflyPulseBase: number;\n  fireflyPulseVariance: number;\n  fireflyPulseFrequency: number;\n  fireflyOpacity: number;\n  fireflyGlowIntensity: number;\n\n  // PartÃ­culas\n  particleCount: number;\n  particleColor: string;\n  particleSpeedFactor: number;\n  particleRadius: number;\n  particleGlowOffset: number;\n  particleGlowSpeed: number;\n  particleGlowStrength: number;\n  particleOpacity: number;\n  particleDecayRate: number;\n  createParticlesOnlyWhenMoving: boolean;\n  particleCreationRate: number;\n\n  // Olhos\n  eyeGlowIntensity: number;\n  eyeGlowResponse: number;\n  eyeGlowDecay: number;\n\n  // Efeitos de PÃ³s-Processamento (Analog Decay)\n  analogGrain: number;\n  analogBleeding: number;\n  analogScanlines: number;\n  analogVignette: number;\n  analogIntensity: number;\n  analogJitter: number;\n  analogVSync: number;\n  limboMode: boolean;\n\n  // ParÃ¢metros do VÃ©u AtmosfÃ©rico\n  revealRadius: number;\n  fadeStrength: number;\n  baseOpacity: number;\n  revealOpacity: number;\n}\n\n// ConfiguraÃ§Ã£o centralizada do Ghost (valores alinhados com o CodePen)\nexport const GHOST_CONFIG: GhostConfig = {\n  // Fundo e nÃ©voa\n  backgroundColor: '#01010f',\n  fogColor: '#051f51',\n  fogNear: 1.6,\n  fogFar: 2.8,\n\n  // CÃ¢mera e renderizaÃ§Ã£o\n  cameraDistance: 15,\n  cameraFov: 75,\n  rendererDPR: [1, 2],\n\n  // AparÃªncia do Ghost (MATCHED to CodePen Reference)\n  ghostScale: 0.4, // FIXED: was 1.2\n  bodyColor: 'ghostBlue', // 0x0f2027\n  glowColor: 'blue', // \"blue\"\n  eyeGlowColor: 'purple', // FIXED: CodePen uses 'blue' (0x0080ff)\n\n  ghostOpacity: 0.88,\n  emissiveIntensity: 8.5, // FIXED: was 5.8\n  pulseSpeed: 1.6,\n  pulseIntensity: 0.6,\n  floatSpeed: 1.6, // FIXED: was 1.6\n\n  // Comportamento do Ghost\n  followSpeed: 0.05, // FIXED: was 0.05\n  movementThreshold: 0.07,\n\n  // IluminaÃ§Ã£o\n  rimLightIntensity: 1.8,\n  ambientLightColor: 'cyan',\n  ambientLightIntensity: 0.08,\n\n  // VÃ©u AtmosfÃ©rico (RevelaÃ§Ã£o)\n  veilColor: 'ghostBlue',\n  veilEmissive: 'blue',\n  veilEmissiveIntensity: 3.6,\n  veilOpacity: 3.9,\n  veilPulseAmount: 1.6,\n  veilBackgroundColor: 'blue',\n  veilBackgroundOpacity: 0.95,\n\n  // Fireflies (Matched to CodePen)\n  fireflyCount: 20, // CodePen cria 20 fireflies em createFireflies loop\n  fireflySpeed: 0.09,\n  fireflyBaseRadius: 0.02,\n  fireflyRadiusVariance: 0.06,\n  fireflyScaleBase: 1,\n  fireflyScaleVariance: 0.5,\n  fireflyFloatFrequency: 1,\n  fireflyFloatAmplitude: 0.05,\n  fireflyWobbleFrequency: 0.5,\n  fireflyWobbleIntensity: 0.09,\n  fireflyPulseBase: 0.9,\n  fireflyPulseVariance: 0.4,\n  fireflyPulseFrequency: 2,\n  fireflyOpacity: 0.9,\n  fireflyGlowIntensity: 4.3,\n\n  // PartÃ­culas (Matched to CodePen)\n  particleCount: 650,\n  particleColor: 'violet',\n  particleSpeedFactor: 0.012,\n  particleRadius: 3.5,\n  particleGlowOffset: 0.6,\n  particleGlowSpeed: 0.003,\n  particleGlowStrength: 0.9,\n  particleOpacity: 0.9,\n  particleDecayRate: 0.005,\n  createParticlesOnlyWhenMoving: true,\n  particleCreationRate: 5,\n\n  // Olhos (Matched to CodePen)\n  eyeGlowIntensity: 9.5,\n  eyeGlowResponse: 0.31,\n  eyeGlowDecay: 0.95,\n\n  // Efeitos de PÃ³s-Processamento (Matched to CodePen)\n  analogGrain: 2.4,\n  analogBleeding: 1.5,\n  analogScanlines: 0.7,\n  analogVignette: 0.9,\n  analogIntensity: 0.9,\n  analogJitter: 0.5,\n  analogVSync: 0.7,\n  limboMode: false,\n\n  // ParÃ¢metros do VÃ©u AtmosfÃ©rico (MATCHED to CodePen Reference)\n  revealRadius: 17, // Increased for better text readability\n  fadeStrength: 0.7,\n  baseOpacity: 0.08, // Darker background to create reveal contrast\n  revealOpacity: -0.2, // Fully transparent reveal\n};\n\n// Helper para converter cor do config para formato numÃ©rico (Three.js)\nexport function getConfigColorHex(colorName: string): number {\n  const hex = resolveConfigColor(colorName);\n  return parseInt(hex.replace('#', ''), 16);\n}\n"],"names":[],"mappings":"AAAA,4BAA4B;AAE5B,gCAAgC;;;;;;;;;;;;;;;AACzB,MAAM,qBAAqB;IAChC,MAAM;IACN,MAAM;IACN,SAAS;IACT,QAAQ;IACR,QAAQ;IACR,MAAM;IACN,QAAQ;IACR,MAAM;IACN,OAAO;IACP,KAAK;IACL,MAAM;IACN,QAAQ;AACV;AAMO,MAAM,8BAA8B;IACzC,GAAG,kBAAkB;IACrB,gCAAgC;IAChC,WAAW;IACX,UAAU;IACV,YAAY;IACZ,cAAc;IACd,cAAc;IACd,SAAS;IACT,WAAW;IACX,UAAU;IACV,SAAS;AACX;AAMO,SAAS,wBAAwB,KAA2B;IACjE,OAAO,kBAAkB,CAAC,MAAM;AAClC;AAGO,SAAS,mBAAmB,SAAiB;IAClD,IAAI,CAAC,aAAa,OAAO,cAAc,UAAU;QAC/C,QAAQ,IAAI,CAAC,8CAA8C;QAC3D,OAAO,WAAW,gBAAgB;IACpC;IAEA,oCAAoC;IACpC,MAAM,gBACJ,2BAA2B,CAAC,UAA+B;IAC7D,IAAI,kBAAkB,WAAW;QAC/B,OAAO;IACT;IACA,wCAAwC;IACxC,IAAI,UAAU,UAAU,CAAC,QAAQ,UAAU,UAAU,CAAC,OAAO;QAC3D,OAAO;IACT;IACA,sCAAsC;IACtC,QAAQ,IAAI,CAAC,CAAC,kCAAkC,EAAE,UAAU,aAAa,CAAC;IAC1E,OAAO,mBAAmB,IAAI;AAChC;AAiGO,MAAM,eAA4B;IACvC,gBAAgB;IAChB,iBAAiB;IACjB,UAAU;IACV,SAAS;IACT,QAAQ;IAER,wBAAwB;IACxB,gBAAgB;IAChB,WAAW;IACX,aAAa;QAAC;QAAG;KAAE;IAEnB,oDAAoD;IACpD,YAAY;IACZ,WAAW;IACX,WAAW;IACX,cAAc;IAEd,cAAc;IACd,mBAAmB;IACnB,YAAY;IACZ,gBAAgB;IAChB,YAAY;IAEZ,yBAAyB;IACzB,aAAa;IACb,mBAAmB;IAEnB,aAAa;IACb,mBAAmB;IACnB,mBAAmB;IACnB,uBAAuB;IAEvB,8BAA8B;IAC9B,WAAW;IACX,cAAc;IACd,uBAAuB;IACvB,aAAa;IACb,iBAAiB;IACjB,qBAAqB;IACrB,uBAAuB;IAEvB,iCAAiC;IACjC,cAAc;IACd,cAAc;IACd,mBAAmB;IACnB,uBAAuB;IACvB,kBAAkB;IAClB,sBAAsB;IACtB,uBAAuB;IACvB,uBAAuB;IACvB,wBAAwB;IACxB,wBAAwB;IACxB,kBAAkB;IAClB,sBAAsB;IACtB,uBAAuB;IACvB,gBAAgB;IAChB,sBAAsB;IAEtB,kCAAkC;IAClC,eAAe;IACf,eAAe;IACf,qBAAqB;IACrB,gBAAgB;IAChB,oBAAoB;IACpB,mBAAmB;IACnB,sBAAsB;IACtB,iBAAiB;IACjB,mBAAmB;IACnB,+BAA+B;IAC/B,sBAAsB;IAEtB,6BAA6B;IAC7B,kBAAkB;IAClB,iBAAiB;IACjB,cAAc;IAEd,oDAAoD;IACpD,aAAa;IACb,gBAAgB;IAChB,iBAAiB;IACjB,gBAAgB;IAChB,iBAAiB;IACjB,cAAc;IACd,aAAa;IACb,WAAW;IAEX,+DAA+D;IAC/D,cAAc;IACd,cAAc;IACd,aAAa;IACb,eAAe,CAAC;AAClB;AAGO,SAAS,kBAAkB,SAAiB;IACjD,MAAM,MAAM,mBAAmB;IAC/B,OAAO,SAAS,IAAI,OAAO,CAAC,KAAK,KAAK;AACxC"}},
    {"offset": {"line": 322, "column": 0}, "map": {"version":3,"sources":["file:///Users/danilonovais/_danilonov_portfolio/src/components/canvas/shaders/AnalogShader.ts"],"sourcesContent":["// src/components/canvas/shaders/AnalogShader.ts\nimport * as THREE from 'three';\n\nexport const AnalogDecayShader = {\n  uniforms: {\n    tDiffuse: { value: null },\n    uTime: { value: 0.0 },\n    uResolution: { value: new THREE.Vector2(1, 1) },\n    uAnalogGrain: { value: 0.4 },\n    uAnalogBleeding: { value: 1.0 },\n    uAnalogVSync: { value: 1.0 },\n    uAnalogScanlines: { value: 1.0 },\n    uAnalogVignette: { value: 1.0 },\n    uAnalogJitter: { value: 0.4 },\n    uAnalogIntensity: { value: 0.6 },\n    uLimboMode: { value: 0.0 },\n  },\n  vertexShader: `\n    varying vec2 vUv;\n    void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  `,\n  fragmentShader: `\n    uniform sampler2D tDiffuse;\n    uniform float uTime;\n    uniform vec2 uResolution;\n    uniform float uAnalogGrain;\n    uniform float uAnalogBleeding;\n    uniform float uAnalogVSync;\n    uniform float uAnalogScanlines;\n    uniform float uAnalogVignette;\n    uniform float uAnalogJitter;\n    uniform float uAnalogIntensity;\n    uniform float uLimboMode;\n    varying vec2 vUv;\n\n    float random(vec2 st) {\n      return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n    }\n\n    float random(float x) {\n      return fract(sin(x) * 43758.5453123);\n    }\n\n    float gaussian(float z, float u, float o) {\n      return (1.0 / (o * sqrt(2.0 * 3.1415))) * exp(-(((z - u) * (z - u)) / (2.0 * (o * o))));\n    }\n\n    vec3 grain(vec2 uv, float time, float intensity) {\n      float seed = dot(uv, vec2(12.9898, 78.233));\n      float noise = fract(sin(seed) * 43758.5453 + time * 2.0);\n      noise = gaussian(noise, 0.0, 0.5 * 0.5);\n      return vec3(noise) * intensity;\n    }\n\n    void main() {\n      vec2 uv = vUv;\n      float time = uTime * 1.8;\n\n      vec2 jitteredUV = uv;\n      if (uAnalogJitter > 0.01) {\n        float jitterAmount = (random(vec2(floor(time * 60.0))) - 0.5) * 0.003 * uAnalogJitter * uAnalogIntensity;\n        jitteredUV.x += jitterAmount;\n        jitteredUV.y += (random(vec2(floor(time * 30.0) + 1.0)) - 0.5) * 0.001 * uAnalogJitter * uAnalogIntensity;\n      }\n\n      if (uAnalogVSync > 0.01) {\n        float vsyncRoll = sin(time * 2.0 + uv.y * 100.0) * 0.02 * uAnalogVSync * uAnalogIntensity;\n        float vsyncChance = step(0.95, random(vec2(floor(time * 4.0))));\n        jitteredUV.y += vsyncRoll * vsyncChance;\n      }\n\n      vec4 color = texture2D(tDiffuse, jitteredUV);\n\n      if (uAnalogBleeding > 0.01) {\n        float bleedAmount = 0.012 * uAnalogBleeding * uAnalogIntensity;\n        float offsetPhase = time * 1.5 + uv.y * 20.0;\n        vec2 redOffset = vec2(sin(offsetPhase) * bleedAmount, 0.0);\n        vec2 blueOffset = vec2(-sin(offsetPhase * 1.1) * bleedAmount * 0.8, 0.0);\n        float r = texture2D(tDiffuse, jitteredUV + redOffset).r;\n        float g = texture2D(tDiffuse, jitteredUV).g;\n        float b = texture2D(tDiffuse, jitteredUV + blueOffset).b;\n        color = vec4(r, g, b, color.a);\n      }\n\n      if (uAnalogGrain > 0.01) {\n        vec3 grainEffect = grain(uv, time, 0.075 * uAnalogGrain * uAnalogIntensity);\n        grainEffect *= (1.0 - color.rgb);\n        color.rgb += grainEffect;\n      }\n\n      if (uAnalogScanlines > 0.01) {\n        float scanlineFreq = 600.0 + uAnalogScanlines * 400.0;\n        float scanlinePattern = sin(uv.y * scanlineFreq) * 0.5 + 0.5;\n        float scanlineIntensity = 0.1 * uAnalogScanlines * uAnalogIntensity;\n        color.rgb *= (1.0 - scanlinePattern * scanlineIntensity);\n        float horizontalLines = sin(uv.y * scanlineFreq * 0.1) * 0.02 * uAnalogScanlines * uAnalogIntensity;\n        color.rgb *= (1.0 - horizontalLines);\n      }\n\n      if (uAnalogVignette > 0.01) {\n        vec2 vignetteUV = (uv - 0.5) * 2.0;\n        float vignette = 1.0 - dot(vignetteUV, vignetteUV) * 0.3 * uAnalogVignette * uAnalogIntensity;\n        color.rgb *= vignette;\n      }\n\n      if (uLimboMode > 0.5) {\n        float gray = dot(color.rgb, vec3(0.299, 0.587, 0.114));\n        color.rgb = vec3(gray);\n      }\n\n      gl_FragColor = color;\n    }\n  `,\n};\n"],"names":[],"mappings":";;;;AAAA,gDAAgD;AAChD;;AAEO,MAAM,oBAAoB;IAC/B,UAAU;QACR,UAAU;YAAE,OAAO;QAAK;QACxB,OAAO;YAAE,OAAO;QAAI;QACpB,aAAa;YAAE,OAAO,IAAI,6JAAa,CAAC,GAAG;QAAG;QAC9C,cAAc;YAAE,OAAO;QAAI;QAC3B,iBAAiB;YAAE,OAAO;QAAI;QAC9B,cAAc;YAAE,OAAO;QAAI;QAC3B,kBAAkB;YAAE,OAAO;QAAI;QAC/B,iBAAiB;YAAE,OAAO;QAAI;QAC9B,eAAe;YAAE,OAAO;QAAI;QAC5B,kBAAkB;YAAE,OAAO;QAAI;QAC/B,YAAY;YAAE,OAAO;QAAI;IAC3B;IACA,cAAc,CAAC;;;;;;EAMf,CAAC;IACD,gBAAgB,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA2FjB,CAAC;AACH"}},
    {"offset": {"line": 472, "column": 0}, "map": {"version":3,"sources":["file:///Users/danilonovais/_danilonov_portfolio/src/components/canvas/home/hero/GhostFireflies.tsx"],"sourcesContent":["import { useRef, useMemo } from 'react';\nimport { useFrame } from '@react-three/fiber';\nimport * as THREE from 'three';\nimport { GHOST_CONFIG } from '@/config/ghostConfig';\n\nexport function GhostFireflies() {\n  const groupRef = useRef<THREE.Group>(null!);\n\n  // Initialize firefly data\n  const fireflies = useMemo(() => {\n    return Array.from({ length: GHOST_CONFIG.fireflyCount }).map(() => ({\n      position: new THREE.Vector3(\n        (Math.random() - 0.5) * 40,\n        (Math.random() - 0.5) * 30,\n        (Math.random() - 0.5) * 20\n      ),\n      velocity: new THREE.Vector3(\n        (Math.random() - 0.5) * GHOST_CONFIG.fireflySpeed,\n        (Math.random() - 0.5) * GHOST_CONFIG.fireflySpeed,\n        (Math.random() - 0.5) * GHOST_CONFIG.fireflySpeed\n      ),\n      phase: Math.random() * Math.PI * 2,\n      pulseSpeed: 2 + Math.random() * 3,\n    }));\n  }, []);\n\n  useFrame(({ clock }) => {\n    if (!groupRef.current) return;\n    const t = clock.getElapsedTime();\n\n    groupRef.current.children.forEach((child, i) => {\n      const data = fireflies[i];\n      if (!data) return;\n\n      const mesh = child as THREE.Mesh;\n\n      // Update position\n      mesh.position.add(data.velocity);\n\n      // Bounds check (bounce)\n      if (Math.abs(mesh.position.x) > 30) data.velocity.x *= -1;\n      if (Math.abs(mesh.position.y) > 20) data.velocity.y *= -1;\n      if (Math.abs(mesh.position.z) > 15) data.velocity.z *= -1;\n\n      // Pulse effect\n      const pulsePhase = t + data.phase;\n      const pulse = Math.sin(pulsePhase * data.pulseSpeed) * 0.4 + 0.6;\n\n      const material = mesh.material as THREE.MeshBasicMaterial;\n      if (material) {\n        material.opacity = GHOST_CONFIG.fireflyOpacity * pulse;\n      }\n\n      // Update glow/light if we had them attached, but here we just have simple mesh + light\n      // The CodePen has child glow mesh + light.\n      // For simplicity/performance in R3F, we can just pulse opacity and maybe scale?\n      // CodePen pulses opacity of glowMaterial and fireflyMaterial and light intensity.\n\n      // Let's assume the child structure: Mesh (Firefly) -> [Mesh (Glow), PointLight]\n      const light = mesh.children.find(\n        (c) => c instanceof THREE.PointLight\n      ) as THREE.PointLight;\n      const glow = mesh.children.find(\n        (c) => c instanceof THREE.Mesh\n      ) as THREE.Mesh; // The glow sphere\n\n      if (light) {\n        light.intensity = GHOST_CONFIG.fireflyGlowIntensity * 0.8 * pulse;\n      }\n      if (glow) {\n        (glow.material as THREE.MeshBasicMaterial).opacity =\n          GHOST_CONFIG.fireflyGlowIntensity * 0.5 * pulse;\n      }\n    });\n  });\n\n  return (\n    <group ref={groupRef}>\n      {fireflies.map((data, i) => (\n        <mesh key={i} position={data.position}>\n          <sphereGeometry args={[0.05, 2, 2]} />\n          <meshBasicMaterial color={0xffff44} transparent opacity={0.9} />\n\n          {/* Glow Sphere */}\n          <mesh>\n            <sphereGeometry args={[0.09, 8, 8]} />\n            <meshBasicMaterial\n              color={0xffff88}\n              transparent\n              opacity={0.4}\n              side={THREE.BackSide}\n            />\n          </mesh>\n\n          <pointLight color={0xffff44} intensity={0.5} distance={4} decay={3} />\n        </mesh>\n      ))}\n    </group>\n  );\n}\n"],"names":[],"mappings":";;;;;AAAA;AACA;AACA;AACA;;;;;;;AAEO,SAAS;;IACd,MAAM,WAAW,IAAA,uKAAM,EAAc;IAErC,0BAA0B;IAC1B,MAAM,YAAY,IAAA,wKAAO;6CAAC;YACxB,OAAO,MAAM,IAAI,CAAC;gBAAE,QAAQ,+IAAY,CAAC,YAAY;YAAC,GAAG,GAAG;qDAAC,IAAM,CAAC;wBAClE,UAAU,IAAI,6JAAa,CACzB,CAAC,KAAK,MAAM,KAAK,GAAG,IAAI,IACxB,CAAC,KAAK,MAAM,KAAK,GAAG,IAAI,IACxB,CAAC,KAAK,MAAM,KAAK,GAAG,IAAI;wBAE1B,UAAU,IAAI,6JAAa,CACzB,CAAC,KAAK,MAAM,KAAK,GAAG,IAAI,+IAAY,CAAC,YAAY,EACjD,CAAC,KAAK,MAAM,KAAK,GAAG,IAAI,+IAAY,CAAC,YAAY,EACjD,CAAC,KAAK,MAAM,KAAK,GAAG,IAAI,+IAAY,CAAC,YAAY;wBAEnD,OAAO,KAAK,MAAM,KAAK,KAAK,EAAE,GAAG;wBACjC,YAAY,IAAI,KAAK,MAAM,KAAK;oBAClC,CAAC;;QACH;4CAAG,EAAE;IAEL,IAAA,8NAAQ;mCAAC,CAAC,EAAE,KAAK,EAAE;YACjB,IAAI,CAAC,SAAS,OAAO,EAAE;YACvB,MAAM,IAAI,MAAM,cAAc;YAE9B,SAAS,OAAO,CAAC,QAAQ,CAAC,OAAO;2CAAC,CAAC,OAAO;oBACxC,MAAM,OAAO,SAAS,CAAC,EAAE;oBACzB,IAAI,CAAC,MAAM;oBAEX,MAAM,OAAO;oBAEb,kBAAkB;oBAClB,KAAK,QAAQ,CAAC,GAAG,CAAC,KAAK,QAAQ;oBAE/B,wBAAwB;oBACxB,IAAI,KAAK,GAAG,CAAC,KAAK,QAAQ,CAAC,CAAC,IAAI,IAAI,KAAK,QAAQ,CAAC,CAAC,IAAI,CAAC;oBACxD,IAAI,KAAK,GAAG,CAAC,KAAK,QAAQ,CAAC,CAAC,IAAI,IAAI,KAAK,QAAQ,CAAC,CAAC,IAAI,CAAC;oBACxD,IAAI,KAAK,GAAG,CAAC,KAAK,QAAQ,CAAC,CAAC,IAAI,IAAI,KAAK,QAAQ,CAAC,CAAC,IAAI,CAAC;oBAExD,eAAe;oBACf,MAAM,aAAa,IAAI,KAAK,KAAK;oBACjC,MAAM,QAAQ,KAAK,GAAG,CAAC,aAAa,KAAK,UAAU,IAAI,MAAM;oBAE7D,MAAM,WAAW,KAAK,QAAQ;oBAC9B,IAAI,UAAU;wBACZ,SAAS,OAAO,GAAG,+IAAY,CAAC,cAAc,GAAG;oBACnD;oBAEA,uFAAuF;oBACvF,2CAA2C;oBAC3C,gFAAgF;oBAChF,kFAAkF;oBAElF,gFAAgF;oBAChF,MAAM,QAAQ,KAAK,QAAQ,CAAC,IAAI;yDAC9B,CAAC,IAAM,aAAa,gKAAgB;;oBAEtC,MAAM,OAAO,KAAK,QAAQ,CAAC,IAAI;wDAC7B,CAAC,IAAM,aAAa,0JAAU;wDACf,kBAAkB;oBAEnC,IAAI,OAAO;wBACT,MAAM,SAAS,GAAG,+IAAY,CAAC,oBAAoB,GAAG,MAAM;oBAC9D;oBACA,IAAI,MAAM;wBACP,KAAK,QAAQ,CAA6B,OAAO,GAChD,+IAAY,CAAC,oBAAoB,GAAG,MAAM;oBAC9C;gBACF;;QACF;;IAEA,qBACE,6LAAC;QAAM,KAAK;kBACT,UAAU,GAAG,CAAC,CAAC,MAAM,kBACpB,6LAAC;gBAAa,UAAU,KAAK,QAAQ;;kCACnC,6LAAC;wBAAe,MAAM;4BAAC;4BAAM;4BAAG;yBAAE;;;;;;kCAClC,6LAAC;wBAAkB,OAAO;wBAAU,WAAW;wBAAC,SAAS;;;;;;kCAGzD,6LAAC;;0CACC,6LAAC;gCAAe,MAAM;oCAAC;oCAAM;oCAAG;iCAAE;;;;;;0CAClC,6LAAC;gCACC,OAAO;gCACP,WAAW;gCACX,SAAS;gCACT,MAAM,8JAAc;;;;;;;;;;;;kCAIxB,6LAAC;wBAAW,OAAO;wBAAU,WAAW;wBAAK,UAAU;wBAAG,OAAO;;;;;;;eAfxD;;;;;;;;;;AAoBnB;GA9FgB;;QAqBd,8NAAQ;;;KArBM"}},
    {"offset": {"line": 639, "column": 0}, "map": {"version":3,"sources":["file:///Users/danilonovais/_danilonov_portfolio/src/components/canvas/home/hero/GhostParticles.tsx"],"sourcesContent":["import { useRef, useMemo } from 'react';\nimport { useFrame } from '@react-three/fiber';\nimport * as THREE from 'three';\nimport { GHOST_CONFIG, getConfigColorHex } from '@/config/ghostConfig';\n\ninterface GhostParticlesProps {\n  ghostGroup: React.RefObject<THREE.Group | null>;\n  movementRef: React.MutableRefObject<number>;\n  count: number;\n}\n\n// Particle data structure stored in userData\ninterface ParticleData {\n  life: number;\n  decay: number;\n  velocity: THREE.Vector3;\n  rotationSpeed: THREE.Vector3;\n  active: boolean;\n}\n\nexport function GhostParticles({\n  ghostGroup,\n  movementRef,\n  count,\n}: GhostParticlesProps) {\n  const groupRef = useRef<THREE.Group>(null!);\n  const lastSpawnTime = useRef(2);\n\n  // Initialize particles strictly with geometry and material\n  // We use userData to store simulation state\n  const particles = useMemo(() => {\n    const geoms = [\n      new THREE.SphereGeometry(0.05, 6, 6),\n      new THREE.TetrahedronGeometry(0.04, 0),\n      new THREE.OctahedronGeometry(0.045, 0),\n    ];\n\n    return Array.from({ length: count }).map((_, i) => {\n      const geom = geoms[Math.floor(Math.random() * geoms.length)];\n      return {\n        key: i,\n        geometry: geom,\n      };\n    });\n  }, [count]);\n\n  useFrame(({ clock }) => {\n    if (!groupRef.current || !ghostGroup.current) return;\n\n    const now = clock.getElapsedTime() * 1000; // ms\n    const moveAmt = movementRef.current;\n\n    // SPAWN LOGIC\n    const shouldSpawn = GHOST_CONFIG.createParticlesOnlyWhenMoving\n      ? moveAmt > 0.005\n      : moveAmt > 0.005;\n\n    if (shouldSpawn && now - lastSpawnTime.current > 200) {\n      // Find inactive particles to spawn\n      // CodePen rate: Math.min(params.particleCreationRate, Math.max(1, speedRate))\n      // Simpler rate here:\n      const spawnCount = GHOST_CONFIG.particleCreationRate;\n\n      let spawned = 0;\n      for (const child of groupRef.current.children) {\n        if (spawned >= spawnCount) break;\n        const mesh = child as THREE.Mesh;\n        if (!mesh.visible) {\n          // Activate particle\n          mesh.visible = true;\n          mesh.position.copy(ghostGroup.current.position);\n          mesh.position.z -= 0.8 + Math.random() * 0.6; // Behind ghost\n\n          // Scatter\n          const scatter = 3.5;\n          mesh.position.x += (Math.random() - 0.5) * scatter;\n          mesh.position.y += (Math.random() - 0.5) * scatter - 0.8;\n\n          // Scale\n          const s = 0.6 + Math.random() * 0.7;\n          mesh.scale.set(s, s, s);\n\n          // Rotation\n          mesh.rotation.set(\n            Math.random() * 6,\n            Math.random() * 6,\n            Math.random() * 6\n          );\n\n          // Color variation\n          const color = new THREE.Color(\n            getConfigColorHex(GHOST_CONFIG.particleColor)\n          );\n          color.offsetHSL(Math.random() * 0.1 - 0.05, 0, 0);\n          (mesh.material as THREE.MeshBasicMaterial).color = color;\n          (mesh.material as THREE.MeshBasicMaterial).opacity =\n            Math.random() * 0.9;\n\n          // Init Data\n          mesh.userData = {\n            life: 1.0,\n            decay: Math.random() * 0.003 + GHOST_CONFIG.particleDecayRate,\n            velocity: new THREE.Vector3(\n              (Math.random() - 0.5) * 0.015,\n              (Math.random() - 0.5) * 0.012 - 0.002, // slight down\n              (Math.random() - 0.5) * 0.012 - 0.006\n            ),\n            rotationSpeed: new THREE.Vector3(\n              (Math.random() - 0.5) * 0.015,\n              (Math.random() - 0.5) * 0.015,\n              (Math.random() - 0.5) * 0.015\n            ),\n          } as ParticleData;\n\n          spawned++;\n        }\n      }\n      lastSpawnTime.current = now;\n    }\n\n    // UPDATE LOGIC\n    groupRef.current.children.forEach((child) => {\n      const mesh = child as THREE.Mesh;\n      if (!mesh.visible) return;\n\n      const data = mesh.userData as ParticleData;\n      data.life -= data.decay;\n      (mesh.material as THREE.MeshBasicMaterial).opacity = data.life * 0.85;\n\n      mesh.position.add(data.velocity);\n\n      const swirl =\n        Math.cos(clock.getElapsedTime() * 1.8 + mesh.position.y) * 0.0008;\n      mesh.position.x += swirl;\n\n      mesh.rotation.x += data.rotationSpeed.x;\n      mesh.rotation.y += data.rotationSpeed.y;\n      mesh.rotation.z += data.rotationSpeed.z;\n\n      if (data.life <= 0) {\n        mesh.visible = false;\n      }\n    });\n  });\n\n  return (\n    <group ref={groupRef}>\n      {particles.map((p) => (\n        <mesh key={p.key} geometry={p.geometry} visible={false}>\n          <meshBasicMaterial\n            color={getConfigColorHex(GHOST_CONFIG.particleColor)}\n            transparent\n            opacity={0}\n            alphaTest={0.1}\n          />\n        </mesh>\n      ))}\n    </group>\n  );\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 791, "column": 0}, "map": {"version":3,"sources":["file:///Users/danilonovais/_danilonov_portfolio/src/components/canvas/home/hero/Ghost.tsx"],"sourcesContent":["'use client';\n\nimport { useRef, useEffect, useState } from 'react';\nimport { useFrame, useThree, extend } from '@react-three/fiber';\nimport * as THREE from 'three';\nimport {\n  EffectComposer,\n  RenderPass,\n  UnrealBloomPass,\n  ShaderPass,\n} from 'three-stdlib';\n\nimport { AnalogDecayShader } from '@/components/canvas/shaders/AnalogShader';\nimport { GHOST_CONFIG, getConfigColorHex } from '@/config/ghostConfig';\n\nimport { GhostFireflies } from './GhostFireflies';\nimport { GhostParticles } from './GhostParticles';\n\n// Extender para usar no React Three Fiber\nextend({ EffectComposer, RenderPass, UnrealBloomPass, ShaderPass });\n\nexport function Ghost({\n  particleCount: _particleCount = 100,\n  ghostRef,\n}: {\n  particleCount?: number;\n  ghostRef?: React.RefObject<THREE.Group | null>;\n}) {\n  const internalRef = useRef<THREE.Group>(null!);\n  const groupRef = ghostRef || internalRef;\n  const eyesRef = useRef<THREE.Group>(new THREE.Group());\n  const bodyRef = useRef<THREE.Mesh>(null!);\n\n  const composerRef = useRef<EffectComposer | null>(null);\n  const bloomPassRef = useRef<UnrealBloomPass | null>(null);\n  const analogPassRef = useRef<ShaderPass | null>(null);\n\n  const { viewport, mouse, camera, scene, gl, size } = useThree();\n  const [isLoaded, setIsLoaded] = useState(false);\n\n  // Refs for motion tracking\n  const prevPositionRef = useRef(new THREE.Vector3());\n  const currentMovementRef = useRef(0);\n\n  // Shader customization for \"Skirt\" deformation\n  const onBeforeCompile = (shader: {\n    uniforms: { [uniform: string]: THREE.IUniform };\n    vertexShader: string;\n    fragmentShader: string;\n  }) => {\n    shader.vertexShader = shader.vertexShader.replace(\n      '#include <begin_vertex>',\n      `\n      #include <begin_vertex>\n      \n      // Ghost Skirt Deformation\n      float y = position.y;\n      if (y < -0.2) {\n        float x = position.x;\n        float z = position.z;\n        \n        float noise1 = sin(x * 5.0) * 0.35;\n        float noise2 = cos(z * 4.0) * 0.25;\n        float noise3 = sin((x + z) * 3.0) * 0.15;\n        \n        transformed.y = -2.0 + noise1 + noise2 + noise3;\n      }\n      `\n    );\n  };\n\n  // Inicializar o compositor de efeitos com Resize Handler\n  useEffect(() => {\n    if (!gl || !scene || !camera) return;\n\n    // Garantir que o renderer suporte transparÃªncia\n    gl.setClearColor(0x000000, 0);\n\n    // Configurar Bloom e Composer\n    const composer = new EffectComposer(gl);\n    composer.setSize(size.width, size.height);\n\n    const renderPass = new RenderPass(scene, camera);\n    composer.addPass(renderPass);\n\n    const bloomPass = new UnrealBloomPass(\n      new THREE.Vector2(size.width, size.height),\n      0.3, // strength - Audit ID #04\n      1.15, // radius - Audit ID #04\n      0.5 // threshold\n    );\n    composer.addPass(bloomPass);\n    bloomPassRef.current = bloomPass;\n\n    const analogPass = new ShaderPass(AnalogDecayShader);\n    analogPass.uniforms.uResolution.value.set(size.width, size.height);\n    composer.addPass(analogPass);\n    analogPassRef.current = analogPass;\n\n    composerRef.current = composer;\n    setIsLoaded(true);\n\n    return () => {\n      composer.dispose();\n      setIsLoaded(false);\n    };\n  }, [gl, scene, camera, size]);\n\n  useFrame(({ clock }) => {\n    if (!groupRef.current || !bodyRef.current) return;\n\n    const t = clock.getElapsedTime();\n\n    // Atualizar passos de analog decay\n    if (analogPassRef.current && analogPassRef.current.uniforms) {\n      analogPassRef.current.uniforms.uTime.value = t;\n    }\n\n    // 1. Follow Mouse (Smooth)\n    const targetX = mouse.x * viewport.width * 0.3;\n    const targetY = mouse.y * viewport.height * 0.3;\n\n    groupRef.current.position.x +=\n      (targetX - groupRef.current.position.x) * GHOST_CONFIG.followSpeed;\n    groupRef.current.position.y +=\n      (targetY - groupRef.current.position.y) * GHOST_CONFIG.followSpeed;\n\n    // 2. Float Animation (Idle)\n    const floatY =\n      Math.sin(t * GHOST_CONFIG.floatSpeed * 0.5) * 0.03 +\n      Math.cos(t * GHOST_CONFIG.floatSpeed * 0.7) * 0.018;\n    groupRef.current.position.y += floatY;\n\n    // 3. Pulse (Emissive Heartbeat)\n    const pulse =\n      Math.sin(t * GHOST_CONFIG.pulseSpeed) * GHOST_CONFIG.pulseIntensity;\n    if (bodyRef.current.material instanceof THREE.MeshStandardMaterial) {\n      bodyRef.current.material.emissiveIntensity =\n        GHOST_CONFIG.emissiveIntensity + pulse;\n    }\n\n    // 4. Rotation/Tilt (Velocity based)\n    const velocityX = targetX - groupRef.current.position.x;\n    const velocityY = targetY - groupRef.current.position.y;\n\n    // Smooth Tilt\n    groupRef.current.rotation.z = THREE.MathUtils.lerp(\n      groupRef.current.rotation.z,\n      -velocityX * 0.05,\n      0.05\n    );\n    groupRef.current.rotation.x = THREE.MathUtils.lerp(\n      groupRef.current.rotation.x,\n      velocityY * 0.02,\n      0.02\n    );\n\n    // 5. Eye Glow Logic\n    if (eyesRef.current && eyesRef.current.userData?.leftEyeMaterial) {\n      const prevPos = prevPositionRef.current;\n      const movement = prevPos.distanceTo(groupRef.current.position);\n\n      currentMovementRef.current =\n        currentMovementRef.current * GHOST_CONFIG.eyeGlowDecay +\n        movement * (5 - GHOST_CONFIG.eyeGlowDecay);\n\n      prevPos.copy(groupRef.current.position);\n\n      const isMoving =\n        currentMovementRef.current > GHOST_CONFIG.movementThreshold;\n      const targetOpacity = isMoving ? 1.0 : 0.0;\n      const lerpFactor = isMoving\n        ? GHOST_CONFIG.eyeGlowResponse\n        : GHOST_CONFIG.eyeGlowResponse * 0.5;\n\n      const {\n        leftEyeMaterial,\n        rightEyeMaterial,\n        leftOuterMaterial,\n        rightOuterMaterial,\n      } = eyesRef.current.userData;\n\n      leftEyeMaterial.opacity = THREE.MathUtils.lerp(\n        leftEyeMaterial.opacity,\n        targetOpacity,\n        lerpFactor\n      );\n      rightEyeMaterial.opacity = leftEyeMaterial.opacity;\n      leftOuterMaterial.opacity = leftEyeMaterial.opacity * 0.63;\n      rightOuterMaterial.opacity = leftEyeMaterial.opacity * 0.63;\n    }\n\n    // Renderizar com efeitos (SEMPRE, se composer existir)\n    if (composerRef.current && isLoaded) {\n      composerRef.current.render();\n    }\n  }, 0.5);\n\n  // Setup Eyes (Static Geometry)\n  useEffect(() => {\n    if (!eyesRef.current) return;\n\n    const eyeColorHex = getConfigColorHex(GHOST_CONFIG.eyeGlowColor);\n\n    // 1. Soquetes (Sockets) pretos para dar profundidade - Conforme ReferÃªncia\n    const socketGeo = new THREE.SphereGeometry(0.45, 16, 16);\n    const socketMat = new THREE.MeshBasicMaterial({ color: 0x000000 });\n\n    const leftSocket = new THREE.Mesh(socketGeo, socketMat);\n    leftSocket.position.set(-0.7, 0.6, 1.9);\n    leftSocket.scale.set(1.1, 1.0, 0.6);\n\n    const rightSocket = new THREE.Mesh(socketGeo, socketMat);\n    rightSocket.position.set(0.7, 0.6, 1.9);\n    rightSocket.scale.set(1.1, 1.0, 0.6);\n\n    // 2. Olhos (Glow) - Conforme ReferÃªncia\n    const eyeGeo = new THREE.SphereGeometry(0.3, 12, 12);\n    const outerGeo = new THREE.SphereGeometry(0.525, 12, 12);\n\n    const eyeMat = new THREE.MeshBasicMaterial({\n      color: eyeColorHex,\n      transparent: true,\n      opacity: 0.0,\n    });\n\n    const outerMat = new THREE.MeshBasicMaterial({\n      color: eyeColorHex,\n      transparent: true,\n      opacity: 0.0,\n      side: THREE.BackSide,\n    });\n\n    const leftEye = new THREE.Mesh(eyeGeo, eyeMat.clone());\n    const rightEye = new THREE.Mesh(eyeGeo, eyeMat.clone());\n    const leftOuter = new THREE.Mesh(outerGeo, outerMat.clone());\n    const rightOuter = new THREE.Mesh(outerGeo, outerMat.clone());\n\n    // PosiÃ§Ãµes alinhadas com a referÃªncia\n    leftEye.position.set(-0.7, 0.6, 2.0);\n    rightEye.position.set(0.7, 0.6, 2.0);\n    leftOuter.position.set(-0.7, 0.6, 1.95);\n    rightOuter.position.set(0.7, 0.6, 1.95);\n\n    // Limpar olhos anteriores para evitar duplicatas\n    eyesRef.current.clear();\n    eyesRef.current.add(\n      leftSocket,\n      rightSocket,\n      leftEye,\n      rightEye,\n      leftOuter,\n      rightOuter\n    );\n\n    eyesRef.current.userData = {\n      leftEyeMaterial: leftEye.material as THREE.MeshBasicMaterial,\n      rightEyeMaterial: rightEye.material as THREE.MeshBasicMaterial,\n      leftOuterMaterial: leftOuter.material as THREE.MeshBasicMaterial,\n      rightOuterMaterial: rightOuter.material as THREE.MeshBasicMaterial,\n    };\n\n    // Adicionar ao grupo principal\n    if (groupRef.current) {\n      groupRef.current.add(eyesRef.current);\n    }\n  }, [groupRef]);\n\n  return (\n    <>\n      <GhostFireflies />\n      <GhostParticles\n        ghostGroup={groupRef}\n        movementRef={currentMovementRef}\n        count={_particleCount}\n      />\n      <group ref={groupRef} name=\"ghost\" scale={GHOST_CONFIG.ghostScale}>\n        <mesh ref={bodyRef}>\n          <sphereGeometry args={[2, 64, 64]} />\n          <meshStandardMaterial\n            color={getConfigColorHex(GHOST_CONFIG.bodyColor)}\n            emissive={getConfigColorHex(GHOST_CONFIG.glowColor)}\n            emissiveIntensity={GHOST_CONFIG.emissiveIntensity}\n            roughness={0.02}\n            metalness={0.0}\n            transparent\n            opacity={0.5} // ðŸ‘ˆ More spectral\n            blending={THREE.AdditiveBlending}\n            depthWrite={false}\n            side={THREE.DoubleSide}\n            onBeforeCompile={onBeforeCompile}\n          />\n        </mesh>\n\n        {/* Olhos jÃ¡ estÃ£o no grupo via useEffect */}\n      </group>\n    </>\n  );\n}\n\nexport default Ghost;\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1082, "column": 0}, "map": {"version":3,"sources":["file:///Users/danilonovais/_danilonov_portfolio/src/components/canvas/home/hero/Atmosphere.tsx"],"sourcesContent":["'use client';\n\nimport { useRef } from 'react';\nimport { useFrame } from '@react-three/fiber';\nimport * as THREE from 'three';\nimport { GHOST_CONFIG } from '@/config/ghostConfig';\n\nconst atmosphereShader = {\n  uniforms: {\n    ghostPosition: { value: new THREE.Vector3() },\n    time: { value: 0 },\n    revealRadius: { value: GHOST_CONFIG.revealRadius },\n    fadeStrength: { value: GHOST_CONFIG.fadeStrength },\n    baseOpacity: { value: GHOST_CONFIG.baseOpacity },\n    revealOpacity: { value: GHOST_CONFIG.revealOpacity },\n  },\n  vertexShader: `\n    varying vec3 vWorldPosition;\n    void main() {\n      vec4 worldPos = modelMatrix * vec4(position, 1.0);\n      vWorldPosition = worldPos.xyz;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  `,\n  fragmentShader: `\n    uniform vec3 ghostPosition;\n    uniform float time;\n    uniform float revealRadius;\n    uniform float fadeStrength;\n    uniform float baseOpacity;\n    uniform float revealOpacity;\n    varying vec3 vWorldPosition;\n    \n    void main() {\n      float dist = distance(vWorldPosition.xy, ghostPosition.xy);\n      // FIXED: Match CodePen dynamics exactly\n      float dynamicRadius = revealRadius * 0.3 + sin(time * 2.0) * 1.0;\n      float reveal = smoothstep(dynamicRadius * 0.4, dynamicRadius, dist);\n      reveal = pow(reveal, fadeStrength * 2.5);\n      \n      float finalOpacity = mix(revealOpacity * 0.5, baseOpacity * 0.3, reveal);\n      \n      // FIXED: Blue-tinted atmosphere like CodePen (was near-black)\n      gl_FragColor = vec4(0.0, 0.2, 1.0, finalOpacity * 0.8);\n    }\n  `,\n  transparent: true,\n};\n\nexport function Atmosphere() {\n  const meshRef = useRef<THREE.Mesh>(null!);\n\n  useFrame(({ clock, scene }) => {\n    if (!meshRef.current) return;\n\n    const ghost = scene.getObjectByName('ghost');\n    const mat = meshRef.current.material as THREE.ShaderMaterial;\n\n    mat.uniforms.time.value = clock.getElapsedTime();\n\n    if (ghost) {\n      mat.uniforms.ghostPosition.value.copy(ghost.position);\n    }\n  });\n\n  return (\n    <mesh ref={meshRef} position={[0, 0, -10]}>\n      <planeGeometry args={[100, 100]} />\n      <shaderMaterial attach=\"material\" args={[atmosphereShader]} />\n    </mesh>\n  );\n}\n\nexport default Atmosphere;\n"],"names":[],"mappings":";;;;;;;AAEA;AACA;AACA;AACA;;;AALA;;;;;AAOA,MAAM,mBAAmB;IACvB,UAAU;QACR,eAAe;YAAE,OAAO,IAAI,6JAAa;QAAG;QAC5C,MAAM;YAAE,OAAO;QAAE;QACjB,cAAc;YAAE,OAAO,+IAAY,CAAC,YAAY;QAAC;QACjD,cAAc;YAAE,OAAO,+IAAY,CAAC,YAAY;QAAC;QACjD,aAAa;YAAE,OAAO,+IAAY,CAAC,WAAW;QAAC;QAC/C,eAAe;YAAE,OAAO,+IAAY,CAAC,aAAa;QAAC;IACrD;IACA,cAAc,CAAC;;;;;;;EAOf,CAAC;IACD,gBAAgB,CAAC;;;;;;;;;;;;;;;;;;;;;EAqBjB,CAAC;IACD,aAAa;AACf;AAEO,SAAS;;IACd,MAAM,UAAU,IAAA,uKAAM,EAAa;IAEnC,IAAA,8NAAQ;+BAAC,CAAC,EAAE,KAAK,EAAE,KAAK,EAAE;YACxB,IAAI,CAAC,QAAQ,OAAO,EAAE;YAEtB,MAAM,QAAQ,MAAM,eAAe,CAAC;YACpC,MAAM,MAAM,QAAQ,OAAO,CAAC,QAAQ;YAEpC,IAAI,QAAQ,CAAC,IAAI,CAAC,KAAK,GAAG,MAAM,cAAc;YAE9C,IAAI,OAAO;gBACT,IAAI,QAAQ,CAAC,aAAa,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,QAAQ;YACtD;QACF;;IAEA,qBACE,6LAAC;QAAK,KAAK;QAAS,UAAU;YAAC;YAAG;YAAG,CAAC;SAAG;;0BACvC,6LAAC;gBAAc,MAAM;oBAAC;oBAAK;iBAAI;;;;;;0BAC/B,6LAAC;gBAAe,QAAO;gBAAW,MAAM;oBAAC;iBAAiB;;;;;;;;;;;;AAGhE;GAtBgB;;QAGd,8NAAQ;;;KAHM;uCAwBD"}},
    {"offset": {"line": 1218, "column": 0}, "map": {"version":3,"sources":["file:///Users/danilonovais/_danilonov_portfolio/src/components/canvas/home/hero/AtmosphereVeil.tsx"],"sourcesContent":["'use client';\n\nimport { useRef } from 'react';\nimport { useFrame } from '@react-three/fiber';\nimport * as THREE from 'three';\n\n/**\n * AtmosphereVeil component\n * Creates a \"veil\" that covers the screen and reveals content based on the ghost's position.\n * Aligned with Ghost Era specifications and CodePen visual references.\n */\nexport function AtmosphereVeil() {\n  const materialRef = useRef<THREE.ShaderMaterial>(null!);\n\n  useFrame(({ clock, scene }) => {\n    if (!materialRef.current) return;\n\n    materialRef.current.uniforms.time.value = clock.getElapsedTime();\n\n    const ghost = scene.getObjectByName('ghost');\n    if (ghost) {\n      materialRef.current.uniforms.ghostPosition.value.copy(ghost.position);\n    }\n  });\n\n  const vertexShader = `\n    varying vec2 vUv;\n    varying vec3 vWorldPosition;\n    void main() {\n      vUv = uv;\n      vec4 worldPos = modelMatrix * vec4(position, 1.0);\n      vWorldPosition = worldPos.xyz;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  `;\n\n  const fragmentShader = `\n    uniform vec3 ghostPosition;\n    uniform float revealRadius;\n    uniform float fadeStrength;\n    uniform float baseOpacity;\n    uniform float revealOpacity;\n    uniform float time;\n    varying vec2 vUv;\n    varying vec3 vWorldPosition;\n\n    void main() {\n      float dist = distance(vWorldPosition.xy, ghostPosition.xy);\n      // Small pulse effect on the reveal radius\n      float dynamicRadius = revealRadius + sin(time * 2.0) * 5.0;\n      float reveal = smoothstep(dynamicRadius * 0.2, dynamicRadius, dist);\n      reveal = pow(reveal, fadeStrength);\n      \n      float opacity = mix(revealOpacity, baseOpacity, reveal);\n      \n      // Extremely low RGB to avoid bloom while keeping the \"veil\" effect\n      gl_FragColor = vec4(0.001, 0.001, 0.002, opacity);\n    }\n  `;\n\n  return (\n    <mesh position={[0, 0, -10]} renderOrder={-100}>\n      <planeGeometry args={[300, 300]} />\n      <shaderMaterial\n        ref={materialRef}\n        attach=\"material\"\n        uniforms={{\n          ghostPosition: { value: new THREE.Vector3(0, 0, 0) },\n          revealRadius: { value: 37 },\n          fadeStrength: { value: 1.7 },\n          baseOpacity: { value: 0.9 },\n          revealOpacity: { value: 0.05 },\n          time: { value: 0 },\n        }}\n        vertexShader={vertexShader}\n        fragmentShader={fragmentShader}\n        transparent\n        depthWrite={false}\n      />\n    </mesh>\n  );\n}\n\nexport default AtmosphereVeil;\n"],"names":[],"mappings":";;;;;;;AAEA;AACA;AACA;;;AAJA;;;;AAWO,SAAS;;IACd,MAAM,cAAc,IAAA,uKAAM,EAAuB;IAEjD,IAAA,8NAAQ;mCAAC,CAAC,EAAE,KAAK,EAAE,KAAK,EAAE;YACxB,IAAI,CAAC,YAAY,OAAO,EAAE;YAE1B,YAAY,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,GAAG,MAAM,cAAc;YAE9D,MAAM,QAAQ,MAAM,eAAe,CAAC;YACpC,IAAI,OAAO;gBACT,YAAY,OAAO,CAAC,QAAQ,CAAC,aAAa,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,QAAQ;YACtE;QACF;;IAEA,MAAM,eAAe,CAAC;;;;;;;;;EAStB,CAAC;IAED,MAAM,iBAAiB,CAAC;;;;;;;;;;;;;;;;;;;;;;EAsBxB,CAAC;IAED,qBACE,6LAAC;QAAK,UAAU;YAAC;YAAG;YAAG,CAAC;SAAG;QAAE,aAAa,CAAC;;0BACzC,6LAAC;gBAAc,MAAM;oBAAC;oBAAK;iBAAI;;;;;;0BAC/B,6LAAC;gBACC,KAAK;gBACL,QAAO;gBACP,UAAU;oBACR,eAAe;wBAAE,OAAO,IAAI,6JAAa,CAAC,GAAG,GAAG;oBAAG;oBACnD,cAAc;wBAAE,OAAO;oBAAG;oBAC1B,cAAc;wBAAE,OAAO;oBAAI;oBAC3B,aAAa;wBAAE,OAAO;oBAAI;oBAC1B,eAAe;wBAAE,OAAO;oBAAK;oBAC7B,MAAM;wBAAE,OAAO;oBAAE;gBACnB;gBACA,cAAc;gBACd,gBAAgB;gBAChB,WAAW;gBACX,YAAY;;;;;;;;;;;;AAIpB;GAtEgB;;QAGd,8NAAQ;;;KAHM;uCAwED"}},
    {"offset": {"line": 1353, "column": 0}, "map": {"version":3,"sources":["file:///Users/danilonovais/_danilonov_portfolio/src/components/canvas/home/hero/GhostCanvas.tsx"],"sourcesContent":["'use client';\n\n/**\n * GhostCanvas.tsx\n * ================\n * Wrapper R3F declarativo para a cena Ghost Atmosphere.\n *\n * Este componente encapsula a configuraÃ§Ã£o do Canvas React Three Fiber,\n * permitindo uma arquitetura limpa e separaÃ§Ã£o de responsabilidades.\n *\n * Features:\n * - DPR adaptativo baseado no devicePixelRatio\n * - Fallback para gradiente CSS se WebGL nÃ£o for suportado\n * - Prefers-reduced-motion respeitado\n * - Performance adaptativa via hook\n */\n\nimport { Suspense, memo, useCallback, useState, useEffect } from 'react';\nimport { Canvas } from '@react-three/fiber';\nimport { Preload } from '@react-three/drei';\nimport * as THREE from 'three';\n\nimport { useWebGLSupport } from '@/hooks/useWebGLSupport';\nimport { usePrefersReducedMotion } from '@/hooks/usePrefersReducedMotion';\nimport { usePerformanceAdaptive } from '@/hooks/usePerformanceAdaptive';\nimport { GHOST_CONFIG } from '@/config/ghostConfig';\n\nimport Ghost from './Ghost';\nimport { Atmosphere } from './Atmosphere';\nimport { AtmosphereVeil } from './AtmosphereVeil';\n\n// ConfiguraÃ§Ã£o do Canvas\nconst CANVAS_CONFIG = {\n  fov: GHOST_CONFIG.cameraFov,\n  near: 0.1,\n  far: 1000,\n  position: [0, 0, GHOST_CONFIG.cameraDistance] as [number, number, number],\n} as const;\n\n// Fallback estÃ¡tico para quando WebGL nÃ£o estÃ¡ disponÃ­vel\nfunction StaticFallback() {\n  return (\n    <div\n      className=\"absolute inset-0 z-0 bg-[radial-gradient(circle_at_50%_50%,#0a0029_0%,#040013_70%)]\"\n      aria-hidden=\"true\"\n    />\n  );\n}\n\n// Loader interno do Canvas (enquanto assets carregam)\nfunction CanvasLoader() {\n  return null; // Transparent loading - o Preloader principal cuida disso\n}\n\n// Componente de Cena (dentro do Canvas)\nconst GhostSceneContent = memo(function GhostSceneContent() {\n  const performanceConfig = usePerformanceAdaptive();\n\n  return (\n    <>\n      {/* Atmosfera de fundo */}\n      <Atmosphere />\n\n      {/* VÃ©u atmosfÃ©rico (reveal effect) */}\n      <AtmosphereVeil />\n\n      {/* Ghost principal com partÃ­culas e fireflies */}\n      <Ghost particleCount={performanceConfig.particleCount} />\n\n      {/* IluminaÃ§Ã£o */}\n      <ambientLight\n        color={0x0a0a2e}\n        intensity={GHOST_CONFIG.ambientLightIntensity}\n      />\n      <directionalLight\n        color={0x4a90e2}\n        intensity={GHOST_CONFIG.rimLightIntensity}\n        position={[-8, 6, -4]}\n      />\n      <directionalLight\n        color={0x50e3c2}\n        intensity={GHOST_CONFIG.rimLightIntensity * 0.7}\n        position={[8, -4, -6]}\n      />\n\n      {/* Preload de assets */}\n      <Preload all />\n    </>\n  );\n});\n\n// Props do componente principal\ninterface GhostCanvasProps {\n  /** Callback quando o Canvas termina de inicializar */\n  onCreated?: () => void;\n  /** Classe CSS adicional */\n  className?: string;\n}\n\n/**\n * GhostCanvas - Wrapper R3F para a atmosfera Ghost\n *\n * Uso:\n * ```tsx\n * <GhostCanvas onCreated={() => setIsLoaded(true)} />\n * ```\n */\nconst GhostCanvas = memo(function GhostCanvas({\n  onCreated,\n  className = '',\n}: GhostCanvasProps) {\n  const supportsWebGL = useWebGLSupport();\n  const prefersReducedMotion = usePrefersReducedMotion();\n  const performanceConfig = usePerformanceAdaptive();\n  const [isReady, setIsReady] = useState(false);\n\n  // Callback de criaÃ§Ã£o do Canvas\n  const handleCreated = useCallback(\n    (state: { gl: THREE.WebGLRenderer }) => {\n      // Configurar renderer\n      state.gl.toneMapping = THREE.ACESFilmicToneMapping;\n      state.gl.toneMappingExposure = 0.9;\n      state.gl.setClearColor(0x000000, 0);\n\n      setIsReady(true);\n      onCreated?.();\n    },\n    [onCreated]\n  );\n\n  // Se preferir movimento reduzido ou WebGL nÃ£o suportado, mostrar fallback\n  useEffect(() => {\n    if (!supportsWebGL || prefersReducedMotion) {\n      // Ainda dispara o callback para nÃ£o bloquear o fluxo\n      onCreated?.();\n    }\n  }, [supportsWebGL, prefersReducedMotion, onCreated]);\n\n  // Fallback para dispositivos sem WebGL ou com prefers-reduced-motion\n  if (!supportsWebGL || prefersReducedMotion) {\n    return <StaticFallback />;\n  }\n\n  return (\n    <div\n      className={`absolute inset-0 z-0 transition-opacity duration-500 ease-out ${isReady ? 'opacity-100' : 'opacity-0'} ${className}`}\n    >\n      <Canvas\n        dpr={performanceConfig.pixelRatio}\n        gl={{\n          antialias: performanceConfig.quality === 'high',\n          powerPreference: 'high-performance',\n          alpha: true,\n          premultipliedAlpha: false,\n          stencil: false,\n          depth: true,\n          preserveDrawingBuffer: false,\n        }}\n        camera={{\n          fov: CANVAS_CONFIG.fov,\n          near: CANVAS_CONFIG.near,\n          far: CANVAS_CONFIG.far,\n          position: CANVAS_CONFIG.position,\n        }}\n        className=\"absolute! inset-0! w-full! h-full! pointer-events-none!\"\n        onCreated={handleCreated}\n      >\n        <Suspense fallback={<CanvasLoader />}>\n          <GhostSceneContent />\n        </Suspense>\n      </Canvas>\n    </div>\n  );\n});\n\nexport { GhostCanvas };\nexport default GhostCanvas;\n"],"names":[],"mappings":"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"}}]
}